<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="OpenTezos Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="OpenTezos Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Coq, GADT and Mi-Cho-Coq | OpenTezos</title><meta data-react-helmet="true" property="og:url" content="https://opentezos.com/formal-verification/gadt-coq"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Coq, GADT and Mi-Cho-Coq | OpenTezos"><meta data-react-helmet="true" name="description" content="To better understand formal verification, let&#x27;s first describe the theory and tools behind the formal analysis."><meta data-react-helmet="true" property="og:description" content="To better understand formal verification, let&#x27;s first describe the theory and tools behind the formal analysis."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://opentezos.com/formal-verification/gadt-coq"><link data-react-helmet="true" rel="alternate" href="https://opentezos.com/formal-verification/gadt-coq" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://opentezos.com/formal-verification/gadt-coq" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.d7943943.css">
<link rel="preload" href="/assets/js/runtime~main.e4f1d814.js" as="script">
<link rel="preload" href="/assets/js/main.cec49b6e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo-dark.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/octo-technology/OpenTezos/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">üåô</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">‚òÄÔ∏è</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo-dark.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a href="https://github.com/octo-technology/OpenTezos/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Welcome</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/">Modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/paths">Paths</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Blockchain Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/main-properties">Main properties of the first &quot;blockchain&quot;</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/proof-of-work">Proof-of-work</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/other-consensuses">Introduction to other consensuses</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/smart-contracts">Smart Contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tezos Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/smart-contracts">Smart contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/liquid-proof-of-stake">Liquid Proof-of-Stake</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/operations">Operations</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/cli-and-rpc">CLI and RPC</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/governance-on-chain">Governance on-chain</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/history-of-amendments">History of amendments</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/economics-and-rewards">Economics and rewards</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Deploy a node</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/deploy-a-node">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/deploy-a-node/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">How to use an Explorer</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/introduction">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/indexer-explained">How Indexers Work?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/available-tezos-indexers">Available Tezos Explorers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/tzstats-main-features">How to use the tzStats blockchain explorer?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/tzstats-smart-contract">Checkout your smart contract on TzStats</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/private-indexer">Private indexer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">SmartPy</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/write-contract-smartpy">Smart contract development with SmartPy</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">LIGO</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/write-contracts-ligo">Smart contract development in Pascaligo</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/language-basics">Language basics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/deploy-a-contract">Smart Contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/unit-testing">Unit Testing with PyTezos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/examples">Examples</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/exam">Exam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/take-away">Take Away</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Michelson</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/smart-contracts">Smart Contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/tutorial">Tutorial</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/examples">Examples</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/instructions-reference">Instructions Reference</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/exam">Exam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/take-away">Take away</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Build a Dapp</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/truffle_compilation_migration">Smart contract deployment with Truffle</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Baking</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Deploy Bakers</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baker">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baker/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">DeFi</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/token-standards">Token Standards</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/dexs">Decentralized Exchanges</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/wrapped-assets">Wrapped Assets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/cross-chain-swaps">Cross-chain Swaps</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/oracles">On-chain Oracles</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/stablecoins">Stablecoins</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/synthetics">Synthetics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/lending">Lending and Flash Loans</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/exam">Exam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Formal Verification</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification">Introduction</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/formal-verification/gadt-coq">Coq, GADT and Mi-Cho-Coq</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification/modeling-theorem">Formal verification on smart contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Private Blockchain</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/private">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/private/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">How to contribute</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/report-issue">Report an issue</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/opentezos">Contribute to OpenTezos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/tezos-core">Contribute to the Tezos Core Protocol</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/grant">Receive a grant</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/baker">Become a baker or a delegator</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/exam">Exam</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Coq, GADT and Mi-Cho-Coq</h1></header><div class="markdown"><p>To better understand formal verification, let&#x27;s first describe the theory and tools behind the formal analysis.</p><p>In order to perform a formal verification, we need a <em>proof assistant</em>. <em>Coq</em> is the default proof assistant for formal verification on Tezos smart contracts. <em>Coq</em> provides a language for defining theorems and for proving these theorems. The proof process relies on:</p><ul><li><p>A theory (i.e. a base foundation of mathematic): We will introduce a branch of mathematics called <strong>Type theory</strong>, and more specifically, the <em>Calculus of Construction</em> (CoC), the building principle of <em>Coq</em>.</p></li><li><p>An expression of the Michelson language as a formal definition: We use <em>GADT</em> for the theory and <em>Mi-Cho-Coq</em> in practice.</p></li><li><p>A formalization of the Michelson script into a theorem to prove this theorem (we&#x27;ll see this in the next <a href="/formal-verification/modeling-theorem">chapter</a>).
//TODO: What is the script? Is it the smart contract?</p></li></ul><p>The goal is to:</p><ul><li><p>provide a solid type-checking mechanism of a Michelson script based on formal rules.</p></li><li><p>ensure the semantic of the script by verifying post-conditions (in the next <a href="/formal-verification/modeling-theorem">section</a>).</p></li></ul><p>This section intends to give:</p><ul><li>a theoretical context about the mathematical principles (CoC, CiC) used in the formal proof process of <em>Coq</em></li><li>a bit of insight on how a language is designed with a <em>GADT</em></li><li>a brief description of the <em>Coq</em> proof assistant</li><li>a brief description of <em>Mi-Cho-Coq</em> (library for <em>Coq</em>)</li></ul><p>For a good understanding of this theoretical part, it is recommended to have some notions on first-order and second-order logic <a href="/formal-verification/gadt-coq#references">[10]</a>, mathematics (e.g. set, group, monoid, associativity, distributivity, reflexivity), functional programming, and language theory.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="type-theory"></a>Type theory<a class="hash-link" href="#type-theory" title="Direct link to heading">#</a></h3><p>In mathematics, logic and computer science, a <em>type system</em> is a formal system in which every term has a <strong>type</strong>. The type defines the meaning and the operations that can be performed on it. <strong>Type theory</strong> is the academic study of type systems.</p><p>Type theory is closely linked to many fields of active research, including the Curry‚ÄìHoward correspondence <a href="/formal-verification/gadt-coq#references">[6] [7]</a> that provides a deep isomorphism between <em>intuitionistic logic</em>, typed <em>Œª-calculus</em> and <em>cartesian closed categories</em>. </p><p>Some type theories serve as alternatives to set theory as a foundation of mathematics. Two famous theories are <em>Alonzo Church&#x27;s typed Œª-calculus</em> and <em>Per Martin-L√∂f&#x27;s intuitionistic type theory</em>. The <em>Per Martin-L√∂f&#x27;s intuitionistic type theory</em> has been the foundation of constructive mathematics. For instance, Thierry Coquand&#x27;s <strong>Calculus of constructions</strong> and its derivatives are the foundation used by <strong>Coq</strong> (the proof assistant) <a href="/formal-verification/gadt-coq#references">[1]</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="coq"></a>Coq<a class="hash-link" href="#coq" title="Direct link to heading">#</a></h3><p>Initially developed by Thierry Coquand, <em>Coq</em> <a href="/formal-verification/gadt-coq#references">[1]</a> is a proof assistant designed to develop mathematical proofs, and especially to write formal specifications, programs, and proofs. Programs chave to comply to their specifications. </p><p>Properties, programs, and proofs are formalized in the <em>Coq</em> language called <em>Gallina</em>, which follows the <em>Calculus of Inductive Constructions</em> (CIC).</p><p>//TODO: What are &quot;properties&quot;, &quot;programs&quot; and &quot;proofs&quot; ?</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="coc---cic"></a>CoC - CiC<a class="hash-link" href="#coc---cic" title="Direct link to heading">#</a></h4><p>Initially developed by Thierry Coquand, the <em>Calculus of Constructions</em> <a href="/formal-verification/gadt-coq#references">[13]</a> (or CoC) is a typed high-order <em>Œª-calculus</em> (i.e. a typed formal system taking the logic of second-order into account). The CoC is used as a typed programming language. </p><p>Many derivatives of CoC have been created to handle inductive types, predicates and co-inductive types. The CIC (<a href="/formal-verification/gadt-coq#references">[18]</a>) is an extension of CoC which integrates inductive datatype. The <em>Coq</em> proof assistant is built upon CiC.</p><p>All logical judgments in Coq are typing judgments: the very heart of <em>Coq</em> is, in fact, a type-checking algorithm. </p><p>An interesting additional feature of <em>Coq</em> is that it can automatically extract executable programs from specifications, either as <em>OCaml</em> or as <em>Haskell</em> source code.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="gallina-term-and-vernacular"></a>Gallina (Term and Vernacular)<a class="hash-link" href="#gallina-term-and-vernacular" title="Direct link to heading">#</a></h4><p>Logical objects (such as theorems, axioms) are formalized in Gallina-Term language, and proof scripts are formalized in Gallina-Vernacular language, which provides <em>tactics</em>.</p><p>The <em>Coq</em> inference engine executes the proof script. In the case of a Tezos smart contract, the inference engine relies on the Coq universe and the <em>Mi-Cho-Coq</em> library. </p><p>For more information about the CoC and CiC foundation, it is recommended to read the official paper from Thierry Coquand and other documentation <a href="/formal-verification/gadt-coq#references">[13] [16] [18]</a>. It is required to know the basis of Œª-calculus <a href="/formal-verification/gadt-coq#references">[17]</a> in order to understand mathematical notations used in CoC and CiC.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="gadt"></a>GADT<a class="hash-link" href="#gadt" title="Direct link to heading">#</a></h3><p>Generalized algebraic data type (GADT) is a generalization of parametric algebraic data types (i.e. a standard representation of algebraic data types).</p><p>The idea of <strong>algebraic data types</strong> is to define a language as a composite type and formalize an algebra of data types (like the algebra on numbers). The programming language can be seen as a complex-type with functors.</p><p>An essential application of GADTs is to embed <strong>higher-order abstract syntax</strong> in a type-safe fashion.</p><p>In computer science, <strong>higher-order abstract syntax</strong> (abbreviated HOAS) is a technique for the representation of abstract syntax trees for languages with variable binders. </p><p>This article <a href="/formal-verification/gadt-coq#references">[8]</a> describes how to define an <strong>higher-order abstract syntax</strong> in <em>Coq</em> (i.e., defining axioms, and inductive types).
GADT is similar to inductive families of data types (or inductive data types) found in <em>Coq</em>&#x27;s CIC <a href="/formal-verification/gadt-coq#references">[18]</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="algebraic-data-type"></a>Algebraic Data Type<a class="hash-link" href="#algebraic-data-type" title="Direct link to heading">#</a></h4><p>In computer programming, and especially functional programming and type theory, an <strong>algebraic data type</strong> is a kind of composite type, (i.e., a type formed by combining other types).</p><p>Two common classes of algebraic types are product types (i.e., tuples and records) and sum types (i.e., tagged or disjoint unions, coproduct types or variant types).</p><p>The values of a product type typically contain several values, called <strong>fields</strong>. All values of that type have the same combination of field types. The set of all possible values of a product type is the set-theoretic product, i.e., the Cartesian product, of the sets of all possible values of its field types.</p><p>The values of a sum type are typically grouped into several classes, called <strong>variants</strong>. A value of a variant type is created with a quasi-functional entity called a constructor. Each variant has its own constructor, which takes a specified number of arguments with specified types. The set of all possible values of a sum type is the set-theoretic sum, i.e., the disjoint union, of the sets of all possible values of its variants.  </p><p>The <em>Algebraic Data Type</em> (ADT) formalizes a language into a composite type and describes possible operations on data types.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="example-with-michelson-pairs-and-variants"></a>Example with Michelson pairs and variants<a class="hash-link" href="#example-with-michelson-pairs-and-variants" title="Direct link to heading">#</a></h4><p>Let&#x27;s illustrate the ADT formalization by defining a set with PRODUCT (a product type) and SUM (a sum type) thus forming a <em>semi-ring</em> that can model Michelson language structures (<em>Pairs</em> and <em>Variants</em>). Defining Michelson data structures as an ADT provides a robust type-checking mechanism on Michelson scripts.</p><p>The Michelson language can be modeled as a mathematical object (set) with a set of rules (PRODUCT and SUM) describing possible operations on datatypes. </p><p>PRODUCT type = <code>(a b)</code> (i.e., Michelson pair)</p><ul><li>reflexivity: (up to an isomorphism) <em>swap</em> : <code>(a b) ~ (b a)</code></li><li>associativity: (up to an isomorphism) <em>assoc</em> :  <code>((a, b), c) ~ (a, (b, c))</code></li><li>neutral element: (up to an isomorphism) <em>first</em> : <code>(a,()) ~ a</code></li></ul><p>Programmatically speaking, a tuple <code>(int bool)</code> does not match a tuple <code>(bool int)</code>, but both contain the same information. These two tuples are equivalent up to an isomorphism (which is the function &quot;swap&quot;; i.e. <code>swap x = (snd x, fst x)</code>). Notice that the inverse function of <em>swap</em> is <em>swap</em>. Also <em>assoc</em> and <em>first</em> are invertible (up to an isomorphism).</p><p>SUM type = (Either a b); <code>Either a b = Left a | Right b</code> (i.e. variant)</p><ul><li>reflexivity: <code>Either a b ~ Either b a</code> </li><li>neutral element (<code>Void</code>): <code>Either a Void ~ a</code> (there is no element in the set Void) equivalent to <code>a + 0 = a</code></li><li>associativity: (i.e. <code>triple (a b c) = Left a | Right c | Middle b</code>)</li><li>distributivity: <code>(a,Either(b,c)) ~ Either (a,b) (a,c)</code> is equivalent to <code>(a * (b + c) = a*b + a*c)</code></li><li><code>(a, Void) ~ Void</code> is equivalent to <code>a * 0 = 0</code></li></ul><p>Notice that the variant (&quot;Either&quot; concept) can be combined with pairs due to the distributivity rule.
For the PRODUCT type, properties (associativity, distributivity) are respected up to an isomorphism that is invertible (i.e., an inverse function exists for each isomorphism). </p><p>For example, the &quot;triple&quot; function compose a variant from three elements. The function &quot;triple_inv&quot; decompose a triple in a nested pair containing the three elements: <code>triple_inv x = ((Left(x) Middle(x)) Right(x))</code>. <code>triple (a (b c)) = Left a | Right c | Middle b</code>.</p><p>So, a set equipped with PRODUCT and SUM represents a language equipped with <em>pairs</em> and <em>variants</em> (such as Michelson language). </p><blockquote><p>Other language structures such as <em>List</em> can be defined using the <em>List Monad pattern</em>.  </p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="a-semi-ring-to-generalize-michelson-language"></a>A semi-ring to generalize Michelson language<a class="hash-link" href="#a-semi-ring-to-generalize-michelson-language" title="Direct link to heading">#</a></h4><p>In algebra, a set equipped with PRODUCT and SUM is a semi-ring. Notice that the inverse of SUM has no meaning (subtraction <code>a - b</code> is not permitted; programmatically speaking, removing an integer from a structure that has no integer field has no meaning). That&#x27;s why the set equipped with PRODUCT and SUM is just a semi-ring and not a ring (due to the missing relation <code>a + inv(a) ~ Void</code> where <code>inv(a)</code> does not exist).</p><blockquote><p>Formally speaking, a ring is an <em>abelian</em> group whose operation is called <em>addition</em>, with a second binary operation called <em>multiplication</em> that is associative, distributive over the <em>addition</em> operation, and has a multiplicative identity element. </p></blockquote><p>In mathematics, <strong>rings are algebraic structures that generalize fields</strong>: multiplication need not be commutative and multiplicative inverses do not have to exist. In other words, a ring is a set equipped with two binary operations satisfying properties analogous to those of addition and multiplication of integers. Ring elements may be numbers, such as integers or complex numbers, but they may also be non-numerical objects, such as polynomial numbers or functions.</p><p>To conclude, the formalization of a language into an algebra of data types (ADT) allows to specify a mathematical representation of a language; and thus allows to use CoC principles to prove theorems on this algebra (i.e., verifying a script in this language). The <strong>Mi-Cho-Coq</strong> library is the formal <em>Coq</em> representation of the Michelson language and allows to specify a formal representation of a Tezos smart contract.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="mi-cho-coq"></a>Mi-Cho-Coq<a class="hash-link" href="#mi-cho-coq" title="Direct link to heading">#</a></h3><p>The <em>Mi-Cho-Coq</em> library represents the bridge between Tezos smart contracts and formal proofs in Coq.</p><p>The <em>Mi-Cho-Coq</em> library <a href="/formal-verification/gadt-coq#references">[2]</a> is a formalization of the Michelson language <a href="/formal-verification/gadt-coq#references">[9]</a> using the Coq interactive theorem prover <a href="/formal-verification/gadt-coq#references">[1]</a>.</p><p>In practice, the <em>Mi-Cho-Coq</em> library is used to produce a formal definition of a Michelson script (i.e., the &quot;Modeling theorem&quot; <a href="/formal-verification/modeling-theorem#Example_vote">section</a>). Each Michelson instruction has its equivalent in the <em>Mi-Cho-Coq</em> library (e.g. see the syntax <a href="/formal-verification/gadt-coq#Syntax">subsection</a>).</p><p>The <em>Mi-Cho-Coq</em> library provides a formal definition (in Gallina) of the <strong>type system</strong> (Michelson types), the <strong>syntax</strong> (instructions of the Michelson), the <strong>semantics</strong> (evaluator) and the lexing and parsing (for type-checking).</p><blockquote><p>It is recommended to have notions of <em>Language theory</em> in order to understand the following Mi-Cho-Coq definition (grammar rules).</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="type-system"></a>Type system<a class="hash-link" href="#type-system" title="Direct link to heading">#</a></h4><p>The <strong>type system</strong> consists of the definition of types (comparable types and non-comparable ones).</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Inductive simple_comparable_type : Set :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| string</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| nat</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| int</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| bytes</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">...</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Inductive comparable_type : Set :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| Comparable_type_simple : simple_comparable_type -&gt; comparable_type</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| Cpair : simple_comparable_type -&gt; comparable_type -&gt; comparable_type.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Inductive type : Set :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| Comparable_type (_ : simple_comparable_type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| key</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| unit</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| signature</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| option (a : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| list (a : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| set (a : comparable_type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| contract (a : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| operation</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| pair (a : type) (b : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| or (a : type) (_ : annot_o) (b : type) (_ : annot_o)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| lambda (a b : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| map (k : comparable_type) (v : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| big_map (k : comparable_type) (v : type)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| chain_id.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="syntax"></a>Syntax<a class="hash-link" href="#syntax" title="Direct link to heading">#</a></h4><p>The *<strong>*syntax</strong> and typing of Michelson instructions are formalized as a dependent inductive type to rule out ill-typed instructions.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Inductive instruction :</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  forall (self_type : Datatypes.option type) (tail_fail_flag : Datatypes.bool) (A B : Datatypes.list type), Set :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| NOOP {A} : instruction A A</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| FAILWITH {A B a} : instruction (a ::: A) B</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| SEQ {A B C} : instruction A B -&gt; instruction B C -&gt; instruction A C</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| IF_ {A B} : instruction A B -&gt; instruction A B -&gt; instruction (bool ::: A) B</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">| LOOP {A} : instruction A (bool ::: A) -&gt; instruction (bool ::: A) A</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">...</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="semantics"></a>Semantics<a class="hash-link" href="#semantics" title="Direct link to heading">#</a></h4><p>The <strong>semantics</strong> of types is defined by interpreting them with predefined <em>Coq</em> types (e.g. int -&gt; Z, nat -&gt; N, mutez -&gt; int63). The semantics of Michelson is defined by an evaluator <code>eval</code> formalized as a <em>Fixpoint</em>. </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Fixpoint eval {self_type} {tff} {env} {A : stack_type} {B : stack_type}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">         (i : instruction self_type tff A B) (fuel : Datatypes.nat) {struct fuel} :</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  stack A -&gt; M (stack B) :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  match fuel with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | O =&gt; fun SA =&gt; Failed _ Out_of_fuel</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | S n =&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    match i, SA, env with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | FAILWITH, (x, _), _ =&gt; Failed _ (Assertion_Failure _ x)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | NOOP, SA, _ =&gt; Return SA</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | DUP, (x, SA), _ =&gt; Return (x, (x, SA))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | SWAP, (x, (y, SA)), _ =&gt; Return (y, (x, SA))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | PUSH a x, SA, _ =&gt; Return (concrete_data_to_data _ x, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | UNIT, SA, _ =&gt; Return (tt, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | LAMBDA a b code, SA, _ =&gt; Return (existT _ _ code, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | EQ, (x, SA), _ =&gt; Return ((x =? 0)%Z, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | NEQ, (x, SA), _ =&gt; Return (negb (x =? 0)%Z, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | LT, (x, SA), _ =&gt; Return ((x &lt;? 0)%Z, SA)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        | SEQ B C, SA, env =&gt; </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        let! r := eval env B n SA in</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        eval env C n r</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | IF_ bt bf, (b, SA), env =&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if b then eval env bt n SA else eval env bf n SA</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    | LOOP body, (b, SA), env =&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        if b then eval env (body;; (LOOP body)) n SA else Return SA</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">...</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>//TODO: I didn&#x27;t understand a single thing in the code examples above...</p><blockquote><p>Since evaluating a Michelson instruction might fail (whereas <em>Coq</em> functions cannot), the return type of this evaluator is wrapped in an exception monad (handling errors such as overflow, lexing, parsing, fuel).</p></blockquote><blockquote><p>Coq forbids non-terminating functions, so we use a common <em>Coq</em> trick to define the evaluator on diverging instructions such as <em>LOOP</em>: we make the evaluator structurally recursive on an extra argument of type Datatypes.nat called the <strong>fuel</strong> of the evaluator.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="conclusion"></a>Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h2><p>//TODO: Conclusion, small summary of this chapter and what&#x27;s next</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="references"></a>References<a class="hash-link" href="#references" title="Direct link to heading">#</a></h2><p>[1] Coq - <a href="https://coq.inria.fr/distrib/current/refman/index.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/index.html</a></p><p>[2] Mi-cho-coq repository - <a href="https://gitlab.com/nomadic-labs/mi-cho-coq" target="_blank" rel="noopener noreferrer">https://gitlab.com/nomadic-labs/mi-cho-coq</a></p><p>[3] Introduction to Coq - <a href="http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf" target="_blank" rel="noopener noreferrer">http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf</a></p><p>[4] Gallina - <a href="https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html</a></p><p>[5] Lambda-Calculus and Isomorphism Curry-Howard - <a href="http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf" target="_blank" rel="noopener noreferrer">http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf</a></p><p>[6] Isomorphism Curry-Howard for Dummies - <a href="https://www.p%C3%A9drot.fr/slides/inria-junior-02-15.pdf" target="_blank" rel="noopener noreferrer">https://www.p√©drot.fr/slides/inria-junior-02-15.pdf</a></p><p>[7] Isomorphism Curry-Howard (small) - <a href="https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf" target="_blank" rel="noopener noreferrer">https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf</a></p><p>[8] Higher-order abstract syntax in Coq - <a href="https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps" target="_blank" rel="noopener noreferrer">https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps</a></p><p>[9] Michelson - <a href="https://tezos.gitlab.io/michelson-reference/" target="_blank" rel="noopener noreferrer">https://tezos.gitlab.io/michelson-reference/</a></p><p>[10] Logique formelle - <a href="https://www.irif.fr/~roziere/2ord/2ndordre.pdf" target="_blank" rel="noopener noreferrer">https://www.irif.fr/~roziere/2ord/2ndordre.pdf</a></p><p>[12] Axioms de Peano - <a href="https://fr.wikipedia.org/wiki/Axiomes_de_Peano" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Axiomes_de_Peano</a></p><p>[13] Calculus of constructions - <a href="https://fr.wikipedia.org/wiki/Calcul_des_constructions" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Calcul_des_constructions</a></p><p>[14] Mini-guide Coq - <a href="https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf" target="_blank" rel="noopener noreferrer">https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf</a></p><p>[15] Coq‚ÄôArt - <a href="https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf" target="_blank" rel="noopener noreferrer">https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf</a></p><p>[16] The calculus of constructions (1988) by Thierry Coquand - <a href="https://www.sciencedirect.com/science/article/pii/0890540188900053" target="_blank" rel="noopener noreferrer">https://www.sciencedirect.com/science/article/pii/0890540188900053</a></p><p>[17] Lambda-calcul - <a href="https://fr.wikipedia.org/wiki/Lambda-calcul" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Lambda-calcul</a></p><p>[18] Calculus of Inductive Constructions - <a href="https://coq.inria.fr/distrib/current/refman/language/cic.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/language/cic.html</a></p><p>[19] Michelson - <a href="https://www.michelson-lang.com/why-michelson.html" target="_blank" rel="noopener noreferrer">https://www.michelson-lang.com/why-michelson.html</a></p><p>[20] Vote example - <a href="https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v" target="_blank" rel="noopener noreferrer">https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/octo-technology/OpenTezos/tree/main/docs/formal-verification/gadt-coq.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-05-19T22:48:57.000Z" class="lastUpdatedDate_1WI_">5/20/2021</time> by <strong>AymericBethencourt</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/formal-verification"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Introduction</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/formal-verification/modeling-theorem"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Formal verification on smart contracts ¬ª</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#type-theory" class="table-of-contents__link">Type theory</a></li><li><a href="#coq" class="table-of-contents__link">Coq</a></li><li><a href="#gadt" class="table-of-contents__link">GADT</a></li><li><a href="#mi-cho-coq" class="table-of-contents__link">Mi-Cho-Coq</a></li><li><a href="#conclusion" class="table-of-contents__link">Conclusion</a></li><li><a href="#references" class="table-of-contents__link">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2021 OpenTezos.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e4f1d814.js"></script>
<script src="/assets/js/main.cec49b6e.js"></script>
</body>
</html>