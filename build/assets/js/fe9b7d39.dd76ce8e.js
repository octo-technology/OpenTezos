(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[1976],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return p},kt:function(){return f}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(t),f=o,h=d["".concat(c,".").concat(f)]||d[f]||u[f]||s;return t?a.createElement(h,r(r({ref:n},p),{},{components:t})):a.createElement(h,r({ref:n},p))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,r=new Array(s);r[0]=d;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var l=2;l<s;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9158:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return r},metadata:function(){return i},toc:function(){return c},default:function(){return p}});var a=t(2122),o=t(9756),s=(t(7294),t(3905)),r={id:"basics",disable_pagination:!0,title:"Build a dapp - basics"},i={unversionedId:"dapp/basics",id:"dapp/basics",isDocsHomePage:!1,title:"Build a dapp - basics",description:"Now that we have a deployed contract and a ready-to-use Wallet, we can start to develop the frontend part of the dapp: it will interact",source:"@site/docs/dapp/front.md",sourceDirName:"dapp",slug:"/dapp/basics",permalink:"/dapp/basics",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/dapp/front.md",version:"current",lastUpdatedBy:"Theotime-Akeare",lastUpdatedAt:1623317038,formattedLastUpdatedAt:"6/10/2021",frontMatter:{id:"basics",disable_pagination:!0,title:"Build a dapp - basics"},sidebar:"docs",previous:{title:"Temple Wallet",permalink:"/dapp/temple"},next:{title:"Build a dapp - User Experience",permalink:"/dapp/front_user_experience"}},c=[{value:"Wallet connexion",id:"wallet-connexion",children:[]},{value:"Wallet information",id:"wallet-information",children:[]},{value:"Big map handling",id:"big-map-handling",children:[]},{value:"New raffle information",id:"new-raffle-information",children:[{value:"DatePicker installation",id:"datepicker-installation",children:[]},{value:"Form creation",id:"form-creation",children:[]}]},{value:"New raffle button",id:"new-raffle-button",children:[{value:"web3 installation",id:"web3-installation",children:[]},{value:"Implementation",id:"implementation",children:[]}]},{value:"End-to-end testing",id:"end-to-end-testing",children:[]},{value:"Implementation",id:"implementation-1",children:[]},{value:"End-to-end testing",id:"end-to-end-testing-1",children:[]}],l={toc:c};function p(e){var n=e.components,r=(0,o.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},l,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Now that we have a deployed contract and a ready-to-use Wallet, we can start to develop the frontend part of the dapp: it will interact\nwith the deployed, raffle smart contract."),(0,s.kt)("p",null,"This chapter is not a tutorial about React, nor how to build a nice UI: its purpose is to shows the basics usage of the Temple Wallet in a dapp use case. Thus, it requires some knowledge about ",(0,s.kt)("a",{parentName:"p",href:"https://www.w3schools.com/css/"},"CSS"),", ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/getting-started.html"},"React")," and ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"React Hooks"),"."),(0,s.kt)("h1",{id:"project-initialisation"},"Project initialisation"),(0,s.kt)("p",null,"Let's create a React project. To do that, we can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"npx create-react-app")," command. We will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"typescript")," template:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ npx create-react-app my-dapp --template typescript #create project\n$ cd my-dapp\n$ yarn start # run project\n")),(0,s.kt)("p",null,"We have a running React application, that displays texts. So far, it doesn't do anything. The first step to begin is to integrate the Temple Wallet within our application."),(0,s.kt)("h1",{id:"temple-integration"},"Temple Integration"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@temple-wallet/dapp"},"temple-wallet/dapp")," module enables a React application to use the Temple Wallet to interact with a Tezos blockchain. This module uses the ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@taquito/taquito"},"@taquito/taquito")," and ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/constate"},"constate"),". Let's install this module:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add @temple-wallet/dapp\n$ yarn add @taquito/taquito\n$ yarn add constate\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("em",{parentName:"p"},"Madfish Solutions")," team provides developers with a ready-to-use script, which integrates the Temple Wallet into our React app:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js"},"https://github.com/madfish-solutions/counter-dapp/blob/master/src/dapp.js")),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp")," folder into ",(0,s.kt)("inlineCode",{parentName:"p"},"src/"),", and put the dapp.js file into it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ mkdir src/dapp\n$ cd src/dapp\n$ curl https://raw.githubusercontent.com/madfish-solutions/counter-dapp/master/src/dapp.js -O\n")),(0,s.kt)("p",null,"It exports a ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html"},"React context")," and the necessary functions to interact with a Tezos\nnetwork:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"DAppProvider"),": a react context that will contain all the below hooks"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useWallet"),": it returns a Wallet instance"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useTezos"),": returns a TezosToolkit, using the wallet instance"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useAccountPkh"),": returns the current wallet account address"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useReady"),": returns a boolean indicating if the wallet is connected to the tezos network"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useConnect"),": react callback to change the user account"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"useOnBlock"),": react effect to retrieve the latest baked block. It subscribe to the stream of blocks (watching head),\nthanks to the ",(0,s.kt)("inlineCode",{parentName:"li"},"SubscribeProvider")," ",(0,s.kt)("em",{parentName:"li"},"Taquito")," class.")),(0,s.kt)("p",null,"These hooks will connect our React frontend to the Temple Wallet extension."),(0,s.kt)("p",null,"Let's modify the src/App.tsx.\nWe will remove all the HTML elements and add the ",(0,s.kt)("inlineCode",{parentName:"p"},"DAppProvider")," context, from the ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js")," file."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// dapp/dapp.js\nfunction useDApp({ appName }) {\n  const [{ wallet, tezos, accountPkh }, setState] = React.useState(() => ({\n    wallet: undefined,\n    tezos: undefined,\n    accountPkh: undefined,\n  }))\n\n  const ready = Boolean(tezos)\n\n  React.useEffect(() => {\n    return TempleWallet.onAvailabilityChange((available) => {\n      setState({\n        wallet: available ? new TempleWallet(appName) : undefined,\n        tezos: undefined,\n        accountPkh: undefined,\n      })\n    })\n  }, [setState, appName])\n\n//...\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useDApp"),' expects one argument, which is the app name. Let\'s call our application "Raffle", and put its name into a constants file in ',(0,s.kt)("inlineCode",{parentName:"p"},"src/dapp/default.ts")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\n")),(0,s.kt)("p",null,"We can add the context into ",(0,s.kt)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"// src/App.tsx\nimport React from 'react';\nimport { DAppProvider } from \"dapp/dapp\";\nimport { APP_NAME } from './dapp/defaults';\nimport './App.css';\n\nfunction App() {\n    return (\n        <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n\n            </React.Suspense>\n        < /DAppProvider>\n    );\n}\n\nexport default App;\n\n")),(0,s.kt)("p",null,"Now that we have our context, we can start using the provided hooks."),(0,s.kt)("h2",{id:"wallet-connexion"},"Wallet connexion"),(0,s.kt)("p",null,"The first step is to connect your react app to the ",(0,s.kt)("em",{parentName:"p"},"Temple Wallet"),"."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Page")," component, that will contain all our components:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider } from './dapp/dapp'\nimport './App.css';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page> </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,s.kt)("p",null,"Let's add a connexion button: when clicked, the app will connects to the ",(0,s.kt)("em",{parentName:"p"},"Temple Wallet"),".\nWe will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," hook from ",(0,s.kt)("inlineCode",{parentName:"p"},"src/dapp/dapp.js"),". Let's take a look at this callback definition:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// src/dapp/dapp.js\nconst connect = React.useCallback(\n    async (network, opts) => {\n      try {\n        if (!wallet) {\n          throw new Error('Thanos Wallet not available')\n        }\n        await wallet.connect(network, opts) // expects a network and some options\n        const tzs = wallet.toTezos()\n        const pkh = await tzs.wallet.pkh()\n        setState({\n          wallet,\n          tezos: tzs,\n          accountPkh: pkh,\n        })\n      } catch (err) {\n        console.error(`Failed to connect ThanosWallet: ${err.message}`)\n      }\n    },\n    [setState, wallet],\n  )\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," expects two arguments: a Tezos network and some options. Let's define a ",(0,s.kt)("inlineCode",{parentName:"p"},"NETWORK"),"'s global variable into ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/default.ts")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/dapp/default.ts\nexport const APP_NAME = 'Raffle';\nexport const NETWORK = 'edo2net';\n")),(0,s.kt)("p",null,"Our smart contract is deployed on ",(0,s.kt)("em",{parentName:"p"},"Edonet"),": the network is therefore set to ",(0,s.kt)("inlineCode",{parentName:"p"},"edo2net"),"."),(0,s.kt)("p",null,"We can now use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useConnect")," callback. We can define a ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnexionButton")," component that will execute a connexion callback when clicked.\nThe application connects the wallet to the specified ",(0,s.kt)("inlineCode",{parentName:"p"},"NETWORK")," (",(0,s.kt)("em",{parentName:"p"},"Edonet")," in our case).\nWe should add the option ",(0,s.kt)("inlineCode",{parentName:"p"},"forcePermission: true")," to force a new connexion if the button is clicked with an already authenticated user:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n")),(0,s.kt)("p",null,"The app looks now:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import React from 'react';\nimport { DAppProvider, useConnect } from './dapp/dapp'\nimport './App.css';\nimport { APP_NAME, NETWORK } from './dapp/defaults';\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className=\"App\"> {props.children} </div>\n}\n\nfunction ConnexionButton() {\n  const connect = useConnect()\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n  return <button onClick={handleConnect}>Connect account</button>\n}\n\nfunction App() {\n  return (\n          <DAppProvider appName={APP_NAME}>\n            <React.Suspense fallback={null}>\n              <Page>\n                <ConnexionButton></ConnexionButton>\n              </Page>\n            </React.Suspense>\n          </DAppProvider>\n  );\n}\n\nexport default App;\n")),(0,s.kt)("p",null,"Our application contains a single button: if we push it, a pop-up appears and offers the user the possibility to connect to the address of its choice."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1631).Z})),(0,s.kt)("h2",{id:"wallet-information"},"Wallet information"),(0,s.kt)("p",null,"Our application now connects to an account, with the ",(0,s.kt)("em",{parentName:"p"},"Temple Wallet"),".\nHowever, the application doesn't display some of the crucial information: the used address and its balance.\nThe user needs to know which address is going to interact with the smart contract. This address must therefore hold some funds."),(0,s.kt)("p",null,"Let's add the used address. We will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," callback from ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp/dapp.js"),".\nThe information is therefor set when the connexion is established:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const connect = React.useCallback(\n        async (network, opts) => {\n          try {\n            if (!wallet) {\n              throw new Error('Thanos Wallet not available')\n            }\n            await wallet.connect(network, opts)\n            const tzs = wallet.toTezos()\n            const pkh = await tzs.wallet.pkh()\n            setState({\n              wallet,\n              tezos: tzs,\n              accountPkh: pkh, // set here\n            })\n          } catch (err) {\n            console.error(`Failed to connect ThanosWallet: ${err.message}`)\n          }\n        },\n        [setState, wallet],\n)\n")),(0,s.kt)("p",null,"We will call the ",(0,s.kt)("inlineCode",{parentName:"p"},"useAccountPkh")," hook, and reformat the address.\nThe user needs to know which address he's using but doesn't need to know the full address: the beginning and the end of the address will be enough."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}` // formatting address\n    }\n  }, [accountPkh]) // updates when the connected account changes\n//..\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"accountPkhPreview")," variable must of course be updated when the connected account changes."),(0,s.kt)("p",null,"Next, we will display the balance associated with the connected account.\nThis requires to interact with the Tezos network, so we need the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook."),(0,s.kt)("p",null,"The balance is likely to change when:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the network changes"),(0,s.kt)("li",{parentName:"ul"},"the account changes"),(0,s.kt)("li",{parentName:"ul"},"a new block is baked")),(0,s.kt)("p",null,"We will write our balance update into a react callback, which will be updated if the network, connected account or the page changes."),(0,s.kt)("p",null,"The callback that will be used is in effect if the callback has changed.\nIt will also be used in the ",(0,s.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook. When a new block is baked, the application will update the balance if it has changed."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n")),(0,s.kt)("p",null,"Let's change our component into an array of three elements: the balance, the connected user, and the connect button"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format('mutez', 'tz', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div style={{ display: \"grid\", gridTemplateColumns: '1fr 1fr 1fr', margin: '0 auto', width: \"500px\" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n}\n")),(0,s.kt)("h1",{id:"displaying-storage"},"Displaying Storage"),(0,s.kt)("p",null,"So far, our application uses the Temple Wallet to connect to a Tezos network, using an address. It is now time to connect our React application to our Raffle smart contract and then to retrieve the contract information (entrypoints and storage)"),(0,s.kt)("p",null,"Let's create a new component, that will display the information from the storage. First, we need to retrieve the contract.\nWe need:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the contract address"),(0,s.kt)("li",{parentName:"ul"},"to connect to a Tezos network, so we will use the ",(0,s.kt)("inlineCode",{parentName:"li"},"useTezos")," hook"),(0,s.kt)("li",{parentName:"ul"},"to save the contract into the component state"),(0,s.kt)("li",{parentName:"ul"},"to reload the contract whenever the Tezos toolkit changes")),(0,s.kt)("p",null,"We will put the logic that retrieves the contract into an effect like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"function RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  return (\n    <div>\n    </div>\n\n  );\n};\n")),(0,s.kt)("p",null,"The contract object holds several pieces of information:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the address"),(0,s.kt)("li",{parentName:"ul"},"the entrypoints"),(0,s.kt)("li",{parentName:"ul"},"the code and storage definition")),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(4507).Z})),(0,s.kt)("p",null,"Let's now take a look at the contract storage.\nThe storage will be kept within the component state.\nLet's define a ",(0,s.kt)("inlineCode",{parentName:"p"},"RaffleStorage")," type, that will follow the storage definition:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," is an abstraction exported by ",(0,s.kt)("inlineCode",{parentName:"p"},"@taquito/taquito"),": it allows the application to handle ",(0,s.kt)("a",{parentName:"p",href:"https://tezostaquito.io/typedoc/classes/_taquito_taquito.bigmapabstraction.html"},"maps and big maps")),(0,s.kt)("p",null,"Let's fetch the storage from the contract. Let's put the logic of fetching the storage in a react callback: ",(0,s.kt)("inlineCode",{parentName:"p"},"loadStorage"),".\nThe storage is likely to change if the contract's object changes and if a new block is baked. So, this callback will be called from an effect and from the ",(0,s.kt)("inlineCode",{parentName:"p"},"useOnBlock")," hook"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\n\nfunction RaffleInformation() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      setStorage(str)\n    }\n  }, [contract]);\n\n    React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n    </div>\n\n  );\n};\n")),(0,s.kt)("p",null,"One example of a retrieved storage is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'admin: "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW"\nclose_date: "2021-07-23T12:59:48.000Z"\ndescription: "Test from dapp"\njackpot: BigNumber {s: 1, e: 1, c: Array(1)}\nplayers: (3) ["tz1beoZXxjqsXGoZnwW4TZD3MWGFpLHRxeFN", "tz1cGftgD3FuBmBhcwY24RaMm5D2UXLr5LHW", "tz1cLMENL1FJYMBJ3WPg5UQAEFobdVPFrdpH"]\nraffle_is_open: true\nsold_tickets: BigMapAbstraction {id: BigNumber, schema: Schema, provider: RpcContractProvider}\nwinning_ticket_number_hash: "74657374"\n\n')),(0,s.kt)("p",null,"Almost all the values are fetched with ",(0,s.kt)("inlineCode",{parentName:"p"},"contract.storage()"),", except the ",(0,s.kt)("inlineCode",{parentName:"p"},"sold_tickets"),"  big map."),(0,s.kt)("h2",{id:"big-map-handling"},"Big map handling"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Taquito")," does not directly retrieve big maps. This is no surprise as indeed big maps are meant to store a huge amount of data: retrieving the whole big map would take a long time. That is why the wallet returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction"),". This object will be used to retrieve specific values of the big map."),(0,s.kt)("p",null,"In our case, we want to display the tickets and their owner: we need to retrieve all the values. So, we need to know the keys, which means that we need to get the ids of the sold ticket. When this article was written, ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ecadlabs/taquito/projects/2#card-34204687"},"big map keys discovery")," was not yet implemented."),(0,s.kt)("p",null,"There are, usually two ways of getting keys of big maps:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"making an api call on an ",(0,s.kt)("a",{parentName:"li",href:"/explorer/tzstats-smart-contract/#api-calls"},"indexer api"),". An indexer monitors a tezos network and extract and transform data so that it can be easily fetched. Those indexers retrieve the contract big maps, which can be called on from an API endpoint. First, you need to retrieve the big map number. You can find this number in the ",(0,s.kt)("inlineCode",{parentName:"li"},"BigMapAbstraction")," or from an explorer. Once you have this number, you can fetch its keys (and values) with an API key (we use ",(0,s.kt)("a",{parentName:"li",href:"https://tzstats.com/"},"tzstats"),")")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'$ GET https://api.edo.tzstats.com/explorer/bigmap/108024/keys\n[{"key":"0","key_hash":"exprtZBwZUeYYYfUs9B9Rg2ywHezVHnCCnmF9WsDQVrs582dSK63dC","key_binary":"0"},{"key":"1","key_hash":"expru2dKqDfZG8hu4wNGkiyunvq2hdSKuVYtcKta7BWP6Q18oNxKjS","key_binary":"1"},{"key":"2","key_hash":"expruDuAZnFKqmLoisJqUGqrNzXTvw7PJM2rYk97JErM5FHCerQqgn","key_binary":"2"}]\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"When refactoring the smart contract: a ",(0,s.kt)("inlineCode",{parentName:"li"},"set")," can be added in the storage and that will hold all the big map keys.")),(0,s.kt)("p",null,"In our raffle smart contract, we don't need this. As there is a clear one-to-one correspondence between the tickets and the players: if there are five players, it means that exactly five tickets have been sold. Since all tickets are numbered in an ascending order, we can infer that the big map keys range from zero to four."),(0,s.kt)("p",null,"So, we will create an array of number, which ranges from ",(0,s.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"players.length"),".\nOnce we have our keys, we will retrieve the mapped values."),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"BigMapAbstraction")," exposes two asynchronous methods: "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"get"),": takes a big map's key as input. It fetches one value."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"getMultipleValues"),": takes a list of big map keys as input. It fetches several values at the same time.")),(0,s.kt)("p",null,"The correct way to retrieve several values is to use the ",(0,s.kt)("inlineCode",{parentName:"p"},"getMultipleValues")," method. Putting ",(0,s.kt)("inlineCode",{parentName:"p"},"get")," into a ",(0,s.kt)("inlineCode",{parentName:"p"},"for")," loop to retrieve ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," values will make ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," calls: it is not effective when the big map grows."),(0,s.kt)("p",null,"Our ",(0,s.kt)("inlineCode",{parentName:"p"},"loadStorage")," callback now looks like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"    const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys()) // creating the keys array\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids) // fetching the values\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n\n    }\n  }, [contract]);\n")),(0,s.kt)("p",null,"Finally, our storage information will be displayed as plain text. Our Raffle app is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("h1",{id:"launching-a-new-raffle"},"Launching a new raffle"),(0,s.kt)("p",null,"Its now time to add interactions with the smart contract: let's add the possibility to launch a raffle. For this, the user will have to enter the raffle pieces of information, and then call the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"LaunchRaffleSection")," component, that will contain a ",(0,s.kt)("inlineCode",{parentName:"p"},"form")," to enter the raffle information, and a button to call the entrypoint."),(0,s.kt)("h2",{id:"new-raffle-information"},"New raffle information"),(0,s.kt)("p",null,"First, we will add a form. Four pieces of information are needed:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"reward"),": a ",(0,s.kt)("inlineCode",{parentName:"li"},"string")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"description"),": a ",(0,s.kt)("inlineCode",{parentName:"li"},"string")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"closing date"),": a ",(0,s.kt)("inlineCode",{parentName:"li"},"Date")),(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("strong",{parentName:"li"},"winning ticket hash"),": a ",(0,s.kt)("inlineCode",{parentName:"li"},"string"))),(0,s.kt)("p",null,"For the reward, description, and winning ticket hash, a simple ",(0,s.kt)("inlineCode",{parentName:"p"},"<input>")," component will be enough. For the closing date, we will use a ",(0,s.kt)("inlineCode",{parentName:"p"},"DatePicker")," (","[https://www.npmjs.com/package/react-datepicker]",")."),(0,s.kt)("p",null,"These four pieces of information will be kept in the component state."),(0,s.kt)("h3",{id:"datepicker-installation"},"DatePicker installation"),(0,s.kt)("p",null,"Let's add the ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/react-datepicker"},"react-datepicker")," package:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add react-datepicker\n")),(0,s.kt)("p",null,"We then need two add two imports into ",(0,s.kt)("em",{parentName:"p"},"App.tsx"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\n')),(0,s.kt)("h3",{id:"form-creation"},"Form creation"),(0,s.kt)("p",null,"The raffle information will be entered in a basic React component like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n  </div>\n\n}\n')),(0,s.kt)("h2",{id:"new-raffle-button"},"New raffle button"),(0,s.kt)("h3",{id:"web3-installation"},"web3 installation"),(0,s.kt)("p",null,"In this part, we will need the standard ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),". It is used to interact with ",(0,s.kt)("em",{parentName:"p"},"Ethereum")," networks. In our case, we will be using the ",(0,s.kt)("inlineCode",{parentName:"p"},"utils.asciiToHex")," function, to convert ",(0,s.kt)("inlineCode",{parentName:"p"},"string")," into ",(0,s.kt)("inlineCode",{parentName:"p"},"bytes"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn add web3\n")),(0,s.kt)("h3",{id:"implementation"},"Implementation"),(0,s.kt)("p",null,"The contract calls the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint and will use the raffle information entered by the user. First, let's add a button that will trigger this call."),(0,s.kt)("p",null,"Let's create a ",(0,s.kt)("inlineCode",{parentName:"p"},"LaunchRaffleButton")," component. This component will contain the contract call logic."),(0,s.kt)("p",null,"We will call the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," entrypoint: it will needs the four pieces of information from the form. Let's create a props type for this component:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n\n}\n")),(0,s.kt)("p",null,"Before making this contract call, we need to connect to the Tezos network (using the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook) and to get the contract component (the same way we got the ",(0,s.kt)("inlineCode",{parentName:"p"},"RaffleInformation"),")."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n}\n")),(0,s.kt)("p",null,"The next step is to create the callback that will perform the contract call. This callback will receive the same four arguments as the component. This callback is likely to change if the contract changes."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ContractAbstraction")," holds the callable entrypoints in ",(0,s.kt)("inlineCode",{parentName:"p"},"methods"),". "),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(4923).Z})),(0,s.kt)("p",null,"It returns three callbacks, matching our three entrypoints: we will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"openRaffle")," function to start.\nIt will expect four arguments: the order that the arguments are expected in can be found in ",(0,s.kt)("inlineCode",{parentName:"p"},"entrypoints")," of the ",(0,s.kt)("inlineCode",{parentName:"p"},"ContractAbstraction"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(9503).Z})),(0,s.kt)("p",null,"The order is given by the type order:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"reward (",(0,s.kt)("inlineCode",{parentName:"li"},"mutez"),")"),(0,s.kt)("li",{parentName:"ol"},"closing date (",(0,s.kt)("inlineCode",{parentName:"li"},"timestamps"),")"),(0,s.kt)("li",{parentName:"ol"},"description (",(0,s.kt)("inlineCode",{parentName:"li"},"option"),")"),(0,s.kt)("li",{parentName:"ol"},"winning ticket hash (",(0,s.kt)("inlineCode",{parentName:"li"},"bytes"),")")),(0,s.kt)("p",null,"We can now write our callback"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n    },\n    [contract]\n  );\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"web3.utils.asciiToHex(string).slice(2)")," is the way to convert a string into a bytes, using the standard ",(0,s.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/web3"},"web3 package"),"."),(0,s.kt)("p",null,"However, even though the contract arguments are correct, the execution will fail. Indeed, when a raffle is opened, the reward must be sent to the smart contract: and an ",(0,s.kt)("inlineCode",{parentName:"p"},"amount")," must be specified. It can be carried out using the ",(0,s.kt)("inlineCode",{parentName:"p"},"send")," method, which specifies some of the parameters of the call:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n")),(0,s.kt)("p",null,"The last thing is to connect this callback to a button. Our final component is therefore:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"type launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n")),(0,s.kt)("h2",{id:"end-to-end-testing"},"End-to-end testing"),(0,s.kt)("p",null,"Our app now looks like: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("p",null,"Let's run it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"$ yarn start\n")),(0,s.kt)("p",null,"The page should look like this:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(2131).Z})),(0,s.kt)("p",null,'Let\'s connect our wallet by clicking on "Connect account". A Temple pop-up should appear and displays the available accounts:\n',(0,s.kt)("img",{src:t(1276).Z})),(0,s.kt)("p",null,"The account information are loaded and displayed:\n",(0,s.kt)("img",{src:t(9988).Z})),(0,s.kt)("p",null,"Let's create a new raffle: the closing date will be the same day and there will be no winner. Let's click on launch. A pop-up should appear, summing up the contract call:\n",(0,s.kt)("img",{src:t(6025).Z})),(0,s.kt)("p",null,'The detailed transaction information can be found under the "Raw" section\n',(0,s.kt)("img",{src:t(3230).Z}),"\nThere is a warning message: ",(0,s.kt)("inlineCode",{parentName:"p"},'"Warning! Transaction is likely to fail"'),". The Temple Wallet is capable, before sending the transaction, to check if the Michelson code will execute successfully. In this case, the closing date is too early. Let's try to send the transaction. If we check in the console, an exception is raised.\n",(0,s.kt)("img",{src:t(1713).Z})),(0,s.kt)("p",null,"The cause of the failure is indeed the closing date. Let's try again: the reward is set at 200 tz and the end of the raffle is a month later:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(6125).Z})),(0,s.kt)("p",null,"The warning is gone. Instead, the fees are displayed. The transaction seems valid: let's send it. After a while, the UI is re-rendered:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1972).Z})),(0,s.kt)("p",null,"A raffle just opened. 200 tz (the reward) has been subtracted from our account balance and the raffle information has been updated."),(0,s.kt)("p",null,"We can try to launch a new raffle, but the transaction will fail since a raffle is already ongoing. This is detected by the Temple Wallet."),(0,s.kt)("h1",{id:"buying-tickets"},"Buying tickets"),(0,s.kt)("h2",{id:"implementation-1"},"Implementation"),(0,s.kt)("p",null,"Let's add the feature of buying tickets to our application. There is no information to provide: the only thing required is to call the entrypoint."),(0,s.kt)("p",null,"Just like the opening of a raffle, we need to add a button component, that makes that contract call when clicked.\nAs we will need to interact with a contract, on a tezos network, we will use the ",(0,s.kt)("inlineCode",{parentName:"p"},"useTezos")," hook and the ",(0,s.kt)("inlineCode",{parentName:"p"},"RAFFLE_ADDRESS")," variable as an effect."),(0,s.kt)("p",null,"The logic of calling the ",(0,s.kt)("inlineCode",{parentName:"p"},"buyTicket")," entrypoint will be written into a React callback. The ticket cost is one XTZ."),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},"buyTicket")," expects ",(0,s.kt)("inlineCode",{parentName:"p"},"unit"),". It does not mean that he should not be passed any argument: it expects a ",(0,s.kt)("inlineCode",{parentName:"p"},'"unit"')," string"),(0,s.kt)("p",null,"Finally, this callback will be connected to our button."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'function BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n')),(0,s.kt)("h2",{id:"end-to-end-testing-1"},"End-to-end testing"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'import React, { useState } from \'react\';\nimport { DAppProvider, useAccountPkh, useConnect, useOnBlock, useReady, useTezos, useWallet } from \'./dapp/dapp\'\nimport \'./App.css\';\nimport { APP_NAME, NETWORK, RAFFLE_ADDRESS } from \'./dapp/defaults\';\nimport { BigMapAbstraction } from "@taquito/taquito";\nimport DatePicker from "react-datepicker";\nimport "react-datepicker/dist/react-datepicker.css";\nimport web3 from "web3";\n\ntype RaffleStorage = {\n  admin: string;\n  close_date: string;\n  description: string;\n  jackpot: number;\n  players: [string];\n  raffle_is_open: boolean;\n  sold_tickets: BigMapAbstraction;\n  winning_ticket_number_hash: string;\n};\n\n\nconst Page = (props: { children: string | number | boolean | {} | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactNodeArray | React.ReactPortal | null | undefined; }) => {\n  return <div className="App"> {props.children} </div>\n}\n\n\n\nfunction ConnectionSection() {\n  const connect = useConnect()\n  const accountPkh = useAccountPkh()\n  const tezos = useTezos()\n  const [balance, setBalance] = React.useState(null)\n  const handleConnect = React.useCallback(async () => {\n    try {\n      await connect(NETWORK, { forcePermission: true })\n    } catch (err) {\n      console.error(err.message)\n    }\n  }, [connect])\n\n\n  const accountPkhPreview = React.useMemo(() => {\n    console.log("usememo")\n    if (!accountPkh) return undefined\n    else {\n      const accPkh = (accountPkh as unknown) as string\n      const ln = accPkh.length\n      return `${accPkh.slice(0, 7)}...${accPkh.slice(ln - 4, ln)}`\n    }\n  }, [accountPkh])\n\n  const loadBalance = React.useCallback(async () => {\n    console.log(loadBalance)\n    if (tezos) {\n      const tezosOk = tezos as any\n      const bal = await tezosOk.tz.getBalance(accountPkh)\n      setBalance(tezosOk.format(\'mutez\', \'tz\', bal).toString())\n    }\n  }, [tezos, accountPkh, setBalance])\n\n  React.useEffect(() => {\n    loadBalance()\n  }, [loadBalance])\n\n  useOnBlock(tezos, loadBalance)\n\n  return <div>\n    <div style={{ display: "grid", gridTemplateColumns: \'1fr 1fr 1fr\', margin: \'0 auto\', width: "500px" }}>\n      <div>{balance}</div>\n      <div>{accountPkhPreview}</div>\n      <button onClick={handleConnect}>Connect account</button>\n    </div>\n  </div>\n\n}\n\nfunction RaffleInformation() {\n  const wallet = useWallet();\n  const ready = useReady();\n  const tezos = useTezos();\n\n  const [contract, setContract] = useState();\n  const [storage, setStorage] = useState<RaffleStorage>();\n  const [tickets, setTickets] = useState<string[]>([]);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        debugger\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const loadStorage = React.useCallback(async () => {\n    if (contract) {\n      const str = await (contract as any).storage();\n      const ticket_ids = Array.from(Array(str.players.length).keys())\n      const tckts = await str.sold_tickets.getMultipleValues(ticket_ids)\n      setStorage(str)\n      setTickets([...tckts.valueMap])\n    }\n  }, [contract]);\n\n  React.useEffect(() => {\n    loadStorage();\n  }, [loadStorage]);\n\n  useOnBlock(tezos, loadStorage)\n\n  return (\n    <div>\n      <div>\n        Administrator: {!!storage ? storage.admin.toString() : ""}\n      </div>\n      <div>\n        Reward: {!!storage ? storage.jackpot.toString() : ""}\n      </div>\n      <div>\n        Description: {!!storage ? storage.description.toString() : ""}\n      </div>\n      <div>\n        Players:\n        <div>\n          {!!storage ? storage.players.map((value, index) => {\n            return <li key={index}>{value}</li>\n          }) : ""}\n        </div>\n      </div>\n      <div>\n        Tickets sold:\n        <div>\n          {tickets.map((value, index) => {\n            return <li key={index}>{value[0]} : {value[1]}</li>\n          })}\n        </div>\n      </div>\n\n      <div>\n        Closing date: {!!storage ? storage.close_date.toString() : ""}\n      </div>\n    </div>\n\n  );\n};\n\ntype launchRaffleButtonProps = { raffleReward: number; raffleDescription: string; raffleClosingDate: Date; raffleWinningHashNumber: string };\n\nfunction LaunchRaffleButton({ raffleReward, raffleDescription, raffleClosingDate, raffleWinningHashNumber }: launchRaffleButtonProps) {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  type launchRaffleParameters = { reward: number; description: string; closingDate: Date; winningTicketHash: string };\n\n  const launchRaffleCallback = React.useCallback(\n    ({ reward, description, closingDate, winningTicketHash }: launchRaffleParameters) => {\n      return (contract as any).methods\n        .openRaffle(reward, closingDate, description, web3.utils.asciiToHex(winningTicketHash).slice(2))\n        .send({ amount: reward });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback({\n      reward: raffleReward,\n      description: raffleDescription,\n      closingDate: raffleClosingDate,\n      winningTicketHash: raffleWinningHashNumber\n    })\n  }}>Launch</button>\n}\n\nfunction LaunchRaffleSection() {\n  const [description, setDescription] = useState("");\n  const [reward, setReward] = useState("100");\n  const [closingDate, setClosingDate] = useState(new Date());\n  const [winningTicketHash, setwinningTicketHash] = useState("");\n\n  const setNewDate = (date: any) => {\n    if (!!date) {\n      setClosingDate(date)\n    }\n  }\n\n  return <div style={{ border: "1px solid black" }}>\n    <form>\n      <label>\n        Reward:\n  <input type="text" name="reward" value={reward}\n          onChange={(e) => setReward(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Description:\n  <input type="text" name="description" value={description}\n          onChange={(e) => setDescription(e.target.value)} />\n      </label>\n      <br />\n      <label>\n        Closing Date:\n    <DatePicker selected={closingDate} onChange={date => setNewDate(date)}></DatePicker>\n      </label>\n      <br />\n      <label>\n        Winning Hash number:\n    <input type="text" name="winningTicketHash" value={winningTicketHash}\n          onChange={(e) => setwinningTicketHash(e.target.value)} />\n      </label>\n    </form>\n    <LaunchRaffleButton raffleReward={parseInt(reward)} raffleDescription={description} raffleClosingDate={closingDate} raffleWinningHashNumber={winningTicketHash} ></LaunchRaffleButton>\n  </div>\n\n}\n\nfunction BuyTicketButton() {\n  const tezos = useTezos();\n  const [contract, setContract] = useState(undefined);\n  React.useEffect(() => {\n    (async () => {\n      if (tezos) {\n        const ctr = await (tezos as any).wallet.at(RAFFLE_ADDRESS);\n        setContract(ctr);\n      }\n    })();\n  }, [tezos]);\n\n  const launchRaffleCallback = React.useCallback(\n    () => {\n      return (contract as any).methods\n        .buyTicket("unit")\n        .send({ amount: 1 });\n    },\n    [contract]\n  );\n  return <button onClick={() => {\n    launchRaffleCallback()\n  }}>Buy</button>\n}\n\nfunction App() {\n  return (\n    <DAppProvider appName={APP_NAME}>\n      <React.Suspense fallback={null}>\n        <Page>\n          <ConnectionSection></ConnectionSection>\n          <RaffleInformation></RaffleInformation>\n          <LaunchRaffleSection></LaunchRaffleSection>\n          <BuyTicketButton></BuyTicketButton>\n        </Page>\n      </React.Suspense>\n    </DAppProvider>\n  );\n}\n\nexport default App;\n')),(0,s.kt)("p",null,"Let's test it. The button to buy a ticket has been added: it can be clicked. A Temple wallet pop-up appears, summing up the contract call."),(0,s.kt)("p",null,(0,s.kt)("img",{src:t(1563).Z})),(0,s.kt)("p",null,"After a while, the UI is re-rendered: bought ticket is displayed.\n",(0,s.kt)("img",{src:t(2318).Z})),(0,s.kt)("h1",{id:"conclusion"},"Conclusion"),(0,s.kt)("p",null,"Integrating the Temple wallet into a React app can be broken down into three steps:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"using the context provider"),(0,s.kt)("li",{parentName:"ol"},"connecting the React app to the Wallet (with ",(0,s.kt)("inlineCode",{parentName:"li"},"useConnect"),")"),(0,s.kt)("li",{parentName:"ol"},"interacting with the contract (storage or contract calls)")),(0,s.kt)("p",null,"We have covered the basic functionalities of the ",(0,s.kt)("em",{parentName:"p"},"Temple dapp")," module. In the next chapter, we will improve the user experience for all the blockchain interactions."))}p.isMDXComponent=!0},1631:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front1-013427e8f1e012269215902cf92b5d08.png"},1713:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front10-48342678a3f6c70948f215e46383e638.png"},6125:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front11-e5be76b5f13c495363ace98bffab1e62.png"},1972:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front12-dc2fbda8b0dd7672447e7713d174fb6f.png"},1563:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front13-561b037cebca6e0111c45471cf4fb124.png"},2318:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front14-7a6342dd5f158456e9ac359b800599c8.png"},4507:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front2-ced586f3745bd9b4c03c1ffc4a0f7390.png"},4923:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front3-309923828c096cec2d28f0f2f71cf06e.png"},9503:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front4-42e98e5aa5a380f4dbbd52940524ad00.png"},2131:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front5-538d8a71a4b3124a8dc1e4e00e235150.png"},1276:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front6-521a214a72acb6954f3b0cbdc3c408cc.png"},9988:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front7-84a3ea0ef9a9de19c28488a4ae242b95.png"},6025:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front8-95b4f7d63da79d3bea7f688879447baf.png"},3230:function(e,n,t){"use strict";n.Z=t.p+"assets/images/front9-d0a193dac6c95ec773cd3265088ac254.png"}}]);