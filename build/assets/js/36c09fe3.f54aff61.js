(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[1167],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,f=m["".concat(l,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7718:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var a=n(2122),o=n(9756),r=(n(7294),n(3905)),i={id:"michocoq",title:"Mi-Cho-Coq",authors:"Frank Hillard"},s={unversionedId:"formal-verification/michocoq",id:"formal-verification/michocoq",isDocsHomePage:!1,title:"Mi-Cho-Coq",description:"Introduction",source:"@site/docs/formal-verification/michocoq.md",sourceDirName:"formal-verification",slug:"/formal-verification/michocoq",permalink:"/formal-verification/michocoq",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/formal-verification/michocoq.md",version:"current",lastUpdatedBy:"AymericBethencourt",lastUpdatedAt:1620844140,formattedLastUpdatedAt:"5/12/2021",frontMatter:{id:"michocoq",title:"Mi-Cho-Coq",authors:"Frank Hillard"}},l=[{value:"Introduction",id:"introduction",children:[]},{value:"Content",id:"content",children:[]},{value:"Category theory",id:"category-theory",children:[]}],c={toc:l};function p(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library represents the bridge between Tezos smart contract and formal proof in Coq."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library ","[2]"," is a formalization of the Michelson language ","[9]"," using the Coq interactive theorem prover ","[1]","."),(0,r.kt)("p",null,"In practice, the ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq"),' library is used to produce a formal definition of a Michelson script (e.g. the "Modeling theorem" ',(0,r.kt)("a",{parentName:"p",href:"/formal-verification/modeling-theorem#Example_vote"},"section"),"). Each Michelson instruction has its equivalent in the ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library (e.g. see the syntax ",(0,r.kt)("a",{parentName:"p",href:"/formal-verification/michocoq#Syntax"},"subsection"),")."),(0,r.kt)("h3",{id:"content"},"Content"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Mi-Cho-Coq")," library provides a formal definition (in Gallina) of the ",(0,r.kt)("strong",{parentName:"p"},"type system")," (Michelson types), the ",(0,r.kt)("strong",{parentName:"p"},"syntax")," (instructions of the Michelson), the ",(0,r.kt)("strong",{parentName:"p"},"semantics")," (evaluator) and the lexing and parsing (for type-checking)."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is recommended to have notions of Language theory in order to understand the following Mi-Cho-Coq definition (grammar rules).")),(0,r.kt)("h4",{id:"type-system"},"Type system"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"type system")," consists of the definition of types (comparable types and non-comparable ones)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Inductive simple_comparable_type : Set :=\n| string\n| nat\n| int\n| bytes\n...\n\nInductive comparable_type : Set :=\n| Comparable_type_simple : simple_comparable_type -> comparable_type\n| Cpair : simple_comparable_type -> comparable_type -> comparable_type.\n\nInductive type : Set :=\n| Comparable_type (_ : simple_comparable_type)\n| key\n| unit\n| signature\n| option (a : type)\n| list (a : type)\n| set (a : comparable_type)\n| contract (a : type)\n| operation\n| pair (a : type) (b : type)\n| or (a : type) (_ : annot_o) (b : type) (_ : annot_o)\n| lambda (a b : type)\n| map (k : comparable_type) (v : type)\n| big_map (k : comparable_type) (v : type)\n| chain_id.\n")),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"The *",(0,r.kt)("strong",{parentName:"p"},"*syntax")," and typing of Michelson instructions are formalized as a dependent inductive type to rule out ill-typed instructions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Inductive instruction :\n  forall (self_type : Datatypes.option type) (tail_fail_flag : Datatypes.bool) (A B : Datatypes.list type), Set :=\n| NOOP {A} : instruction A A\n| FAILWITH {A B a} : instruction (a ::: A) B\n| SEQ {A B C} : instruction A B -> instruction B C -> instruction A C\n| IF_ {A B} : instruction A B -> instruction A B -> instruction (bool ::: A) B\n| LOOP {A} : instruction A (bool ::: A) -> instruction (bool ::: A) A\n...\n")),(0,r.kt)("h4",{id:"semantics"},"Semantics"),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"semantics")," of types is defined by interpreting them by predefined Coq types (e.g. int -> Z, nat -> N, mutez -> int63). The semantics of Michelson is defined by an evaluator ",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," formalized as a ",(0,r.kt)("em",{parentName:"p"},"Fixpoint"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Fixpoint eval {self_type} {tff} {env} {A : stack_type} {B : stack_type}\n         (i : instruction self_type tff A B) (fuel : Datatypes.nat) {struct fuel} :\n  stack A -> M (stack B) :=\n  match fuel with\n  | O => fun SA => Failed _ Out_of_fuel\n  | S n =>\n    match i, SA, env with\n    | FAILWITH, (x, _), _ => Failed _ (Assertion_Failure _ x)\n    | NOOP, SA, _ => Return SA\n    | DUP, (x, SA), _ => Return (x, (x, SA))\n    | SWAP, (x, (y, SA)), _ => Return (y, (x, SA))\n    | PUSH a x, SA, _ => Return (concrete_data_to_data _ x, SA)\n    | UNIT, SA, _ => Return (tt, SA)\n    | LAMBDA a b code, SA, _ => Return (existT _ _ code, SA)\n    | EQ, (x, SA), _ => Return ((x =? 0)%Z, SA)\n    | NEQ, (x, SA), _ => Return (negb (x =? 0)%Z, SA)\n    | LT, (x, SA), _ => Return ((x <? 0)%Z, SA)\n        | SEQ B C, SA, env => \n        let! r := eval env B n SA in\n        eval env C n r\n    | IF_ bt bf, (b, SA), env =>\n        if b then eval env bt n SA else eval env bf n SA\n    | LOOP body, (b, SA), env =>\n        if b then eval env (body;; (LOOP body)) n SA else Return SA\n...\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Since evaluating a Michelson instruction might fail (which Coq functions cannot), the return type of this evaluator is wrapped in an exception monad (handling errors such as overflow, lexing, parsing, fuel).")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Coq forbids non-terminating function so we use a common Coq trick to define the evaluator on diverging instructions such as LOOP: we make the evaluator structurally recursive on an extra argument of type Datatypes.nat called the fuel of the evaluator.")),(0,r.kt)("h1",{id:"annexe"},"ANNEXE"),(0,r.kt)("h3",{id:"category-theory"},"Category theory"),(0,r.kt)("p",null,"Category theory formalizes mathematical structure and its concepts in terms of a labeled directed graph called a category, whose nodes are called objects, and whose labeled directed edges are called ",(0,r.kt)("em",{parentName:"p"},"arrows")," (or morphisms). A category has two basic properties: the ability to compose the arrows associatively, and the existence of an identity arrow for each object. The language of category theory has been used to formalize concepts of other high-level abstractions such as ",(0,r.kt)("em",{parentName:"p"},"sets"),", ",(0,r.kt)("em",{parentName:"p"},"rings"),", and ",(0,r.kt)("em",{parentName:"p"},"groups"),". Informally, category theory is a general theory of functions. "),(0,r.kt)("p",null,"The common usage of \"type theory\" is when those types are used with a term rewrite system. The most famous early example is Alonzo Church's simply typed lambda calculus. Church's theory of types helped the formal system avoid the Kleene\u2013Rosser paradox that afflicted the original untyped lambda calculus. Church demonstrated that it could serve as a foundation of mathematics and it was referred to as a ",(0,r.kt)("strong",{parentName:"p"},"higher-order logic"),"."),(0,r.kt)("p",null,"In ",(0,r.kt)("strong",{parentName:"p"},"category theory"),", a category is ",(0,r.kt)("strong",{parentName:"p"},"Cartesian closed")," if, roughly speaking, any morphism defined on a product of two objects can be naturally identified with a morphism defined on one of the factors. These categories are particularly important in mathematical logic and the theory of programming, in that their internal language is the ",(0,r.kt)("strong",{parentName:"p"},"simply typed lambda calculus"),". They are generalized by closed monoidal categories, whose internal language, linear type systems, are suitable for both quantum and classical computation."),(0,r.kt)("p",null," Here is an embedding of the ",(0,r.kt)("strong",{parentName:"p"},"simply typed lambda calculus")," with an arbitrary collection of base types, tuples and a fixed point combinator: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"data Lam :: * -> * where\n  Lift :: a                     -> Lam a        // lifted value\n  Pair :: Lam a -> Lam b        -> Lam (a, b)   // product\n  Lam  :: (Lam a -> Lam b)      -> Lam (a -> b) // lambda abstraction\n  App  :: Lam (a -> b) -> Lam a -> Lam b        // function application\n  Fix  :: Lam (a -> a)          -> Lam a        // fixed point\n")),(0,r.kt)("p",null,"A fixed point of a function is a value that is mapped to itself by the function. In combinatory logic for computer science, a fixed-point combinator (or fixpoint combinator) is a higher-order function ",(0,r.kt)("em",{parentName:"p"},"fix")," that returns some fixed point of its argument function, if one exists."),(0,r.kt)("h4",{id:"monad"},"Monad"),(0,r.kt)("p",null,"In category theory, a monad (also triple, triad, standard construction and fundamental construction) is an endofunctor (a functor mapping a category to itself), together with two natural transformations required to fulfill certain coherence conditions. Monads are used in the theory of pairs of adjoint functors, and they generalize closure operators on partially ordered sets to arbitrary categories. "),(0,r.kt)("p",null,"In functional programming, a ",(0,r.kt)("strong",{parentName:"p"},"monad")," is an abstraction that allows structuring programs generically. Supporting languages may use monads to abstract away boilerplate code needed by the program logic. Monads achieve this by providing their own data type, which represents a specific form of computation, along with two procedures:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One to wrap values of any basic type within the monad (yielding a ",(0,r.kt)("strong",{parentName:"li"},"monadic value"),");"),(0,r.kt)("li",{parentName:"ul"},"Another to compose functions that output monadic values (called ",(0,r.kt)("strong",{parentName:"li"},"monadic functions"),")")),(0,r.kt)("p",null,"This allows monads to simplify a wide range of problems, like handling potential undefined values (with the Maybe monad), or keeping values within a flexible, well-formed list (using the List monad). With a monad, a programmer can turn a complicated sequence of functions into a succinct pipeline that abstracts away auxiliary data management, control flow, or side-effects."),(0,r.kt)("p",null,"Without getting too much into mathematics, in programming a Monad is a Design Pattern. It\u2019s a structure, a wrapper which \u201cenriches\u201d a value by giving it a context."),(0,r.kt)("p",null,"//TODO ...\nIt's about having representations simulating exactly notions such as exceptions and side-effects while keeping the purety of functionnal languages."),(0,r.kt)("p",null,"Famous examples of Monads are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Option/Maybe monad (it can represent a missing/null value)\nEither monad (it can represent a successful operation or a failure)\nIO/Effect monad (it can represent side-effects)\nTask monad (it can represent asynchronous side-effects)\n")))}p.isMDXComponent=!0}}]);