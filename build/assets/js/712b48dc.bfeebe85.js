(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[3985],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||o;return n?a.createElement(d,s(s({ref:t},c),{},{components:n})):a.createElement(d,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7705:function(e,t,n){"use strict";n.d(t,{Z:function(){return o}});var a=n(7294),i="root_2W3B",o=function(e){var t=e.children;return a.createElement("div",{className:i},t)}},5932:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),s=n(7705),r={id:"tutorial",title:"Tutorial",authors:"Frank Hillard"},l={unversionedId:"michelson/tutorial",id:"michelson/tutorial",isDocsHomePage:!1,title:"Tutorial",description:"This section introduces the main concepts of the Michelson language. It begins with the basics of stack manipulation then focuses on primitive types and more complex data structures. Finally the chapter focuses on specific features related to smart contracts concepts.",source:"@site/docs/michelson/tutorial.md",sourceDirName:"michelson",slug:"/michelson/tutorial",permalink:"/michelson/tutorial",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/michelson/tutorial.md",version:"current",lastUpdatedBy:"AymericBethencourt",lastUpdatedAt:1622492036,formattedLastUpdatedAt:"5/31/2021",frontMatter:{id:"tutorial",title:"Tutorial",authors:"Frank Hillard"},sidebar:"docs",previous:{title:"Smart Contracts",permalink:"/michelson/smart-contracts"},next:{title:"Examples",permalink:"/michelson/examples"}},p=[{value:"Stack programming",id:"stack-programming",children:[]},{value:"Primitive types support",id:"primitive-types-support",children:[]},{value:"Working with complex data structures",id:"working-with-complex-data-structures",children:[]},{value:"Contract specific types and operations",id:"contract-specific-types-and-operations",children:[]},{value:"Lambda functions",id:"lambda-functions",children:[]},{value:"Iterative processing",id:"iterative-processing",children:[]},{value:"More detail in the &quot;Instructions&quot; section",id:"more-detail-in-the-instructions-section",children:[]}],c={toc:p};function m(e){var t=e.components,r=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This section introduces the main concepts of the Michelson language. It begins with the basics of ",(0,o.kt)("strong",{parentName:"p"},"stack manipulation")," then focuses on primitive types and more complex ",(0,o.kt)("strong",{parentName:"p"},"data structures"),". Finally the chapter focuses on specific features related to smart contracts concepts."),(0,o.kt)("h3",{id:"stack-programming"},"Stack programming"),(0,o.kt)("h4",{id:"basics"},"Basics"),(0,o.kt)("p",null,"Michelson is a stack-based language, which means that all the data (manipulated by the program) is stacked on a single pile. The Michelson language provides stack operators to reorganize elements of the stack and other kinds of operators which consume the top elements of the stack. In this section, we will introduce basic stack-manipulation operators and illustrates them with simple examples. Then, in a second time, we will focus on the arithmetic operators and conditional branching."),(0,o.kt)("h5",{id:"type-checking"},"Type checking"),(0,o.kt)("p",null,"In order to operate Michelson instructions, certain type of elements are required to be in the stack and in a specific order. If these expectations are not met, the type checking of the Michelson script would fail and the execution of the smart contract would stop."),(0,o.kt)("h5",{id:"basic-stack-operators-push-drop-swap"},"Basic stack operators (PUSH DROP SWAP)"),(0,o.kt)("p",null,"The code of a smart contract is defined as a ",(0,o.kt)("strong",{parentName:"p"},"sequence")," of Michelson instructions. The ",(0,o.kt)("strong",{parentName:"p"},"sequence")," structure is defined by ",(0,o.kt)("inlineCode",{parentName:"p"},"{")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"}"),", and contains instructions separated by ",(0,o.kt)("inlineCode",{parentName:"p"},";")," (semi-colon). When executing a sequence, the interpreter executes each instruction sequentially, one after the other, in the specified order."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"{ instruction1 ; \n  instruction2 ; \n  ... ; \n  instruction n }\n")),(0,o.kt)(s.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,"The Michelson language must respect a precise indentation. Each instruction that introduces a new block must indent its content. It is recommended to have a single instruction per line. For instance, the `IF` instruction introduces two sequences of instructions (the `then` clause and `else` clause) which must be indented as shown below.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"code { instruction1;\n       instruction2;\n       IF\n              { then_clause }\n              { else_clause };\n       instruction4;\n}\n")),(0,o.kt)("p",null,"Let's describe the basic instructions (PUSH, DROP, SWAP) that manipulates stack elements."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH")," instruction adds an element at the top of the stack. The value and the type of the element pushed must be specified."),(0,o.kt)("p",null,"For example, the instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH nat 1")," adds an element ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," as a natural integer (i.e., a positive integer) on top of the stack. The instruction ",(0,o.kt)("inlineCode",{parentName:"p"},'PUSH string "Hello"'),' adds an element "Hello" as a string on top of the stack.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DROP")," instruction removes the top element of the stack."),(0,o.kt)("p",null,"The following diagram executes the sequence ",(0,o.kt)("inlineCode",{parentName:"p"},"{ PUSH nat 1; DROP }")," which illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DROP")," usage."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1112).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 1: Execution of `PUSH` and `DROP`"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SWAP")," instruction inverts the position of the top two elements of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6319).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 2: Illustration of the `SWAP` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DUP")," instruction duplicates the top element of the stack and prevents the loss of variables since most instructions consume and remove elements from the stack. Later examples will illustrate this further."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(5470).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 3: Illustration of the `DUP` instruction"),(0,o.kt)("h5",{id:"stack-manipulation-using-arithmetic-operators"},"Stack manipulation using arithmetic operators"),(0,o.kt)("p",null,"Once elements are added to the stack, they can be combined using arithmetic operators such as addition (",(0,o.kt)("inlineCode",{parentName:"p"},"ADD"),") and multiplication (",(0,o.kt)("inlineCode",{parentName:"p"},"MUL"),"). Other arithmetic operators are described in the ",(0,o.kt)("strong",{parentName:"p"},"Instructions/Operations on numbers")," section."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," instruction sums the top two elements of the stack and ",(0,o.kt)("inlineCode",{parentName:"p"},"MUL")," multiplies them. The result is then pushed on top of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(3541).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 4: Illustration of the `ADD` instruction"),(0,o.kt)("p",null,"More complex computation can be done. For instance, the mathematical expression ",(0,o.kt)("inlineCode",{parentName:"p"},"((2 + 3) * 6) + 7")," is equivalent to the following sequence:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"PUSH int 2;\nPUSH int 3;\nADD;\nPUSH int 6;\nMUL;\nPUSH int 7;\nADD\n")),(0,o.kt)("p",null,"The following diagram illustrates the execution of the sequence."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(8154).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 5: Illustration of the arithmetic operators"),(0,o.kt)("h5",{id:"other-basic-stack-operators-dig-dug"},"Other basic stack operators (DIG DUG)"),(0,o.kt)("p",null,"Other instructions allow you to change the position of elements in the stack such as ",(0,o.kt)("inlineCode",{parentName:"p"},"DIG")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DUG"),'. Other stack operators are described in the "Stack operations" section.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DIG n")," instruction moves the n-th element of the stack to the top of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(7325).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 6: Illustration of the `DIG` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DUG n")," instruction moves the top element of the stack to the n-th element of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1331).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 7: Illustration of the `DUG` instruction"),(0,o.kt)("p",null,"For example, the mathematical expression ",(0,o.kt)("inlineCode",{parentName:"p"},"((2 + 3) * 6) + 7")," is equivalent to the following sequence of instructions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"PUSH int 2;\nPUSH int 6;\nPUSH int 3;\nPUSH int 7;\nDUG 3;\nDIG 2;\nADD;\nMUL;\nADD\n")),(0,o.kt)("p",null,"The following schema illustrates the execution of this sequence of instructions."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2388).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 8: Illustration of the `DUG` and `DIG` instructions"),(0,o.kt)("p",null,"Now that we have seen the basic of stack operators, we are able to re-organize elements of the stack. These stack operators will be useful to prepare the stack for more complex operators that require precise elements in a specific order on the top of the stack."),(0,o.kt)("h5",{id:"conditional-branching"},"Conditional branching"),(0,o.kt)("p",null,"The Michelson language provides the possibility to execute a part of the code, depending on some criteria. This is called conditional branching, and some instructions exist for this intent."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF {} {}")," instruction allows branches of execution to be created. It takes two sequences as arguments. It expects a boolean at the top of the stack. It consumes the top element and executes the first given sequence if this boolean top element is ",(0,o.kt)("em",{parentName:"p"},"True"),". Otherwise it executes the second sequence."),(0,o.kt)("p",null,"In order to illustrate the conditional branching, let's explain the following sequence of instructions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"IF \n{ PUSH int 1 }\n{ PUSH int 2 }\n")),(0,o.kt)("p",null,"This snippet of code is equivalent to the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"if True then 1 else 2"),". It checks the top element of the stack and ensures it is a boolean and consumes it. If the value of this top element is ",(0,o.kt)("em",{parentName:"p"},"True")," then the value 1 is pushed onto the stack otherwise value 2 is pushed. "),(0,o.kt)("p",null,"This other example removes one of the top elements of the stack. If the top element is a boolean ",(0,o.kt)("em",{parentName:"p"},"True")," then the next element is removed or the one after is removes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"IF \n{ DROP }\n{ SWAP; DROP }\n")),(0,o.kt)("p",null,"The following diagrams illustrates the modification of the stack while executing the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF { DROP }")," instruction part."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(4834).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 9: Illustration of the `IF` instruction (true case)"),(0,o.kt)("p",null,"The following diagrams illustrates the modification of the stack while executing the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF { SWAP; DROP }")," instruction part."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(4633).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 10: Illustration of the `IF` instruction (false case)"),(0,o.kt)("p",null,"The conditional branching can be combined with other instructions, such as the comparison. "),(0,o.kt)("h5",{id:"comparison"},"Comparison"),(0,o.kt)("p",null,"Elements of the stack can be compared if they belong to the same class of types (called ",(0,o.kt)("strong",{parentName:"p"},"comparable"),"). For example, two integers can be compared but an integer and a string cannot, because they don't belong to the same class of comparable types."),(0,o.kt)("p",null,"Since primitive types are different by design, each primitive type is comparable to itself (e.g. there is no meaning in comparing a string to a number). Basically, numbers (",(0,o.kt)("em",{parentName:"p"},"nat"),", ",(0,o.kt)("em",{parentName:"p"},"int"),", ",(0,o.kt)("em",{parentName:"p"},"mutez"),", ",(0,o.kt)("em",{parentName:"p"},"timestamp"),") are compared numerically, sequence of characters (",(0,o.kt)("em",{parentName:"p"},"string"),", ",(0,o.kt)("em",{parentName:"p"},"bytes"),", ",(0,o.kt)("em",{parentName:"p"},"key_hash"),", ",(0,o.kt)("em",{parentName:"p"},"key"),", ",(0,o.kt)("em",{parentName:"p"},"signature"),", ",(0,o.kt)("em",{parentName:"p"},"chain_id")," values) are compared lexicographically.  "),(0,o.kt)("p",null,"For ",(0,o.kt)("em",{parentName:"p"},"pair")," values such as ",(0,o.kt)("inlineCode",{parentName:"p"},"(Pair d1 d2)"),", the comparison is done component-wise, starting with the left component.\nFor ",(0,o.kt)("em",{parentName:"p"},"option")," values, the ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," value is considered less than ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," value, and comparing ",(0,o.kt)("inlineCode",{parentName:"p"},"Some x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Some y")," is done by comparing ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),".\nThese two types (",(0,o.kt)("em",{parentName:"p"},"option")," and ",(0,o.kt)("em",{parentName:"p"},"pair"),") will be introduced later in this tutorial."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction compares the top two elements of the stack. It consumes the two top elements and returns an integer at the top of the stack. The outcome value is ",(0,o.kt)("inlineCode",{parentName:"p"},"-1")," if the first element is smaller than the second one; ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," if the two first elements are equal; ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," otherwise."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2990).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 11: Illustration of the `COMPARE` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EQ")," instruction consumes the top element and returns a boolean on top of the stack. It returns ",(0,o.kt)("em",{parentName:"p"},"True")," if this value is zero, ",(0,o.kt)("em",{parentName:"p"},"False")," otherwise. "),(0,o.kt)("p",null,"The combination of the ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EQ")," instructions allows you to create boolean conditions based on a number comparison. The following sequence verifies if two numbers are equal and returns a boolean answer on top of the stack."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"COMPARE;\nEQ\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(8721).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 12: Illustration of number comparison"),(0,o.kt)("p",null,"Other comparison instructions are available to check if a number is lower or equal to zero (",(0,o.kt)("inlineCode",{parentName:"p"},"LE")," instruction) or greater than zero (",(0,o.kt)("inlineCode",{parentName:"p"},"GT")," instruction). The list of comparison operators is described in the ",(0,o.kt)("strong",{parentName:"p"},"Generic comparison")," section."),(0,o.kt)("h5",{id:"conditional-branching-based-on-number-comparison"},"Conditional branching based on number comparison"),(0,o.kt)("p",null,"The combination of the ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"LE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"IF")," instructions allows you to apply conditional branching by comparing two numbers. The following sequence of instructions assumes that two integers are on top of the stack and removes the smaller one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"DUP;\nDUG 2;\nSWAP;\nDUP;\nDUG 2;\nDUG 3;\nCOMPARE;\nLE;\nIF { DROP } { SWAP; DROP }\n")),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"DUP; DUG 2; SWAP; DUP; DUG 2; DUG 3")," sequence duplicates the top two elements of the stack. The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE; LE")," sequence determines which is the biggest number and the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF { DROP } { SWAP; DROP }")," sequence removes the smallest number."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9629).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 13: Illustration of conditional branching based on number comparison"),(0,o.kt)("h5",{id:"more-stack-operator-dip-cmple"},"More stack operator (",(0,o.kt)("inlineCode",{parentName:"h5"},"DIP"),", ",(0,o.kt)("inlineCode",{parentName:"h5"},"CMPLE"),")"),(0,o.kt)("p",null,'This principle of duplicating the top two elements of the stack and comparing them to choose one of them is a common pattern. Some syntactic sugar (i.e. a "shortcut" instruction that combines many of the language\'s basic instructions) and macros have been introduced in the Michelson language to ease these common patterns. '),(0,o.kt)("p",null,"For example, the macro ",(0,o.kt)("inlineCode",{parentName:"p"},"CMPLE")," stands for ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE; LE"),". A more exhaustive list is available in the ",(0,o.kt)("strong",{parentName:"p"},"macros")," section."),(0,o.kt)("p",null,"Notice that the duplication of the top two elements of the stack is not an optimal sequence. It is intended to be like this in order to illustrate the ",(0,o.kt)("inlineCode",{parentName:"p"},"DUG")," instruction, but some better implementation can be done with the ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP")," instruction."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP")," instruction runs a provided sequence of instructions while protecting the ",(0,o.kt)("em",{parentName:"p"},"n")," top elements of the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP")," instruction takes two arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"n"),": a number of elements to protect (by default 1)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"code"),": a sequence of instructions to execute")),(0,o.kt)("p",null,"This instruction can be very useful. For example, let's re-write the duplication of the top two elements of the stack with the ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP")," instruction."),(0,o.kt)("p",null,"The following sequence of instructions expects two integers on top of the stack and removes the smaller one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"DIP { DUP };\nDUP;\nDIP { SWAP };\nCMPLE;\nIF { DROP } { SWAP; DROP }\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(5362).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 14: Illustration of conditional branching based on number comparison"),(0,o.kt)("h3",{id:"primitive-types-support"},"Primitive types support"),(0,o.kt)("p",null,"The Michelson language supports only few primitive data types:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nat")," represents a natural integer (e.g. 0, 3, 15)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int")," represents a integer (e.g. -10, 2, 3)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"string"),' represents a sequence of characters (e.g. "Hello")'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"bool")," represents a boolean value (e.g. True, False)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"bytes")," represents a sequence of bytes (octet)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"unit")," represents a non-specified type."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"timestamp"),' represents a duration (e.g. NOW, 1571659294, "2019-09-26T10:59:51Z"; i.e. a string following the RFC3339 standard)')),(0,o.kt)("p",null,"Notice that there is no floating-point type supported (such as ",(0,o.kt)("em",{parentName:"p"},"float"),")."),(0,o.kt)(s.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,"It is worth mentioning that there is no limit to the value of numbers (_nat_, _int_) or length of strings (_string_, _bytes_) other than the storage limit and gas limit (specified in the Tezos protocol). Therefore there is no risk of overflow errors.")),(0,o.kt)("p",null,"Other Tezos specific types such as ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," will be listed and explained later."),(0,o.kt)("p",null,"The Michelson language also allows for the manipulation of these types, but before going on primitive type, let's introduce the ",(0,o.kt)("em",{parentName:"p"},"unit")," type, the ",(0,o.kt)("em",{parentName:"p"},"optional")," (i.e. the ",(0,o.kt)("em",{parentName:"p"},"option")," type) and the ",(0,o.kt)("em",{parentName:"p"},"pair")," type."),(0,o.kt)("h4",{id:"default-unit-type"},"Default ",(0,o.kt)("inlineCode",{parentName:"h4"},"UNIT")," type"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UNIT")," instruction pushes a ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," value of type ",(0,o.kt)("em",{parentName:"p"},"unit")," on top of the stack. The ",(0,o.kt)("em",{parentName:"p"},"unit")," type stands in many contexts for nothing:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an empty structure in case of storage. "),(0,o.kt)("li",{parentName:"ul"},"an empty entry point in case of a parameter."),(0,o.kt)("li",{parentName:"ul"},"an empty argument in a function. ")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," value represents the value of a ",(0,o.kt)("em",{parentName:"p"},"unit")," type."),(0,o.kt)("h4",{id:"stopping-the-execution-of-the-smart-contract-with-failwith"},"Stopping the execution of the smart contract with ",(0,o.kt)("inlineCode",{parentName:"h4"},"FAILWITH")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction aborts the execution of the Michelson script which implies the cancellation of all storage modifications and other smart contract invocations."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction consumes the top element of the stack as arguments (usually a string message). The consumed element must be a push-able type. It is allowed to stop the execution of a Michelson script without a message by pushing a ",(0,o.kt)("inlineCode",{parentName:"p"},"UNIT")," value on top of the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FAIL")," keyword has been provided as a replacement for ",(0,o.kt)("inlineCode",{parentName:"p"},"UNIT; FAILWITH"),"."),(0,o.kt)("p",null,"Actually, the ",(0,o.kt)("inlineCode",{parentName:"p"},"FAIL")," keyword is not an instruction but a syntactic sugar."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction provides a way to reject a transaction by stopping the execution of related instructions."),(0,o.kt)("h4",{id:"optional"},"Optional"),(0,o.kt)("p",null,"An optional value is a data structure that can hold a value (of a given type) which can be not assigned yet. The optional value has two states: it is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"NONE")," if no value is assigned and can be defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"SOME")," if a value has been assigned."),(0,o.kt)("p",null,"When defining an optional value, the type of value must be specified (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"option int"),")."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_SOME")," instruction allows to check and retrieve the value if it has been assigned."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SOME")," instruction packs a value as an optional value (i.e. allows to create an ",(0,o.kt)("em",{parentName:"p"},"option")," type with an assigned value)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NONE")," instruction specifies the absence of value. It requires that the type of value that can be held be specified."),(0,o.kt)("p",null,"This ",(0,o.kt)("em",{parentName:"p"},"option")," type is very useful for all process that may fail such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Euclidean division (division by zero) "),(0,o.kt)("li",{parentName:"ul"},"slicing a string (out of bound error)"),(0,o.kt)("li",{parentName:"ul"},"accessing an element in a collection (non-existence of the element)"),(0,o.kt)("li",{parentName:"ul"},"invoking an other contract (entrypoint name and type verification)")),(0,o.kt)("p",null,"Rather than causing an error, the examples above make use of optional values to specify a special case to handle."),(0,o.kt)("p",null,"A Michelson smart contract is expected to explicitly handle all possible cases; especially the case where the process produces an option with no value."),(0,o.kt)("p",null,"All these cases will be detailed in their respective sections."),(0,o.kt)("h5",{id:"using-optional"},"Using optional"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_NONE bt bf")," instruction inspects an optional value.\nIt requires two sequences of instructions, like with an ",(0,o.kt)("inlineCode",{parentName:"p"},"IF")," instruction.\nIt executes the first sequence if the optional value has no value assigned, otherwise it executes the second sequence of instructions (where a value has been assigned with a ",(0,o.kt)("inlineCode",{parentName:"p"},"SOME")," instruction)."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction encounters a NONE value it consumes it and then start executing the first sequence.",(0,o.kt)("br",{parentName:"p"}),"\n","If the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction encounters a SOME value it does not consumes it and then starts executing the second sequence."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6702).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 15: Illustration of the `IF_NONE` instruction"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(4668).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 16: Illustration of the `IF_NONE` instruction"),(0,o.kt)("p",null,"Michelson also introduces the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_SOME bt bf")," instruction which retrieves the value behind an optional and executes the first sequence if it encounters a SOME value. It executes the second sequence if it encounters a NONE value."),(0,o.kt)("h4",{id:"pair"},"PAIR"),(0,o.kt)("p",null,"The Michelson language introduces the ",(0,o.kt)("em",{parentName:"p"},"pair")," type which defines a data structure containing multiple fields. "),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"pair")," type is a tuple of 2 elements."),(0,o.kt)("p",null,"A  ",(0,o.kt)("em",{parentName:"p"},"pair")," type can contain values of any type, from primitive types (",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),") to advanced composite types such as ",(0,o.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"lambda")," function or ",(0,o.kt)("inlineCode",{parentName:"p"},"union"),"."),(0,o.kt)("h5",{id:"creating-and-destructuring-pairs"},"creating and destructuring pairs"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR")," instruction takes the top two elements of the stack and pushes back on top of the stack a pair containing these two elements."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR")," instruction takes the top element of the stack and ensures it is a ",(0,o.kt)("em",{parentName:"p"},"pair")," type. It pushes back on top of the stack the two elements of the ",(0,o.kt)("em",{parentName:"p"},"pair"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9141).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 18: Illustration of the _PAIR_ and _UNPAIR_ instructions"),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR")," instruction expects a ",(0,o.kt)("em",{parentName:"p"},"pair")," element on top of the stack. "),(0,o.kt)("p",null,"Similarly, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR")," instruction expects two elements in the stack. "),(0,o.kt)("h5",{id:"accessing-to-elements-of-a-pair"},"Accessing to elements of a ",(0,o.kt)("em",{parentName:"h5"},"PAIR")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CAR")," instruction consumes the top element of the stack (which must be a ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR"),") and pushes back on the top of the stack the left part of the pair."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(8771).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 19: Illustration of the `CAR` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," instruction consumes the top element of the stack (which must be a ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR"),") and pushes back on top of the stack the right part of the pair."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1675).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 20: Illustration of the `CDR` instruction"),(0,o.kt)("p",null,"These ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CAR")," instructions are useful to retrieve a part of a ",(0,o.kt)("em",{parentName:"p"},"PAIR"),'. As seen in the "Smart contract" section, when invoking a smart contract, the initial stack is defined by a ',(0,o.kt)("em",{parentName:"p"},"PAIR")," containing the parameter of the invoked entrypoint and the current storage value."),(0,o.kt)("p",null,"Now that we introduced basic instructions (like ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR"),') we can explain the empty contract seen in the "Smart contract" section.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter unit;\nstorage unit;\ncode { CDR ;\n       NIL operation ;\n       PAIR };\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6305).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 21: Execution of `CDR ; NIL operation ; PAIR`"),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," instruction retrieves the right part of the initial ",(0,o.kt)("em",{parentName:"p"},"PAIR"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"NIL operation")," pushed an empty list of operations on top of the stack. The ",(0,o.kt)("em",{parentName:"p"},"PAIR")," instructions forms a ",(0,o.kt)("em",{parentName:"p"},"pair")," type with the empty list of operations and the initial storage."),(0,o.kt)("p",null,"The next section will explain the list operators (",(0,o.kt)("inlineCode",{parentName:"p"},"NIL operation"),")."),(0,o.kt)("h5",{id:"nested-pairs"},"Nested pairs"),(0,o.kt)("p",null,"Michelson language doesn't directly support tuples of more than 2 elements, but we can instead create ",(0,o.kt)("strong",{parentName:"p"},"nested pairs"),". For example, the following nested ",(0,o.kt)("em",{parentName:"p"},"pair")," ",(0,o.kt)("inlineCode",{parentName:"p"},'PAIR (PAIR nat 5, string "Hello") int 37'),' contains a natural integer 5, a string "Hello" and an integer 37.'),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9860).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 17: Illustration of the C[AD]+R macro"),(0,o.kt)("p",null,"The creation of a ",(0,o.kt)("em",{parentName:"p"},"nested pair")," consists of a succession of ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR")," instructions (which reorganizes elements in the stack). This may become a fastidious exercise with large ",(0,o.kt)("em",{parentName:"p"},"nested pairs"),". The Michelson language supports these nested pairs by providing the ",(0,o.kt)("inlineCode",{parentName:"p"},"PAPPAIIR")," macros for creating ",(0,o.kt)("em",{parentName:"p"},"nested pair")," in a single instruction."),(0,o.kt)("p",null,"Similarly, the Michelson language provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAPPAIIR")," macro for destructuring ",(0,o.kt)("em",{parentName:"p"},"nested pairs"),"."),(0,o.kt)("p",null,"Similarly, the Michelson language provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"C[AD]+R")," macro for accessing a specific field inside a ",(0,o.kt)("em",{parentName:"p"},"nested pair"),". For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"CAAR")," macro stands for ",(0,o.kt)("inlineCode",{parentName:"p"},"{ CAR; CAR }")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CADAR")," macro stands for ",(0,o.kt)("inlineCode",{parentName:"p"},"{ CAR; CDR; CAR }"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(4200).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 22: Illustration of the C[AD]+R macro"),(0,o.kt)("p",null,'These macros are described in the "Instructions" section (in the "macros" sub-section).'),(0,o.kt)("p",null,"Here is an example of a smart contract that stores a natural integer in its storage and receives a nested pair (containing a ",(0,o.kt)("em",{parentName:"p"},"nat")," , a ",(0,o.kt)("em",{parentName:"p"},"string")," and an ",(0,o.kt)("em",{parentName:"p"},"int"),") as the parameter. It only takes the nat part of the nested pair and adds it to the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter (pair (pair (nat) (string)) (int));\nstorage nat;\ncode { UNPAIR;\n       CAAR;\n       ADD;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR")," separates the entry point and the storage."),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"CAAR")," extracts a single field from the ",(0,o.kt)("em",{parentName:"p"},"nested pair"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"CAAR")," macro only retrieves the ",(0,o.kt)("em",{parentName:"p"},"nat")," field of the parameter; it is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"{ CAR; CAR }"),"."),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_caar.tz on storage '9' and input 'Pair (Pair 2 \"toto\") -23'\n")),(0,o.kt)("p",null,"Notice that defining a Michelson expression containing a ",(0,o.kt)("em",{parentName:"p"},"pair")," in CLI expects a ",(0,o.kt)("inlineCode",{parentName:"p"},"Pair")," keyword (which is different from ",(0,o.kt)("em",{parentName:"p"},"pair")," type or ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR")," instruction)."),(0,o.kt)(s.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,"Annotation usage is recommended when creating complex types and nested _pairs_ (see [Annotation](/michelson/instructions-reference#annotation) section)")),(0,o.kt)("h4",{id:"numbers"},"Numbers"),(0,o.kt)("p",null,"Now let's focus on primitive types such as numbers."),(0,o.kt)("p",null,"There are two number types in Michelson. The ",(0,o.kt)("em",{parentName:"p"},"nat")," type represents natural integers and the ",(0,o.kt)("em",{parentName:"p"},"int")," type represents integers."),(0,o.kt)("h5",{id:"standard-arithmetic-operations"},"Standard arithmetic operations"),(0,o.kt)("p",null,"Standard arithmetic operations are supported by the Michelson language on ",(0,o.kt)("em",{parentName:"p"},"nat")," and ",(0,o.kt)("em",{parentName:"p"},"int")," types."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," instruction computes additions on ",(0,o.kt)("em",{parentName:"p"},"nat")," and ",(0,o.kt)("em",{parentName:"p"},"int"),". It consumes the top two elements of the stack and pushes back the addition of the two elements on top of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(3541).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 23: Illustration of the `ADD` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," instruction computes subtractions on ",(0,o.kt)("em",{parentName:"p"},"nat")," and ",(0,o.kt)("em",{parentName:"p"},"int"),". It consumes the top two elements of the stack and pushes back the difference of the two elements on top of the stack."),(0,o.kt)("p",null,"Notice that the subtraction of two natural integers (or of a natural integer and an integer) produces an integer (since the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"2 - 4")," produces a number smaller than 0)."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1254).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 24: Illustration of the `SUB` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MUL")," instruction computes multiplications on ",(0,o.kt)("em",{parentName:"p"},"nat")," and ",(0,o.kt)("em",{parentName:"p"},"int"),". It consumes the top two elements of the stack and pushes back the product of these two elements on top of the stack."),(0,o.kt)("p",null,"Notice that the multiplication of a natural integer and an integer produces an integer."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(803).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 25: Illustration of the `MUL` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction computes Euclidean divisions on ",(0,o.kt)("em",{parentName:"p"},"nat"),". The Euclidean division computes the quotient and the remainder between two numbers."),(0,o.kt)("p",null,"If the divisor is equal to zero, it returns an ",(0,o.kt)("em",{parentName:"p"},"option")," type with the assigned value ",(0,o.kt)("em",{parentName:"p"},"None"),". Otherwise, it applies the Euclidean division and returns an ",(0,o.kt)("em",{parentName:"p"},"option")," type containing the result (i.e. a ",(0,o.kt)("em",{parentName:"p"},"pair")," composed with the quotient and the remainder). "),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9640).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 26: Illustration of the `EDIV` instruction"),(0,o.kt)("h5",{id:"conversions-int---nat"},"Conversions ",(0,o.kt)("inlineCode",{parentName:"h5"},"int")," <-> ",(0,o.kt)("inlineCode",{parentName:"h5"},"nat")),(0,o.kt)("p",null,"The Michelson language also provides instructions to cast an integer into a natural integer with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ABS")," instruction. Respectively the ",(0,o.kt)("inlineCode",{parentName:"p"},"INT")," instruction casts a natural integer into an integer."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ABS")," instruction consumes an integer on top of the stack and pushes back the absolute value of this integer as a ",(0,o.kt)("em",{parentName:"p"},"nat")," value. "),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1370).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 27: Illustration of the `ABS` instruction"),(0,o.kt)("p",null,"The following smart contract illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"ABS")," usage. It receives an integer as an input parameter, computes the absolute value and adds it to the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter int;\nstorage nat;\ncode { UNPAIR;\n       ABS;\n       ADD;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_abs.tz on storage '9' and input '-2'\n")),(0,o.kt)("p",null,"The resulting storage has a value of 11."),(0,o.kt)("h4",{id:"string"},"String"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," type represents a sequence of characters and a ",(0,o.kt)("em",{parentName:"p"},"string")," value is composed of a sequence of ASCII printable characters (accents are not included)."),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"string")," value can be split and two ",(0,o.kt)("em",{parentName:"p"},"string")," values can be concatenated or linked together. A ",(0,o.kt)("em",{parentName:"p"},"string")," can be compared to an other ",(0,o.kt)("em",{parentName:"p"},"string"),"."),(0,o.kt)("p",null,"Like for numbers, a ",(0,o.kt)("em",{parentName:"p"},"string")," can be pushed on top of the stack with the ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'PUSH string "Hello World"\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction consumes a string of the top of the stack and pushes the number of characters contained in the string element."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction concatenates strings. It consumes the two top elements and produces a string (concatenation of the two top elements) that is placed on top of the stack. The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction also works with a list of strings. "),(0,o.kt)("p",null,"For example, the following smart contract concatenates a given string at the end of the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter string;\nstorage string;\ncode { UNPAIR ;\n       SWAP ;\n       CONCAT;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_string_example.tz on storage '\"one\"' and input '\"two\"'\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SLICE")," instruction provides a way to retrieve a part of a string.\nIt requires these three elements at the top of the stack and in this order:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an ",(0,o.kt)("inlineCode",{parentName:"li"},"offset")," argument indicating the beginning of the substring "),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("inlineCode",{parentName:"li"},"length")," argument indicating the size of the substring"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("inlineCode",{parentName:"li"},"string")," to slice")),(0,o.kt)("p",null,"It returns an optional string because the given offset may be out of bound. "),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2365).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 28: Illustration of the `SLICE` instruction"),(0,o.kt)("p",null,"For example, the following smart contract retrieves the first 5 characters of a given string and store them in the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter string;\nstorage string;\ncode { CAR;\n       PUSH nat 5;\n       PUSH nat 0;\n       SLICE;\n       IF_SOME {} { FAIL };\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_string_example2.tz on storage '\"\"' and input '\"Hello World\"'\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction allows two strings to be compared. It consumes the top two elements of the stack and pushes an integer to the top. If the first element is lexically greater than the second, then it returns 1. If the first element is lexically equal to the second element, then it returns 0. If the first element is lexically smaller than the second element, then it returns -1."),(0,o.kt)("h4",{id:"boolean-logic"},"Boolean logic"),(0,o.kt)("p",null,"Like most languages, the Michelson language supports boolean logic with a ",(0,o.kt)("em",{parentName:"p"},"bool")," type and standard boolean operators ",(0,o.kt)("inlineCode",{parentName:"p"},"OR")," ",(0,o.kt)("inlineCode",{parentName:"p"},"AND")," ",(0,o.kt)("inlineCode",{parentName:"p"},"XOR")," ",(0,o.kt)("inlineCode",{parentName:"p"},"NOT"),"."),(0,o.kt)("p",null,"These boolean operators are useful mixed with ",(0,o.kt)("inlineCode",{parentName:"p"},"IF")," instruction for creating complex conditions."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"OR")," instruction consumes the top two boolean elements of the stack and pushes back on top of the stack a logical ",(0,o.kt)("em",{parentName:"p"},"OR")," of both elements."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9328).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 29: Illustration of the `OR` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AND")," instruction consumes the top two boolean elements of the stack and computes a logical ",(0,o.kt)("em",{parentName:"p"},"AND")," of the two elements."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(3026).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 30: Illustration of the `AND` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"XOR")," instruction consumes the top two boolean elements of the stack and computes an exclusive logical ",(0,o.kt)("em",{parentName:"p"},"OR")," of the two elements."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(926).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 31: Illustration of the `XOR` instruction"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NOT")," instruction consumes a boolean top element of the stack and pushes the logical opposite of the given boolean. "),(0,o.kt)("h4",{id:"timestamp"},"Timestamp"),(0,o.kt)("p",null,"The Michelson language supports the ",(0,o.kt)("inlineCode",{parentName:"p"},"timestamp")," type. Like in most languages, a timestamp represents a number of seconds passed since the beginning of year 1970.\nTimestamps can be used in a smart contract to authorize actions on a certain period of time.  "),(0,o.kt)("p",null,"Timestamps can be obtained by the ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," operation, or retrieved from script parameters or globals."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," instruction pushes on top of the stack the timestamp of the block whose validation triggered this execution. This timestamp does not change during the execution of the contract."),(0,o.kt)("p",null,"This small contract registers when it is invoked, by saving the ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," timestamp in the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit;\nstorage timestamp;\ncode { DROP;\n       NOW;\n       NIL operation;\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DROP")," instruction empties the single data on the stack. The ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," instruction pushes on top of the stack the timestamp of the block. And finally, ",(0,o.kt)("inlineCode",{parentName:"p"},"NIL operation; PAIR")," instructions encapsulate the returned timestamp (i.e. the new storage state) with an empty list of operations."),(0,o.kt)("p",null,"This second small contract registers when it is invoked, by storing in a list of timestamps the ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," timestamp of its transaction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit;\nstorage (list timestamp);\ncode { CDR;\n       NOW;\n       CONS;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," instruction retrieves the storage part. The ",(0,o.kt)("inlineCode",{parentName:"p"},"NOW")," instruction pushes on top of the stack the timestamp of the block. And finally the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONS")," operator adds an element in a ",(0,o.kt)("em",{parentName:"p"},"list"),"."),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_timestamp.tz on storage '{ \"2021-04-01T12:43:31Z\" }' and input 'Unit'\n")),(0,o.kt)("p",null,"Notice that the storage (i.e. a list of timestamps) is initialized with a ",(0,o.kt)("em",{parentName:"p"},"timestamp")," value in string format ",(0,o.kt)("inlineCode",{parentName:"p"},'"2021-04-01T12:43:31Z"'),"."),(0,o.kt)("h5",{id:"standard-timestamp-operations"},"Standard timestamp operations"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," instruction increments a timestamp of the given number of seconds. The number of seconds must be expressed as an ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," instruction subtracts a number of seconds from a timestamp. It can also be used to subtract two timestamps and obtain an ",(0,o.kt)("em",{parentName:"p"},"int")," that represents the difference as a number of seconds."),(0,o.kt)("p",null,"For example, this smart contract when invoked computes the delay between two timestamps, and keeps it in the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter (pair timestamp timestamp);\nstorage int;\ncode { CAR;\n       UNPAIR;\n       SUB;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CAR")," instruction retrieves the parameter value. The ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR")," instruction pushes on top of the stack the two given timestamps. And finally the ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," operator computes the difference between the two timestamps."),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_timestamp2.tz on storage '0' and input 'Pair \"2021-04-01T12:43:31Z\" \"2021-04-01T12:42:31Z\"'\n")),(0,o.kt)("h5",{id:"comparing-timestamps"},"Comparing timestamps"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," computes timestamp comparison. It returns an integer, as with the ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction for an integer."),(0,o.kt)("p",null,"It returns ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," if the first timestamp is bigger than the second timestamp, ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," if both timestamps are equal, and ",(0,o.kt)("inlineCode",{parentName:"p"},"-1")," otherwise. "),(0,o.kt)("h4",{id:"bytes"},"Bytes"),(0,o.kt)("p",null,"Bytes are used for serializing data in order to check signatures and to compute hashes on them. They can also be used to incorporate data from the untyped outside world."),(0,o.kt)("p",null,"The Michelson language provides ",(0,o.kt)("em",{parentName:"p"},"bytes")," supports with common operators like for ",(0,o.kt)("em",{parentName:"p"},"string")," type. It also provides standard serialization and de-serialization. "),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"bytes")," values is composed by a sequence of hexadecimals prefixed by a ",(0,o.kt)("inlineCode",{parentName:"p"},"0x")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"0xa47ef2"),")."),(0,o.kt)("h5",{id:"serialization"},"Serialization"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PACK")," instruction serializes any value of packable type to its optimized binary representation. All types are packable with the exception of ",(0,o.kt)("em",{parentName:"p"},"operation")," and ",(0,o.kt)("em",{parentName:"p"},"big_map")," types.\nIt consumes the top element of the stack and push back the corresponding ",(0,o.kt)("em",{parentName:"p"},"bytes")," value on top of the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPACK")," instruction de-serializes a piece of data, if valid. It returns an ",(0,o.kt)("em",{parentName:"p"},"option")," initialized to ",(0,o.kt)("em",{parentName:"p"},"None")," if the de-serialization is invalid, or an ",(0,o.kt)("em",{parentName:"p"},"option")," initialized to ",(0,o.kt)("em",{parentName:"p"},"Some")," if valid."),(0,o.kt)("h5",{id:"standard-operators"},"Standard operators"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction concatenates two byte sequences. It can also be applied to a list of byte sequences. It consumes a list of byte sequences and pushes the concatenation of all sequences (in the respective order). The ",(0,o.kt)("em",{parentName:"p"},"list")," data structure will be explained later in this tutorial."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the size of a sequence of bytes. It consumes a byte sequence and pushes the number of bytes of the sequence."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SLICE")," instruction provides a way to retrieve a part of a byte sequence.\nIt expects the following elements on top of the stack:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an ",(0,o.kt)("inlineCode",{parentName:"li"},"offset"),", indicating the beginning of the byte sequence "),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("inlineCode",{parentName:"li"},"length"),", indicating the size of the sub-sequence"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("inlineCode",{parentName:"li"},"byte sequence")," to slice")),(0,o.kt)("p",null,"It returns an optional byte sequence because the given offset and length may be out of bound."),(0,o.kt)("p",null,"The following smart contract illustrates the slicing of bytes. It expects a ",(0,o.kt)("em",{parentName:"p"},"bytes")," value as parameter and saves in the storage the first 3 bytes. Otherwise if the offset or length elements do not fit the given ",(0,o.kt)("em",{parentName:"p"},"bytes")," value then it fails."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter bytes;\nstorage bytes;\ncode { CAR ;\n       PUSH nat 3;\n       PUSH nat 1;\n       SLICE ;\n       IF_NONE { FAIL } {};\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_bytes_slice.tz on storage '0x00' and input '0x12a47ef2'\n")),(0,o.kt)("p",null,"This command would produce a new storage value ",(0,o.kt)("inlineCode",{parentName:"p"},"0xa47ef2"),"."),(0,o.kt)("p",null,"The following command will fail (out-of-bound access) due to a too short ",(0,o.kt)("em",{parentName:"p"},"bytes")," value.  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_bytes_slice.tz on storage '0x00' and input '0x12a47e'\n")),(0,o.kt)("h5",{id:"comparing-bytes"},"Comparing bytes"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction computes a lexicographic comparison. As with other ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instructions, it returns 1 if the first sequence is bigger than the second sequence, 0 if both byte sequences are equal, or -1 otherwise."),(0,o.kt)("p",null,"The following smart contract concatenates the given bytes with the ones in the storage only if the parameter value is 0x12. Otherwise it fails."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter bytes;\nstorage bytes;\ncode { UNPAIR;\n       DUP;\n       PUSH bytes 0x12;\n       COMPARE;\n       EQ;\n       IF { CONCAT } { FAIL };\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_bytes.tz on storage '0xa2' and input '0x12'\n")),(0,o.kt)("h3",{id:"working-with-complex-data-structures"},"Working with complex data structures"),(0,o.kt)("p",null,"Since the beginning we have used simple data structures such as primitive types (",(0,o.kt)("em",{parentName:"p"},"int"),", ",(0,o.kt)("em",{parentName:"p"},"nat"),", ",(0,o.kt)("em",{parentName:"p"},"string"),", ",(0,o.kt)("em",{parentName:"p"},"pair")," and ",(0,o.kt)("em",{parentName:"p"},"option"),") but more complex types can be designed. "),(0,o.kt)("p",null,"The storage of the smart contract can store a single type which can combine composite types and ",(0,o.kt)("em",{parentName:"p"},"pairs")," to create a complex data structure. Let's take a deeper dive into composite data types."),(0,o.kt)("p",null,"A composite structure integrates many fields and can organize them in many ways. "),(0,o.kt)("p",null,"There are 5 kinds of composite data structures: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"ordered list")," of elements with type ",(0,o.kt)("em",{parentName:"li"},"list")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"set")," of unique elements with type ",(0,o.kt)("em",{parentName:"li"},"set")),(0,o.kt)("li",{parentName:"ul"},"an ",(0,o.kt)("strong",{parentName:"li"},"associative array")," (a collection of key-value pairs) implemented with the type ",(0,o.kt)("em",{parentName:"li"},"map")),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("strong",{parentName:"li"},"union")," (i.e. an exclusive composite type) implemented with nested ",(0,o.kt)("em",{parentName:"li"},"or")," structure."),(0,o.kt)("li",{parentName:"ul"},"an ",(0,o.kt)("strong",{parentName:"li"},"optional")," implements a type holding a value which handles an uninitialized state if a value hasn't been assigned.  (seen in the previous section)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"records")," containing multiple fields implemented with nested ",(0,o.kt)("em",{parentName:"li"},"PAIR")," structure (seen in the previous section). Notice that ",(0,o.kt)("em",{parentName:"li"},"records")," is not a reserved word of the language but just symbolizes the concept represented by nested pairs.")),(0,o.kt)("h4",{id:"list"},"LIST"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," type represents an ordered collection of elements of the same type. A ",(0,o.kt)("em",{parentName:"p"},"list")," can contain multiple occurrences of the same value. For example, here is a list of integers ",(0,o.kt)("inlineCode",{parentName:"p"},"{ 2; 4; 5; 3; 5 }"),"."),(0,o.kt)("h5",{id:"building-a-list"},"Building a list"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"NIL")," instruction pushes an empty list on the top of the stack. When creating a ",(0,o.kt)("em",{parentName:"p"},"list")," the type of list elements must be specified. For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"NIL operation")," pushes an empty list of operations on the top of the stack. Similarly ",(0,o.kt)("inlineCode",{parentName:"p"},"NIL int")," pushes an empty list of integers on top of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1658).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 32: Illustration of the `NIL` instruction"),(0,o.kt)("h5",{id:"adding-an-element-in-the-list"},"Adding an element in the list"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONS")," instruction allows you to add an element at the beginning of a list. It expects an element and a list on top of the stack, consumes them and pushes back the updated ",(0,o.kt)("em",{parentName:"p"},"list")," on top of the stack."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2472).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 33: Illustration of the `CONS` instruction"),(0,o.kt)("p",null,"To illustrate the ",(0,o.kt)("em",{parentName:"p"},"list")," type usage take a look at the following smart contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter int ;\nstorage (list int);\ncode { UNPAIR ;\n       CONS;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The unique entry point of smart contract expects an integer as input (",(0,o.kt)("inlineCode",{parentName:"p"},"parameter int"),").\nNotice that the storage of this smart contract is defined as a list of integers declared with ",(0,o.kt)("inlineCode",{parentName:"p"},"(list int)"),".\nThis smart contract concatenates the given integer at the beginning of the integer list and returns the updated list as the new state of the storage."),(0,o.kt)("p",null,"This smart contract can be simulated by running the following CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script max_list.tz on storage '{1;2;5;3}' and input '12'\n")),(0,o.kt)("p",null,"Notice that in the CLI command the integer list is specified by ",(0,o.kt)("inlineCode",{parentName:"p"},"{1;2;5;3}"),". "),(0,o.kt)("h5",{id:"removing-the-top-element-of-the-list"},"Removing the top element of the list"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_CONS bt bf")," instruction inspects a list. It requires two sequences of instructions (bt anf bf), as with the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF")," instruction."),(0,o.kt)("p",null,"This instruction removes the first element of the list, pushes it on top of the stack and executes the first sequence of instructions (",(0,o.kt)("inlineCode",{parentName:"p"},"bt"),"). If the list is empty, then the second list of instructions is executed (",(0,o.kt)("inlineCode",{parentName:"p"},"bf"),")."),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_CONS")," instruction allows you to inspect the first element of the list (and verifies the list is not empty). It also allows to relocate elements of a list or to filter elements of a list. "),(0,o.kt)("p",null,"As illustration purpose, the following smart contract stores a list of integer. When invoked, the smart contract modifies the storage by multiplying by 2 the first element of the list (and if the list is empty then it add element ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," in the list. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit ;\nstorage (list int);\ncode { CDR ;\n       IF_CONS { PUSH int 2; MUL; CONS } { NIL int; PUSH int 1; CONS };\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"Notice that the entry point expects a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," (i.e. no value expected)."),(0,o.kt)("p",null,"The smart contract can be simulated with the following CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_ifcons3.tz on storage '{1;2;5;3}' and input 'Unit'\n")),(0,o.kt)("p",null,"and"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_ifcons3.tz on storage '{}' and input 'Unit'\n")),(0,o.kt)("p",null,"Notice that the given parameter value is ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit")," of type ",(0,o.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,o.kt)("h5",{id:"using-list-map-iter-size"},"Using list (MAP, ITER, SIZE)"),(0,o.kt)("p",null,"Other list operators are available to apply a process on a list."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the number of elements in the list.\nIt consumes a list on the top of the stack and pushes the number of elements of the list back on top of the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MAP {}")," instruction updates a ",(0,o.kt)("em",{parentName:"p"},"list")," data structure by applying a sequence of instructions to each element of the list. It takes a ",(0,o.kt)("em",{parentName:"p"},"list")," element on top of the stack, applies the given sequence of instruction for each element and in the end, it produces a new list on top of the stack. "),(0,o.kt)("p",null,'The given sequence of instructions (i.e. called "body") has access to the stack, thus complex algorithms can be implemented. '),(0,o.kt)("p",null,"The following smart contract illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"MAP")," usage. This smart contract holds a list of integer in its storage and when invoked it increments each integer of the list by 1."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit ;\nstorage (list int);\ncode { CDR ;\n       MAP { PUSH int 1; ADD };\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the following CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_list_map.tz on storage '{1;2;5;3}' and input 'Unit'\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER {}")," instruction iterates on all elements of a ",(0,o.kt)("em",{parentName:"p"},"list")," and applies a sequence of instructions to each element. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction requires a sequence of instructions (called "body") that has access to the stack.'),(0,o.kt)("p",null,"For example, the following smart contract computes the sum of a list of integers (given as parameter). The resulting sum is stored in the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter (list int);\nstorage int;\ncode { CAR ; DIP { PUSH int 0 };\n       ITER { ADD };\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP { PUSH int 0 }")," instruction pushes the value ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," on the second element of the stack. It represents the initial value of resulting sum (before the computation)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER { ADD }")," instruction sums the current element of the list with the resulting sum. At the end of the loop, the list of integer has been folded into a single integer representing the sum of all integers of the given list."),(0,o.kt)("p",null,"This smart contract can be simulated with the following CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_list_sum.tz on storage '999' and input '{2;1;3;6;1;5;2}'\n")),(0,o.kt)("p",null,"An other example is described in the ",(0,o.kt)("em",{parentName:"p"},"Examples")," section (Example 2), about the computation of the maximum of a list."),(0,o.kt)("h4",{id:"set"},"SET"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," type represents an unordered collection of elements. It preserves the uniqueness of elements inside the collection. For example, here is a set of integers ",(0,o.kt)("inlineCode",{parentName:"p"},"{ 2; 4; 5 }"),"."),(0,o.kt)("h5",{id:"creation-and-uniqueness-checking"},"Creation and uniqueness checking"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EMPTY_SET 'elt")," instruction builds a new empty set for elements of a given type 'elt. The 'elt type must be a comparable type (i.e. the COMPARE primitive must be defined over it)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MEM")," instruction checks for the existence of an element in a set. It consumes an element and a set and pushes back a boolean on top of the stack which represents the existence of the element in the ",(0,o.kt)("inlineCode",{parentName:"p"},"set"),"."),(0,o.kt)("h5",{id:"modify-elements-of-the-set"},"Modify elements of the set"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction allows to add an element in a ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," or to remove an element from a set."),(0,o.kt)("p",null,"It takes the top three elements of the stack:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an element whose type corresponds to the ",(0,o.kt)("em",{parentName:"li"},"set")," type"),(0,o.kt)("li",{parentName:"ul"},"a boolean representing the existence of this element in the ",(0,o.kt)("em",{parentName:"li"},"set")),(0,o.kt)("li",{parentName:"ul"},"a set to update")),(0,o.kt)("p",null,"If the boolean argument is ",(0,o.kt)("em",{parentName:"p"},"False")," then the element will be removed."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2716).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 34: Illustration of the `UPDATE` instruction"),(0,o.kt)("p",null,"If the boolean argument is ",(0,o.kt)("em",{parentName:"p"},"True")," then the element will be inserted."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(8665).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 35: Illustration of the `UPDATE` instruction"),(0,o.kt)("p",null,"An attempt to add a value which already exists in the set will let the ",(0,o.kt)("em",{parentName:"p"},"set")," unchanged. Similarly an attempt to remove a value which does not exist in the set will let the ",(0,o.kt)("em",{parentName:"p"},"set")," unchanged."),(0,o.kt)("p",null,"The following smart contract illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction usage. This smart contract stores a set of integers and can be invoked by specifying an integer that will be inserted in the set."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage (set int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       PUSH bool True ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"You can test the smart contract with the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script set_example.tz on storage '{1; 2; 3; 9}' and input '7'\n")),(0,o.kt)("p",null,"The following diagram illustrates the execution of this command"),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(8410).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 36: Illustration of the `UPDATE` instruction on a _set_ type"),(0,o.kt)("h5",{id:"apply-process-on-a-set"},"Apply process on a set"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," instruction iterates on all elements of a ",(0,o.kt)("em",{parentName:"p"},"set")," and applies a sequence of instructions to each element. The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction requires a sequence of instructions (called "body") that has access to the stack.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," usage on ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," is similar to its usage on ",(0,o.kt)("inlineCode",{parentName:"p"},"list"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction consumes a set from the top of the stack and pushes to the top the number of elements contained in the set."),(0,o.kt)("h4",{id:"map"},"MAP"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," is an associative array. It stores many pairs of key-value elements, i.e. it binds a key and a value. Type definitions of key and value must be defined when instantiating a new ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"map")," data structure can only contain a limited amount of data. Another associative array called ",(0,o.kt)("inlineCode",{parentName:"p"},"big_map")," is introduced in the Michelson language to optimize the storage of large amount of data. "),(0,o.kt)("p",null,"These big_maps should be used if you intend to store large amounts of data in a map. Using big_maps can reduce gas costs significantly compared to standard maps, as as data is lazily deserialized. "),(0,o.kt)("p",null,"The behavior of ",(0,o.kt)("inlineCode",{parentName:"p"},"GET"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MEM")," instructions is the same on big_maps as on standard maps. Note however that single operations on big_maps have higher gas costs than those over standard maps (because, under the hood, they have to load and deserialize data on demand). "),(0,o.kt)("h5",{id:"building-a-map"},"Building a map"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EMPTY_MAP 'key 'val")," instruction builds a new empty map. It requires the type definition of the key (",(0,o.kt)("em",{parentName:"p"},"'key"),") and types definition of the value (",(0,o.kt)("em",{parentName:"p"},"'val"),")."),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"'key")," type must be comparable (the COMPARE primitive must be defined over it)."),(0,o.kt)("p",null,"For example, this smart contract always returns an empty ",(0,o.kt)("em",{parentName:"p"},"map")," (typed map string int) and an empty list of ",(0,o.kt)("em",{parentName:"p"},"operations"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit;\nstorage (map string int);\ncode { DROP;\n       EMPTY_MAP string int;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This script can be simulated with the following command line:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_empty_map.tz on storage '{ Elt \"toto\" 1 }' and input 'Unit'\n")),(0,o.kt)("p",null,"Notice that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EMPTY_BIG_MAP")," instruction builds a new empty ",(0,o.kt)("inlineCode",{parentName:"p"},"big_map")," data structure.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The Michelson syntax for defining a non-empty ",(0,o.kt)("em",{parentName:"p"},"map")," value is:"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{ Elt <key1> <value1>; Elt <key2> <value2> }\n")),(0,o.kt)("h5",{id:"checking-existence-of-a-binding-for-the-key"},"Checking existence of a binding for the key"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MEM")," instruction checks for the existence of a binding for a key in a map."),(0,o.kt)("p",null,"It expects a key and a map on top of the stack and pushes back a boolean on top of the stack which represents the existence of the element in the ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,o.kt)("h5",{id:"modifying-a-map"},"Modifying a map"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction adds, removes or updates an element in a map."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction expects a key, an optional value and a map on top of the stack. It consumes the key and the optional value and modifies the map accordingly."),(0,o.kt)("p",null,"If the optional value is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),", then the element is removed from the map.\nIf the optional value is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," value, then the element corresponding to the given key is updated with the given value.  "),(0,o.kt)("p",null," The following smart contract (map_remove_example.tz) illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," usage while removing an element from the map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       NONE int ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be tested with the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_remove_example.tz on storage '{ Elt \"toto\" 1 }' and input '\"toto\"'\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6016).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 37: Illustration of the `UPDATE` instruction"),(0,o.kt)("p",null,"If the optional value is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," then the element is inserted into the map. The following smart contract (map_insert_example.tz) illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," usage while inserting an element into the map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       PUSH int 2;\n       SOME ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be tested with the following command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_insert_example.tz on storage '{ Elt \"toto\" 1 }' and input '\"tutu\"'\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9765).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 38: Illustration of the `UPDATE` instruction"),(0,o.kt)("h4",{id:"accessing-element-of-a-map"},"Accessing element of a map"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"GET")," instruction allows access to an element inside a map. It returns an optional value to be checked with an ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_SOME")," instruction."),(0,o.kt)("p",null,"The following smart contract illustrates the usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"GET"),". The storage of this contract defines a map. This smart contract takes a key as the parameter and inserts a new element in the map if the key does not exist. In this case, it assigns the value 0 to the given key. Or if the map possesses an element for the given key then it increments its associated value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ;\n       CAR ;\n       DIP { CDR } ;\n       DIP { DUP } ;\n       DUP ;\n       DIP { SWAP } ;\n       GET ;\n       IF_NONE { PUSH int 0 ; SOME } { PUSH int 1 ; ADD ; SOME } ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"This smart contract can be simulated with the following commands:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_example.tz on storage '{}' and input '\"toto\"'\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_example.tz on storage '{ Elt \"toto\" 5 }' and input '\"toto\"'\n")),(0,o.kt)("p",null,"Notice that ",(0,o.kt)("inlineCode",{parentName:"p"},"{}")," represents an empty map and ",(0,o.kt)("inlineCode",{parentName:"p"},'{ Elt "toto" 5 }'),' a map containing one element where "toto" is the key and its associated value is 5.'),(0,o.kt)("p",null,"The following diagram illustrates the execution of this command."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6158).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 39: Illustration of the `GET` and `UPDATE`  instructions"),(0,o.kt)("h5",{id:"applying-some-process-on-a-map"},"Applying some process on a map"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the number of elements inside a map. It consumes a map on top of the stack and places the number of elements on top of the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction cannot be applied to the ",(0,o.kt)("inlineCode",{parentName:"p"},"big_map")," type. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MAP")," instruction updates a ",(0,o.kt)("em",{parentName:"p"},"map")," data structure by applying a sequence of instructions to each element of a ",(0,o.kt)("inlineCode",{parentName:"p"},"map"),'. It takes a sequence of instructions as its argument (called "body") which has access to the stack.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MAP")," instruction takes a ",(0,o.kt)("em",{parentName:"p"},"map")," on top of the stack, applies the given sequence of instruction for each element and in the end, it produces a new ",(0,o.kt)("em",{parentName:"p"},"map")," on top of the stack. "),(0,o.kt)("p",null,"The following smart contract (map_map_example.tz) illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"MAP")," usage. This smart contract stores a ",(0,o.kt)("inlineCode",{parentName:"p"},"map string nat")," and when invoked it goes through all key-value elements of the map and multiplies by 2 the ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter unit ;\nstorage (map string nat) ;\ncode {\n       CDR ;\n       MAP { CDR ; PUSH nat 2 ; MUL }  ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The smart contract can be simulated with the following command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'tezos-client run script map_map_example.tz on storage \'{ Elt "toto" 1 ; Elt "tutu" 4 }\' and input Unit\n')),(0,o.kt)("h5",{id:"iterating-on-a-map"},"Iterating on a map"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER body")," instruction iterates on all elements of a ",(0,o.kt)("em",{parentName:"p"},"map"),' and applies a sequence of instructions (called "body") to each element. So, the "body" sequence expects an element of the stack (i.e. a ',(0,o.kt)("em",{parentName:"p"},"pair"),' key-value) on top of the stack. The "body" sequence has access to the underlying stack.'),(0,o.kt)("p",null,'An example ("Max list") illustrating ',(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," instruction usage is described in the ",(0,o.kt)("em",{parentName:"p"},"Examples")," section. Despite being applied to a list of integers, the ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," instruction works in the same way with a map (except at each iteration a ",(0,o.kt)("em",{parentName:"p"},"pair"),' key-value is pushed on the stack instead of an integer, as in the example "Max list").'),(0,o.kt)("h4",{id:"union"},"Union"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," data structure specifies two possible type definitions with logical ",(0,o.kt)("em",{parentName:"p"},"or"),". It can be used to create a new type that can handle two different types exclusively."),(0,o.kt)("p",null,'For example, the following Michelson expression defines the type "int_or_nat" as:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"or int nat\n")),(0,o.kt)("p",null,"The logical ",(0,o.kt)("em",{parentName:"p"},"or")," operator has 2 branches a left part and a right part. It is possible to form nested ",(0,o.kt)("em",{parentName:"p"},"or")," structure in order to combine more than 2 types. For example, the type ",(0,o.kt)("inlineCode",{parentName:"p"},"string_or_int_or_nat")," would be defined by "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"or (or (int) (nat)) (string)\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Unions")," are often used to define the ",(0,o.kt)("strong",{parentName:"p"},"parameter")," of the smart contract. As said in previous sections, the smart contract accepts a single parameter. This ",(0,o.kt)("strong",{parentName:"p"},"parameter")," can be a ",(0,o.kt)("em",{parentName:"p"},"union")," and thus offer multiple choices (i.e. multiple entry points)."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter (or (or (nat %add) (nat %sub)) (unit %default))"),' defines the parameter of a smart contract as a union of three entry points (add, sub, default). Each entrypoint specifies the expected argument type (e.g. "add" entry point expects an integer).'),(0,o.kt)("p",null,"Notice that when using a nested ",(0,o.kt)("em",{parentName:"p"},"or"),' structure for the parameter of the smart contract, each entry point requires an annotation ("%add", "%sub") which is not the case for regular ',(0,o.kt)("em",{parentName:"p"},"union")," such as ",(0,o.kt)("inlineCode",{parentName:"p"},"string_or_int_or_nat"),"."),(0,o.kt)("h5",{id:"left--right"},"LEFT & RIGHT"),(0,o.kt)("p",null,"When using ",(0,o.kt)("em",{parentName:"p"},"union")," type it is necessary to respect the strict typing of the Michelson language.\nFor example, let's consider the type ",(0,o.kt)("em",{parentName:"p"},"int_or_nat")," defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"or int nat"),". A single integer value cannot be held in an ",(0,o.kt)("em",{parentName:"p"},"int_or_nat"),' type. It has to be "cast" in a logical ',(0,o.kt)("em",{parentName:"p"},"or")," structure. The ",(0,o.kt)("inlineCode",{parentName:"p"},"LEFT")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"RIGHT")," operators are provided by the Michelson language to form logical ",(0,o.kt)("em",{parentName:"p"},"or")," structures based on a single value. Obviously, the type of the given value can be deduced but the other possible type of the ",(0,o.kt)("em",{parentName:"p"},"or")," must be specified. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LEFT p")," instruction takes the top-element of the stack and produces a ",(0,o.kt)("em",{parentName:"p"},"union"),".\nThe top element is placed in the right branch of the ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," structure and the left branch is typed with the given ",(0,o.kt)("inlineCode",{parentName:"p"},"p")," argument."),(0,o.kt)("p",null,"It consumes a type definition on top of the stack and pushes a union where the left part is defined as the consumed type definition."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(387).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 40: Illustration of the `LEFT` instruction"),(0,o.kt)("p",null,"Usage of the ",(0,o.kt)("inlineCode",{parentName:"p"},"LEFT")," instruction is illustrated in the example section."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RIGHT p")," instruction takes the top-element of the stack and produces a ",(0,o.kt)("em",{parentName:"p"},"union"),".\nThe top-element is placed in the left branch of the ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," structure and the right branch is typed with the given ",(0,o.kt)("inlineCode",{parentName:"p"},"p")," argument."),(0,o.kt)("p",null,"It consumes a type definition on top of the stack and pushes a union where the right part is defined as the consumed type definition."),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(3394).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 41: Illustration of the `RIGHT` instruction"),(0,o.kt)("p",null,"Usage of the ",(0,o.kt)("inlineCode",{parentName:"p"},"RIGHT")," instruction is illustrated in the example section."),(0,o.kt)("p",null,"Now that the creation of a ",(0,o.kt)("em",{parentName:"p"},"union")," is described, let's see how to inspect a ",(0,o.kt)("em",{parentName:"p"},"union"),"."),(0,o.kt)("h5",{id:"inspecting-a-union-with-if_left"},"Inspecting a ",(0,o.kt)("em",{parentName:"h5"},"union")," with ",(0,o.kt)("inlineCode",{parentName:"h5"},"IF_LEFT")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction inspects a value of ",(0,o.kt)("em",{parentName:"p"},"union"),". It requires two sequences of instructions (bt bf), like with an ",(0,o.kt)("inlineCode",{parentName:"p"},"IF")," instruction. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT bt bf"),' executes the "bt" sequence if the left part of a ',(0,o.kt)("em",{parentName:"p"},"union"),' has been given, otherwise it will execute the "bf" sequence.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction consumes a Michelson expression on top of the stack which specifies which part of the ",(0,o.kt)("em",{parentName:"p"},"union")," has been defined and pushes on top of the stack the element underneath the ",(0,o.kt)("em",{parentName:"p"},"union"),"."),(0,o.kt)("p",null,"The following smart contract (union_example.tz) illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," usage. Notice that the parameter is a ",(0,o.kt)("em",{parentName:"p"},"union")," ",(0,o.kt)("inlineCode",{parentName:"p"},"(or string int)")," and the storage is an integer. This smart contract increments the storage if an integer is passed as a parameter (i.e. if the smart contract is invoked with an integer) and does nothing if a string is given."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or string int) ;\nstorage int ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       IF_LEFT { DROP } { ADD } ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"To illustrate the invocation of the smart contract, we will break down its execution."),(0,o.kt)("p",null,"The following command simulates the execution of the smart contract when called with an integer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script union_example.tz on storage '5' and input 'Right 1'\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(1077).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 42: Illustration of the `IF_LEFT` instruction"),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction consumes the ",(0,o.kt)("em",{parentName:"p"},"union")," value ",(0,o.kt)("inlineCode",{parentName:"p"},"RIGHT int 1")," and pushed back the element behind the ",(0,o.kt)("em",{parentName:"p"},"right")," branch ",(0,o.kt)("inlineCode",{parentName:"p"},"int 1"),", and finally selects the ",(0,o.kt)("inlineCode",{parentName:"p"},"{ ADD }")," sequence."),(0,o.kt)("p",null,"The following command simulates the execution of the smart contract when called with a string."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script union_example.tz on storage '5' and input 'Left \"Hello\"'\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(2841).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 43: Illustration of the `IF_LEFT` instruction"),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction consumes the ",(0,o.kt)("em",{parentName:"p"},"union")," value ",(0,o.kt)("inlineCode",{parentName:"p"},'LEFT string "Hello"')," and pushed back the element behind the ",(0,o.kt)("em",{parentName:"p"},"left")," branch ",(0,o.kt)("inlineCode",{parentName:"p"},'string "Hello"'),", and finally selects the ",(0,o.kt)("inlineCode",{parentName:"p"},"{ DROP }")," sequence."),(0,o.kt)("h3",{id:"contract-specific-types-and-operations"},"Contract specific types and operations"),(0,o.kt)("p",null,"Now let's focus on the specific types related to Tezos smart contract such as crypto-currency (mutez), address identifying an account or a contract, delegation."),(0,o.kt)("h4",{id:"mutez"},"Mutez"),(0,o.kt)("p",null,"Mutez (micro-Tez) are internally represented by a 64-bit, signed integer. "),(0,o.kt)("p",null,"There are restrictions to prevent creating a negative amount of mutez. Operations are limited in order to prevent overflow and to avoid mixing with other numerical types by mistake. "),(0,o.kt)("p",null,"Operations ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MUL")," must be checked for overflows (i.e. the ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MUL")," instructions will fail in case of overflow)."),(0,o.kt)("p",null,"Operations ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," must be checked for underflow (i.e. the ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," instruction will fail if the result is negative)."),(0,o.kt)("p",null,"So, keep in mind that taking under/overflows into account is mandatory while manipulating ",(0,o.kt)("em",{parentName:"p"},"mutez")," type."),(0,o.kt)("h5",{id:"standard-currency-operations"},"Standard currency operations"),(0,o.kt)("p",null,"Standard operations on currency are supported by the Michelson language. These operators are more restricted than for integers."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD")," instruction computes additions on mutez. It consumes two ",(0,o.kt)("em",{parentName:"p"},"mutez")," elements on top of the stack and pushes back the addition of the two quantities on top of the stack.\nThis operation may fail in case of overflow."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SUB")," instruction computes subtractions on mutez. It consumes two ",(0,o.kt)("em",{parentName:"p"},"mutez")," elements on top of the stack and pushes back the difference of the two quantities on top of the stack.\nA ",(0,o.kt)("em",{parentName:"p"},"mutez")," value cannot be negative so this subtraction may fail if the first value is smaller than the second one."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MUL")," instruction computes multiplications on mutez. It consumes a ",(0,o.kt)("em",{parentName:"p"},"mutez")," and a ",(0,o.kt)("em",{parentName:"p"},"nat")," elements on top of the stack and pushes back the product of the two quantities on top of the stack.\nThe multiplication allows mutez to be multiplied with natural integers.\nMultiplication of 2 ",(0,o.kt)("inlineCode",{parentName:"p"},"mutez")," operands is not allowed. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction computes the Euclidean division on mutez. It consumes a ",(0,o.kt)("em",{parentName:"p"},"mutez")," and a ",(0,o.kt)("em",{parentName:"p"},"nat")," elements on top of the stack and pushes back a ",(0,o.kt)("inlineCode",{parentName:"p"},"pair")," with the quotient and the reminder (of the two elements) on top of the stack."),(0,o.kt)("p",null,"The Euclidean division allows a mutez to be divided by a natural integer. It is also possible to divide 2 mutez, in this case, it returns a ",(0,o.kt)("em",{parentName:"p"},"pair")," composed with a ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," as a quotient and a mutez as the rest of the Euclidean division."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction compares two mutez and returns an integer on top of the stack. It returns 0 if both elements are equal, 1 if the first element is bigger than the second, and -1 otherwise. "),(0,o.kt)("h4",{id:"contract-communication"},"Contract communication"),(0,o.kt)("p",null,"This section describes instructions specific to smart contracts and interactions between contracts. It includes key features such as emitting transactions and invoking a contract, setting delegations, and even creating contracts on the fly. "),(0,o.kt)("p",null,"This section introduces the ",(0,o.kt)("em",{parentName:"p"},"address")," type identifying an account or a deployed smart contract; and other built-in instructions related to transactions."),(0,o.kt)("h5",{id:"address-type"},(0,o.kt)("inlineCode",{parentName:"h5"},"address")," type"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"address"),' type represents an identifier for a user account or a deployed smart contract (e.g. "tz1n2Vm2dvjey...", "KT1faswCTD..." ).'),(0,o.kt)("p",null,"For example, an ",(0,o.kt)("em",{parentName:"p"},"address")," value can be pushed on top of the stack with the ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH")," instruction (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},'PUSH address "tz1n2Vm2dvjey..."'),")."),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"address")," type is a comparable type (i.e. ",(0,o.kt)("em",{parentName:"p"},"address")," values can be compared between each other). Addresses of implicit accounts are considered strictly less than addresses of originated accounts. Addresses of the same type are compared lexicographically."),(0,o.kt)("p",null,"Built-ins macros such as SOURCE or SENDER push an ",(0,o.kt)("em",{parentName:"p"},"address"),' value on top of the stack. (see "Built-ins" section) '),(0,o.kt)("h5",{id:"entrypoint-verification-with-contract"},"Entrypoint verification with ",(0,o.kt)("inlineCode",{parentName:"h5"},"CONTRACT")),(0,o.kt)("p",null,'Smart contract communicates among each other with transactions. When invoking a smart contract, the execution must insure that the invocation parameter matches the parameter of the targeted smart contract. For example, if a smart contract (possessing 2 entrypoints) can only "Increment" and "Decrement" one can not ask it to "Multiply". In the same manner, the arguments of entrypoints must be respected.'),(0,o.kt)("p",null,"All this verification is done based on entry point definition and expectation. The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT")," stands for this concept. Actually the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction permits to specify what kind of entry points one expects to invoke (i.e. the type definition of invoked entrypoint)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction casts the address to the given contract type if possible.\nIt consumes an ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," to the top element of the stack and returns a contract instance that corresponds to the given parameter type.\nThe element returned on top of the stack is typed ",(0,o.kt)("em",{parentName:"p"},"option contract")," and its value represents a valid instance of contract at the given address."),(0,o.kt)("p",null,"The parameter is ",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," in case of an implicit account."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction considers the default entrypoint if it exists, otherwise the full parameter is returned. "),(0,o.kt)("h5",{id:"transaction-with-transfer_tokens"},"Transaction with ",(0,o.kt)("inlineCode",{parentName:"h5"},"TRANSFER_TOKENS")),(0,o.kt)("p",null,"Communication between contracts (and accounts) are done via transactions. The Michelson language supports the creation of transactions."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction forges a transaction. In Michelson, the ",(0,o.kt)("inlineCode",{parentName:"p"},"operation")," type represents a transaction.\nForging a transaction requires the following to be specified: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("em",{parentName:"li"},"parameter")," (i.e. the entrypoint expected by the targeted contract)"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("em",{parentName:"li"},"quantity of mutez")," transferred by this transaction"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("em",{parentName:"li"},"recipient contract")," representing the target of the transaction (i.e. to which contract this transaction will be sent)")),(0,o.kt)("p",null,"The parameter must be consistent with the one expected by the contract.\nIf the transaction is sent to an implicit account (i.e. the address of an account) then the parameter must be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction consumes the three top elements of the stack and outputs a transaction on top of the stack."),(0,o.kt)("p",null,"As seen in previous sections, the invocation of a Tezos smart contract produces a list of operations and a new storage state. In a smart contract, when using a ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction to forge a transaction the produced transaction must be included in the returned list of operations in order to be taken into account."),(0,o.kt)("p",null,"To illustrate the usage of the ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS"),' instruction, we will consider a simple "Counter" smart contract that can increment or decrement a value. We will create a second smart contract, "CounterCaller", which forges a transaction and sends it to the "Counter" smart contract using the ',(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction."),(0,o.kt)("p",null,'The following smart contract demonstrates the implementation of the "Counter" smart contract.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or (int %decrement) (int %increment)) ;\nstorage int ;\ncode { DUP ;\n       CDR ;\n       SWAP ;\n       CAR ;\n       IF_LEFT { SWAP ; SUB } { ADD } ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,'The following smart contract demonstrates the implementation of the "CounterCaller" smart contract.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or int int);\nstorage address;\ncode {\n       DUP;\n       DUP;\n       CDR;\n       CONTRACT (or int int);\n       IF_NONE\n              {DROP; NIL operation }\n              {\n                     SWAP;\n                     CAR;\n                     DIP {PUSH mutez 0};\n                     TRANSFER_TOKENS;\n                     DIP {NIL operation;};\n                     CONS;\n              };\n       DIP { CDR };\n       PAIR }\n")),(0,o.kt)("p",null,'Now, let\'s break down the execution of the "CounterCaller" smart contract:'),(0,o.kt)("p",null,"The following command simulates the invocation of the smart contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script countercaller.tz on storage '\"KT1HUbVyf62ZAp7BRqwQaDueb6kgb7Q86cc3\"' and input 'Left 3'\n")),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(6179).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 44: Illustration of the `TRANSFER_TOKENS` instruction"),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT (or int int)")," instruction produces an optional instance of contract. This instance,once the optional is resolved, is typed ",(0,o.kt)("inlineCode",{parentName:"p"},"contract (or int int)")," and its value contains the ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," of a valid deployed smart contract (",(0,o.kt)("inlineCode",{parentName:"p"},'instance @"KT.."')," in the schema)."),(0,o.kt)("h5",{id:"delegation-with-set_delegate"},"Delegation with ",(0,o.kt)("inlineCode",{parentName:"h5"},"SET_DELEGATE")),(0,o.kt)("p",null,"Delegation is when you delegate your staking/baking rights to another person (called \u201cbaker\u201d), rather than setting your own Tezos node. It\u2019s a quite useful feature as it allows you to participate in staking and receive Tezos staking rewards without the necessity of maintaining a node (see Chapter Baking)."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SET_DELEGATE")," sets or withdraws the contract's delegation. It consumes an ",(0,o.kt)("em",{parentName:"p"},"option key_hash")," specifying the delegate and returns a transaction (operation) on top of the stack."),(0,o.kt)("p",null,"Using this instruction is the only way to modify the delegation of a smart contract. If the top element is ",(0,o.kt)("em",{parentName:"p"},"None"),", then the delegation of the current contract is withdrawn. If the top element is ",(0,o.kt)("em",{parentName:"p"},"Some kh"),", where ",(0,o.kt)("em",{parentName:"p"},"kh")," is the key hash of a registered delegate (that is not the current delegate of the contract), then this operation sets the delegate of the contract to this registered delegate. The operation fails if ",(0,o.kt)("em",{parentName:"p"},"kh")," is the current delegate of the contract or if ",(0,o.kt)("em",{parentName:"p"},"kh")," is not a registered delegate."),(0,o.kt)("h5",{id:"inspecting-the-balance-of-the-contract"},"Inspecting the balance of the contract"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"BALANCE")," instruction pushes the current amount of mutez held by the executing contract to the stack, including any mutez added by the calling transaction."),(0,o.kt)("h5",{id:"creating-contract-dynamically-with-create_contract"},"Creating contract dynamically with ",(0,o.kt)("inlineCode",{parentName:"h5"},"CREATE_CONTRACT")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction forges a new contract. It consumes the top three elements of the stack and pushes back a ",(0,o.kt)("em",{parentName:"p"},"transaction")," (responsible for creating the contract) and the ",(0,o.kt)("em",{parentName:"p"},"address")," of the newly created contract."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction expects as an argument the smart contract definition as a literal ",(0,o.kt)("inlineCode",{parentName:"p"},"{ storage 'g ; parameter 'p ; code ... }"),", including the storage definition, parameter definition and the code of the smart contract."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction expects three elements on top of the stack (these elements represent arguments for deploying a contract):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the initial storage value for the new contract."),(0,o.kt)("li",{parentName:"ul"},"an optional ",(0,o.kt)("inlineCode",{parentName:"li"},"key_hash")," value representing the delegate"),(0,o.kt)("li",{parentName:"ul"},"a quantity of mutez transferred to the new contract")),(0,o.kt)("p",null,"Accessing the newly created contract (via a ",(0,o.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction) will fail until it is actually originated."),(0,o.kt)("p",null,'So as to illustrate the dynamic creation of contracts, let\'s make a smart contract that creates the "Counter" contract seen previously in ',(0,o.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS"),"."),(0,o.kt)("p",null,'The implementation of the "Counter" smart contract is:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or (int %decrement) (int %increment)) ;\nstorage int ;\ncode { DUP ;\n       CDR ;\n       SWAP ;\n       CAR ;\n       IF_LEFT { SWAP ; SUB } { ADD } ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,'Now let\'s see the implementation of a "Factory" contract that creates and deploys a "Counter" contract.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit;\nstorage unit;\ncode { DROP;\n       PUSH int 9;\n       PUSH mutez 0;\n       NONE key_hash;\n       CREATE_CONTRACT { parameter (or (int %decrement) (int %increment)) ; storage int ; code { DUP ; CDR ; SWAP ; CAR ; IF_LEFT { SWAP ; SUB } { ADD } ; NIL operation ; PAIR } };\n       DIP { NIL operation };\n       CONS;\n       DIP { DROP; UNIT };\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"DROP")," instruction removes entrypoint and storage elements from the stack since they are not used."),(0,o.kt)("p",null,"The first expected element for ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," is the delegate of the smart contract. Here we specify there is none (",(0,o.kt)("inlineCode",{parentName:"p"},"NONE key_hash;"),"). Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"NONE")," instruction must be typed.\nThe second expected element for ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," is the quantity of mutez transferred to the new contract. Here we specify 0 with ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH mutez 0;"),".\nThe third expected element for ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," is the initial storage value for the new contract. Here the ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH int 9;")," set the default counter value to 9."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction produces on top of the stack an ",(0,o.kt)("em",{parentName:"p"},"operation")," and the ",(0,o.kt)("em",{parentName:"p"},"address")," of the contract.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP { NIL operation }; CONS")," sequence adds this operation into a list of operation (which will constitute the return of the smart contract).\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP { DROP }")," sequence deletes the address of the (because we don't use it here).\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"UNIT")," instruction specifies an empty storage as described in the storage definition (",(0,o.kt)("inlineCode",{parentName:"p"},"storage unit;"),")\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"PAIR")," instruction forms the ",(0,o.kt)("em",{parentName:"p"},"pair")," returned by the smart contract (including the list of operation and the storage)."),(0,o.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script factory.tz on storage 'Unit' and input 'Unit'\n")),(0,o.kt)("p",null,"This CLI command produces the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"storage\n  Unit\nemitted operations\n  Internal origination:\n    From: KT1BEqzn5Wx8uJrZNvuS9DVHmLvG9td3fDLi\n    Credit: \ua7290\n    Script:\n      { parameter (or (int %decrement) (int %increment)) ;\n        storage int ;\n        code { DUP ;\n               CDR ;\n               SWAP ;\n               CAR ;\n               IF_LEFT { SWAP ; SUB } { ADD } ;\n               NIL operation ;\n               PAIR } }\n      Initial storage: 9\n      No delegate for this contract\n")),(0,o.kt)("h5",{id:"built-ins"},"Built-ins"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADDRESS")," instruction casts the contract to its address. It consumes a contract on top of the stack and pushes back the address of the contract."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SELF")," instruction pushes the default entry point of a contract on top of the stack. This default entry point specifies the expected parameter type.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"SELF 'p")," instruction allows you to take a entry point name 'p as argument. In this case, it pushed the specified entrypoint on top of the stack. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SOURCE")," instruction pushes the address of the contract that initiated the current transaction, i.e. the contract that paid the fees and storage cost, and whose manager signed the operation that was sent on the blockchain. Note that since the TRANSFER_TOKENS instructions can be chained, ",(0,o.kt)("inlineCode",{parentName:"p"},"SOURCE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"SENDER")," are not necessarily the same."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SENDER")," instruction pushes the address of the contract that initiated the current internal transaction. It may be the ",(0,o.kt)("inlineCode",{parentName:"p"},"SOURCE"),", but may also be different if the source sent an order to an intermediate smart contract, which then called the current contract."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SOURCE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"SENDER")," built-ins represent the identity that invoked the smart contract. "),(0,o.kt)("p",null,"To illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"SENDER")," macro, here is a smart contract handling a set of address as storage. When invoked this smart contract saves the identifier of the invoker (i.e. its ",(0,o.kt)("em",{parentName:"p"},"address"),") inside the storage."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter unit;\nstorage (set address);\ncode { CDR;\n       SENDER;\n       DIP { PUSH bool True };\n       UPDATE;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CDR")," extracts the storage value. The ",(0,o.kt)("inlineCode",{parentName:"p"},"SENDER")," instruction push on top of the stack the address of the invoker. The ",(0,o.kt)("inlineCode",{parentName:"p"},"DIP { PUSH bool True }")," pushes a True boolean value on the second position of the stack. Finally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE")," consumes the 3 top elements (the address , the boolean and the set) and produces an updated ",(0,o.kt)("em",{parentName:"p"},"set")," containing the sender address. "),(0,o.kt)("p",null,"This smart contract can be simulated with CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_sender.tz on storage '{}' and input 'Unit'\n")),(0,o.kt)("p",null,"An other useful built-in is the ",(0,o.kt)("inlineCode",{parentName:"p"},"AMOUNT")," instruction which is key when currencies are being exchanged. The ",(0,o.kt)("inlineCode",{parentName:"p"},"AMOUNT")," instruction pushes the amount of mutez of the current transaction on top of the stack."),(0,o.kt)("p",null,"The following smart contract illustrates the ",(0,o.kt)("inlineCode",{parentName:"p"},"AMOUNT")," usage. When invoked it concatenates a given string to the string of the storage only if no money has been transferred with this transaction. In fact, it verifies that the ",(0,o.kt)("em",{parentName:"p"},"amount")," is equal to zero."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"parameter string;\nstorage string;\ncode { AMOUNT;\n       PUSH mutez 0;\n       COMPARE;\n       EQ;\n       IF { UNPAIR; CONCAT } { FAIL };\n       NIL operation ;\n       PAIR }\n\n")),(0,o.kt)("p",null," The ",(0,o.kt)("inlineCode",{parentName:"p"},"AMOUNT")," instruction pushes the amount of mutez of the current transaction on top of the stack. The ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH mutez 0; COMPARE; EQ")," sequence verifies that the amount is equal to zero. If it is the case then the parameter string and the storage string are concatenated (with sequence",(0,o.kt)("inlineCode",{parentName:"p"},"{ UNPAIR; CONCAT }"),") otherwise the transaction stops with a ",(0,o.kt)("inlineCode",{parentName:"p"},"FAIL")," instruction."),(0,o.kt)("p",null,"This contract can be simulated with the CLI command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"tezos-client run script instruction_amount.tz on storage '\"Hello\"' and input '\"World\"' --amount 0\n")),(0,o.kt)("p",null,"Notice that the ",(0,o.kt)("inlineCode",{parentName:"p"},"tezos-client run script")," command provides an optional argument ",(0,o.kt)("inlineCode",{parentName:"p"},"--amount 0")," for specifying the amount of mutez sent with this transaction."),(0,o.kt)("h3",{id:"lambda-functions"},"Lambda functions"),(0,o.kt)("p",null,"The Michelson language supports anonymous functions, also called ",(0,o.kt)("strong",{parentName:"p"},"lambda"),". Lambda functions are strongly typed and when called it executes a sequence of instructions."),(0,o.kt)("p",null,"Lambda functions are useful for factoring code, thus preventing code duplication. "),(0,o.kt)("p",null,"An important limitation is that Lambda functions can't manipulate the stack of the calling contract, but instead have their own stack.\nThough, data can be passed as arguments to the lambda function."),(0,o.kt)("p",null,"Lambda functions can also be defined inside the storage. A smart contract would be able to apply on-demand the stored lambda; and would also be able to change the code of the lambda. BE CAREFUL! In this case, it means the smart contract is not immutable. This kind of design requires a strong administration layer (with multi-signature patterns); and proofs on those smart contracts might become irrelevant."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction defines a lambda function and the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction allows to execute its code."),(0,o.kt)("p",null,"A function can be partially applied (i.e. partially resolved) with the ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction. "),(0,o.kt)("h4",{id:"lambda-definition-with-lambda"},"Lambda definition with ",(0,o.kt)("inlineCode",{parentName:"h4"},"LAMBDA")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction pushes an anonymous function on top of the stack. The function is an element like others being pushed on the stack excepts that only a few instructions may be applied on this kind of element. A lambda can be executed with the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction if lambda arguments have been provided on the stack. A lambda can be partially resolved (i.e. producing a new lambda function) with the ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction requires three arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the type of the function argument"),(0,o.kt)("li",{parentName:"ul"},"the type returned by the function"),(0,o.kt)("li",{parentName:"ul"},"the sequence of instructions associated with the function (code of the function)")),(0,o.kt)("p",null,"Michelson grammar defines the ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"LAMBDA _ _ code / S  =>  code : S\n")),(0,o.kt)("p",null,'Notice that "_" represents any type. So, a ',(0,o.kt)("inlineCode",{parentName:"p"},"lambda")," takes and returns arguments that can be of any type."),(0,o.kt)("p",null,"Here is an example of a smart contract that defines a function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction and executes the function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage int ;\ncode { CAR ;\n       LAMBDA int int { PUSH int 1 ; ADD } ;\n       SWAP ;\n       EXEC ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"lambda")," function is just incrementing a given int."),(0,o.kt)("p",null,"The execution of this smart contract is described in the example section."),(0,o.kt)("h4",{id:"lambda-execution-with-exec"},"Lambda execution with ",(0,o.kt)("inlineCode",{parentName:"h4"},"EXEC")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction executes a function from the stack."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction consumes a function and its related input arguments on top of the stack. The ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction produces the expected function output on the top of the stack."),(0,o.kt)("p",null,"Here is an example of a smart contract that defines a function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction and executes the function with the ",(0,o.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage int ;\ncode { CAR ;\n       LAMBDA int int { PUSH int 1 ; ADD } ;\n       SWAP ;\n       EXEC ;\n       NIL operation ;\n       PAIR }\n")),(0,o.kt)("p",null,"Notice that the code of the ",(0,o.kt)("inlineCode",{parentName:"p"},"LAMBDA")," function just increments a given integer by 1."),(0,o.kt)("p",null,'The execution of this smart contract is described in the "example" section.'),(0,o.kt)("h4",{id:"partially-resolving-functions-with-apply"},"Partially resolving functions with ",(0,o.kt)("inlineCode",{parentName:"h4"},"APPLY")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY 'a")," instruction partially applies a ",(0,o.kt)("em",{parentName:"p"},"tuplified")," function from the stack (i.e. arguments are grouped in pairs or nested pairs). It is parameterized by a type ",(0,o.kt)("inlineCode",{parentName:"p"},"'a"),". Values that are not both push-able and storable (i.e. values of type ",(0,o.kt)("em",{parentName:"p"},"operation"),", ",(0,o.kt)("em",{parentName:"p"},"contract"),", and ",(0,o.kt)("em",{parentName:"p"},"big map"),") cannot be captured by ",(0,o.kt)("em",{parentName:"p"},"APPLY")," (and so cannot appear in argument ",(0,o.kt)("inlineCode",{parentName:"p"},"'a"),")."),(0,o.kt)("p",null,"The instruction produces a new function that is only partially resolved. For example, if a function takes 2 arguments, it is possible to provide one argument and to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction to produce an equivalent partially-resolved function which takes one argument."),(0,o.kt)("p",null,"Michelson grammar defines the ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},":: 'a : lambda (pair 'a 'b) 'c : 'C   ->   lambda 'b 'c : 'C\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"APPLY / a : f : S  => { PUSH 'a a ; PAIR ; f } : S\n")),(0,o.kt)("p",null,"For example, let's consider a ",(0,o.kt)("inlineCode",{parentName:"p"},"lambda")," function (called ",(0,o.kt)("em",{parentName:"p"},"additionAB"),") that takes a pair of ",(0,o.kt)("em",{parentName:"p"},"nat")," and returns a ",(0,o.kt)("em",{parentName:"p"},"nat"),". It computes the addition of two numbers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"LAMBDA (pair nat nat) nat { ADD }\n")),(0,o.kt)("p",null,"Notice that the function is 'tuplified'."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction allows a new ",(0,o.kt)("inlineCode",{parentName:"p"},"lambda")," function to be formed (called ",(0,o.kt)("em",{parentName:"p"},"addition2B"),") which takes a single ",(0,o.kt)("em",{parentName:"p"},"nat")," as argument and returns a ",(0,o.kt)("em",{parentName:"p"},"nat"),". This function would increment a given ",(0,o.kt)("em",{parentName:"p"},"nat")," by two. "),(0,o.kt)("p",null,"The resulting function ",(0,o.kt)("em",{parentName:"p"},"addition2B")," is equivalent to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"LAMBDA nat nat { PUSH nat 2 ; ADD }\n")),(0,o.kt)("h3",{id:"iterative-processing"},"Iterative processing"),(0,o.kt)("p",null,"The Michelson language supports repetitive processing. As seen the previous sections, the collection types (set, list, map) supports the ",(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," instruction allowing to parse each element of the collection and applying a sequence of instruction to each element."),(0,o.kt)("p",null,"The example (",(0,o.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-2--maximum-of-a-list-with-iter-and-cmple"},"#2"),' in the "Examples" section illustrates the ',(0,o.kt)("inlineCode",{parentName:"p"},"ITER")," instruction usage on ",(0,o.kt)("em",{parentName:"p"},"list")," type."),(0,o.kt)("p",null,"There are also two other instructions allowing repetitive processing: the ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT")," instructions.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," instructions have access to the stack and the repetitiveness of the process is controlled by boolean on the stack. It is very similar to ",(0,o.kt)("em",{parentName:"p"},"while")," operators in other languages."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT")," instruction is a bit more complex and allows to handle a repetitive process with an accumulator. An accumulator is an element used for aggregating data during a repetitive process. The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT")," is based on ",(0,o.kt)("em",{parentName:"p"},"union")," type for storing the accumulator and controlling the repetition."),(0,o.kt)("h4",{id:"loop-"},"LOOP {}"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP"),' instruction is a generic loop, i.e. it repeatedly applies a sequence of instructions (called "body") many times until a condition is reached. The condition is tested before each application of the sequence.'),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction consumes a boolean value on top of the stack. If the value is true then the 'body\" sequence is applied; otherwise the repetitive process is stopped. "),(0,o.kt)(s.Z,{mdxType:"NotificationBar"},(0,o.kt)("p",null,'This "body" sequence of instructions must recompute and push the boolean condition on top of the stack in order to make the process repeatable).')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction makes it possible to iterate on a composite structure (list, set, map, big_map) and apply a process to all elements sequentially."),(0,o.kt)("p",null,"The example (",(0,o.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-1--modulo-with-loop-and-if"},"#1"),' in the "Examples" section illustrates the ',(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction usage by implementing a modulo function."),(0,o.kt)("h4",{id:"loop_left-loop-with-accumulator"},"LOOP_LEFT (loop with accumulator)"),(0,o.kt)("p",null,"Like the ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction, ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT {}")," is a generic loop that handles accumulators generally used for aggregating data during a repetitive process. "),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT {}")," takes a sequence of instructions as an argument and requires a ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," (composed of a given data structure and an accumulator) on top of the stack. "),(0,o.kt)("p",null,"If the left part of the ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," is initialized the process is repeated (i.e. the value of the ",(0,o.kt)("em",{parentName:"p"},"union")," defines the left branch ",(0,o.kt)("inlineCode",{parentName:"p"},"LEFT <datatype> <value>"),").\nIf the right part is initialized (i.e. the value of the ",(0,o.kt)("em",{parentName:"p"},"union")," defines the right branch ",(0,o.kt)("inlineCode",{parentName:"p"},"RIGHT <datatype> <value>"),") then the process is stopped and the accumulator is returned."),(0,o.kt)("p",null,"Two examples (",(0,o.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-4--computing-a-sum-with-loop_left"},"#4")," and ",(0,o.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-5--computing-a-factorial-with-loop_left"},"#5"),") in the ",(0,o.kt)("em",{parentName:"p"},"Examples")," section describe in detail the ",(0,o.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT")," instruction usage."),(0,o.kt)("h3",{id:"more-detail-in-the-instructions-section"},'More detail in the "Instructions" section'),(0,o.kt)("p",null,'This "Tutorial" part ends, with hope that you have had a satisfying introduction to the Michelson language.'),(0,o.kt)("p",null,'More detail about macros and syntactic sugar are available int the "Instructions" section.'),(0,o.kt)("p",null,'For more advanced Michelson programmers, there are other concepts such as cryptographic features and annotations that are described in the "Instructions" section. '),(0,o.kt)("p",null,"As the Michelson language is part of the protocol it is destined to change and thus many other features may be supported in the future, bringing new possibilities like anonymity (with sapling techniques) or allowing for the stamping of atomic information (with tickets)."))}m.isMDXComponent=!0},6179:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_example_transfertoken_execution-1e728baa011cb9db29a3da35c5063b08.svg"},1370:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_abs_example-e134936de8f561edb77aa7e5d3ec86df.svg"},3541:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_add_example-938944ba9bd680b6fc511043a9f61fdd.svg"},3026:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_and_example-2fd12cc90ac9f9e196e32ebbde1b449f.svg"},8771:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_car_example-5aab635921f5fc0da71b5dd5ad5b72b9.svg"},1675:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_cdr_example-b3a0b33e8bb879111b621a676e0c1bca.svg"},2990:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_compare_example-e697aa4e8764e371664efa7ac5b87350.svg"},2472:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_cons_example-72004d345be8eef54baf5d4a6ee62904.svg"},7325:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dig_example-0c1f6744d93fa7c896ec6bfc70181417.svg"},1331:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dug_example-a4bcecd1511e67965798974cb42ddf03.svg"},5470:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dup_example-f2a97d8c62fc429aff0dca5370d989aa.svg"},9640:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ediv_example-affff443b53a6bd499435337c1ed0b6a.svg"},2841:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifleft_left_example-4be764b370901ac4c41804b7c62bee2f.svg"},1077:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifleft_right_example-24b5d95ac17997958bdf0411855b54c0.svg"},6702:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifnone_none_example-f162286deb209c962f0b4220843d3f51.svg"},4668:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifnone_some_example-1583eb394f815c74940d8c5a832517d3.svg"},387:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_left-51e4943fe674856964ae1bea7fe26244.svg"},6158:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_map_get-7a19c06895237f9916dcf81a32ba4518.svg"},9765:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mapinsert_example-bf78e54704a2a5bf367f5cbba30d23bf.svg"},6016:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mapremove_example-c398367edc01b4738fcfe4898af9fb64.svg"},803:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mul_example-427e0664e857a85a48e31282eb8daefa.svg"},1658:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_nillist_example-e14ad579e2909d07424acb3297cef796.svg"},9328:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_or_example-8c499ecad23c5af1da00b089eead699f.svg"},3394:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_right-2421961d73e6d0e3f6ed0f1f2c0ce30c.svg"},8410:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_set_insert-266978af556dfd5a0c894c1a4186b61e.svg"},2365:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_slice_example-e6cd513819ba4cc66ee7f3f0687ae904.svg"},1254:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_sub_example-4a0e1da09f0dd54089302c43f8dc4f13.svg"},6319:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_swap_example-f8ab1903def5f30ecaa8a953a0790027.svg"},8665:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_updatesetinsert_example-fb43a4f5d1e08e0d3c9bee5d40e1e89e.svg"},2716:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_updatesetremove_example-4c3a938c8048ccc2eb3839835a6a770d.svg"},926:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_xor_example-1462803c39d1fea62b796fa579ca0587.svg"},4200:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_macro_C[AD]+R_example-406d9ded47e46d42e62de8fc60e22d18.svg"},6305:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_smartcontract_basics-1e6ca476f5a13cceedbda97b25b68ce8.svg"},8154:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_arithmetic-bad7ef02393252f5f961faf0212c839b.svg"},8721:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_compare_example-00193e5f30a5b32f01b2afa717fe6b1f.svg"},9629:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_compare_numbers-30e7765a044ec0016ca6e7386736c376.svg"},5362:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_compare_numbers_dip-ef17a41a4f8eb0e37cfe5590a92d1fb5.svg"},2388:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_dug_dig-f95813b4a910b02c16296457f6a57716.svg"},4633:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_if_false-0735e3057a36329da26b2c19ad47f415.svg"},4834:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_if_true-7cb74164e9706c0d834988a1bc7baf27.svg"},9860:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_pair-7ad6a4f5a698df7d1539a23c368824b4.svg"},9141:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_pair_unpair-b8ac457ee44c1cfc5337c0024fd26287.svg"},1112:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_tutorial_push_drop-425301f6b130aaff162d59abd67a5aa0.svg"}}]);