(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[572],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return c},kt:function(){return f}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(a),f=s,u=m["".concat(l,".").concat(f)]||m[f]||d[f]||r;return a?n.createElement(u,i(i({ref:t},c),{},{components:a})):n.createElement(u,i({ref:t},c))}));function f(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7705:function(e,t,a){"use strict";a.d(t,{Z:function(){return r}});var n=a(7294),s="root_2W3B",r=function(e){var t=e.children;return n.createElement("div",{className:s},t)}},4385:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return o},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var n=a(2122),s=a(9756),r=(a(7294),a(3905)),i=a(7705),o={id:"write-contract-smartpy",title:"Smart contract development with SmartPy",authors:"Maxime Sallerin"},l={unversionedId:"smartpy/write-contract-smartpy",id:"smartpy/write-contract-smartpy",isDocsHomePage:!1,title:"Smart contract development with SmartPy",description:"In this chapter, we will use SmartPy to develop a smart contract based Raffle and cover the most important aspects of the framework. We will use this opportunity to introduce new notions as they appear. For a complete reference of SmartPy, please refer to the Reference Manual.",source:"@site/docs/smartpy/write-contract-smartpy.md",sourceDirName:"smartpy",slug:"/smartpy/write-contract-smartpy",permalink:"/smartpy/write-contract-smartpy",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/smartpy/write-contract-smartpy.md",version:"current",lastUpdatedBy:"Aymeric BETHENCOURT",lastUpdatedAt:1622492989,formattedLastUpdatedAt:"5/31/2021",frontMatter:{id:"write-contract-smartpy",title:"Smart contract development with SmartPy",authors:"Maxime Sallerin"},sidebar:"docs",previous:{title:"Installation",permalink:"/smartpy/installation"},next:{title:"Exam",permalink:"/smartpy/exam"}},p=[{value:"About the raffle contract",id:"about-the-raffle-contract",children:[{value:"Get started",id:"get-started",children:[]},{value:"The <em>open_raffle</em> entrypoint",id:"the-open_raffle-entrypoint",children:[]},{value:"buy_ticket entrypoint",id:"buy_ticket-entrypoint",children:[]},{value:"<em>close_raffle</em> entrypoint",id:"close_raffle-entrypoint",children:[]},{value:"Full code",id:"full-code",children:[]},{value:"Entrypoint implementation",id:"entrypoint-implementation-2",children:[]},{value:"Run and watch the output",id:"run-and-watch-the-output-1",children:[]}]},{value:"Conclusion",id:"conclusion",children:[]},{value:"To go further",id:"to-go-further",children:[]},{value:"References",id:"references",children:[]}],c={toc:p};function d(e){var t=e.components,o=(0,s.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this chapter, we will use ",(0,r.kt)("em",{parentName:"p"},"SmartPy")," to develop a smart contract based Raffle and cover the most important aspects of the framework. We will use this opportunity to introduce new notions as they appear. For a complete reference of ",(0,r.kt)("em",{parentName:"p"},"SmartPy"),", please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html"},"Reference Manual"),"."),(0,r.kt)("h2",{id:"about-the-raffle-contract"},"About the raffle contract"),(0,r.kt)("p",null,"A raffle is a game of chance that distributes a winning prize."),(0,r.kt)("p",null,"The organizer is in charge of defining a jackpot and selling tickets that will either be winners or losers. In the case of our example, we will only have one winning ticket."),(0,r.kt)("p",null,"Fig.3 represents our smart contract."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(8913).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 3: Raffle contract"),(0,r.kt)("p",null,"Three entrypoints allow interaction with the contract:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"open_raffle")," can only be called by the administrator. During this call, he sends the tez amount of the jackpot to the contract, defines a closing date, indicates the number/identity of the winning ticket (in an encrypted way), and declares the raffle open."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"buy_ticket")," allows anyone to buy a ticket for 1 tez and take part in the raffle."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"close_raffle")," can only be called by the administrator. It closes the raffle and sends the jackpot to the winner.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that this is a simplified conception of what a raffle is. Here the jackpot is fixed by the administrator, but it is possible to make a contract where the jackpot depends on the number of sold tickets.")),(0,r.kt)("h3",{id:"get-started"},"Get started"),(0,r.kt)("p",null,"This section illustrates the coding of the smart contract in the ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/ide"},"online editor")," proposed by ",(0,r.kt)("em",{parentName:"p"},"SmartPy"),". You can however also use your favourite IDE instead, as described previously."),(0,r.kt)("h4",{id:"create-your-contract"},"Create your contract"),(0,r.kt)("p",null,"To start, create a new contract in the online editor and name it ",(0,r.kt)("em",{parentName:"p"},"Raffle Contract"),"."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(5861).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 4: Online Editor Create Contract"),(0,r.kt)("h4",{id:"template"},"Template"),(0,r.kt)("p",null,"Copy/paste the template below to get started:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Raffle Contract - Example for illustrative purposes only.\n\nimport smartpy as sp\n\nclass Raffle(sp.Contract):\n    def __init__(self):\n        self.init()\n\n    @sp.entry_point\n    def open_raffle(self):\n        pass\n\nif "templates" not in __name__:\n    @sp.add_test(name = "Raffle")\n    def test():\n        r = Raffle()\n        scenario = sp.test_scenario()\n        scenario.h1("Raffle")\n        scenario += r\n\n    sp.add_compilation_target("Raffle_comp", Raffle())\n')),(0,r.kt)("h4",{id:"a-few-concepts-first"},"A few concepts first"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A ",(0,r.kt)("em",{parentName:"strong"},"SmartPy")," contract")," consists of a storage with one or several entry points. It is a class definition that inherits from the ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.Contract"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"A class")," is a code template for creating objects. Objects have member variables and have a behaviour associated with them. In python a class is created by the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"class"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("strong",{parentName:"p"},"Inheritance")," allows us to define a class that can inherit all the methods and properties of another class.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"The ",(0,r.kt)("em",{parentName:"strong"},"SmartPy")," storage")," is defined into the constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"__init__")," which makes a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"self.init()")," that initializes the fields and sets up the storage.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Entrypoints")," are a type of contract class that can be called on from the outside. Entrypoints need to be marked with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@sp.entry_point")," decorator."),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Decorators")," are functions that modify the functionality of other functions. They are introduced by ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," and are placed before the function.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Test Scenarios")," are good tools to make sure our smart contracts are working correctly."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A new test is a method marked with the ",(0,r.kt)("inlineCode",{parentName:"li"},"sp.add_test")," decorator."),(0,r.kt)("li",{parentName:"ul"},"A new scenario is instantiated by ",(0,r.kt)("inlineCode",{parentName:"li"},"sp.test_scenario"),"."),(0,r.kt)("li",{parentName:"ul"},"Scenarios describe a sequence of actions: originating contracts, computing expressions or calling entry points, etc."),(0,r.kt)("li",{parentName:"ul"},"In the online editor of SmartPy.io, the scenario is computed and then displayed as an HTML document on the output panel.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that there is a difference between ",(0,r.kt)("strong",{parentName:"p"},"Test Case")," which is a set of actions executed to verify particular features or functionality and ",(0,r.kt)("strong",{parentName:"p"},"Test Scenario")," which includes an end to end functionality to be tested.")),(0,r.kt)("p",null,"We will explain in more details the use of all these concepts in the next sections."),(0,r.kt)("p",null,"Our code doesn't do much for now, but it can already be compiled by pressing the ",(0,r.kt)("em",{parentName:"p"},"run")," button. If there is no error, you should be able to visualize the generated Michelson code in the ",(0,r.kt)("em",{parentName:"p"},"Deploy Michelson Contract")," tab."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"parameter (unit %open_raffle);\nstorage   unit;\ncode\n  {\n    CDR;        # @storage\n    # == open_raffle == # @storage\n    NIL operation; # list operation : @storage\n    PAIR;       # pair (list operation) @storage\n  };\n")),(0,r.kt)("h3",{id:"the-open_raffle-entrypoint"},"The ",(0,r.kt)("em",{parentName:"h3"},"open_raffle")," entrypoint"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"open_raffle")," is the entrypoint that only the administrator can call. If the invocation is successful, then the raffle will open, and the smart contract's storage will be updated with the chosen amount and the hash of the winning ticket number."),(0,r.kt)("h4",{id:"link-to-referential-manual"},"Link to referential manual"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_contracts"},"Init")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_entry_points"},"Entrypoints")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_checking_a_condition"},"Checking a Condition")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_timestamps"},"Timestamps")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_tests_and_scenarios"},"Test and Scenario")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_typing"},"Typing"))),(0,r.kt)("h4",{id:"code"},"Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Raffle Contract - Example for illustrative purposes only.\n\nimport smartpy as sp\n\n\nclass Raffle(sp.Contract):\n    def __init__(self, address):\n        self.init(admin=address,\n                  close_date=sp.timestamp(0),\n                  jackpot=sp.tez(0),\n                  raffle_is_open=False,\n                  hash_winning_ticket=sp.bytes(\'0x\')\n                  )\n\n    @sp.entry_point\n    def open_raffle(self, jackpot_amount, close_date, hash_winning_ticket):\n        sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n        sp.verify(~ self.data.raffle_is_open, message="A raffle is already open.")\n        sp.verify(sp.amount >= jackpot_amount, message="The administrator does not own enough tz.")\n        today = sp.now\n        in_7_day = today.add_days(7)\n        sp.verify(close_date > in_7_day, message="The raffle must remain open for at least 7 days.")\n        self.data.close_date = close_date\n        self.data.jackpot = jackpot_amount\n        self.data.hash_winning_ticket = hash_winning_ticket\n        self.data.raffle_is_open = True\n\n\nif "templates" not in __name__:\n    alice = sp.test_account("Alice")\n    admin = sp.test_account("Administrator")\n\n\n    @sp.add_test(name="Raffle")\n    def test():\n        r = Raffle(admin.address)\n        scenario = sp.test_scenario()\n        scenario.h1("Raffle")\n        scenario += r\n\n        scenario.h2("Test open_raffle entrypoint")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        jackpot_amount = sp.tez(10)\n        number_winning_ticket = sp.nat(345)\n        bytes_winning_ticket = sp.pack(number_winning_ticket)\n        hash_winning_ticket = sp.sha256(bytes_winning_ticket)\n\n        scenario.h3("The unauthorized user Alice unsuccessfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=alice.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle with wrong close_date")\n        close_date = sp.timestamp_from_utc_now().add_days(4)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle by sending not enough tez to the contract")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(5), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin successfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now())\n        scenario.verify(r.data.close_date == close_date)\n        scenario.verify(r.data.jackpot == jackpot_amount)\n        scenario.verify(r.data.raffle_is_open)\n\n        scenario.h3("Admin unsuccessfully call open_raffle because a raffle is already open")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n\n    sp.add_compilation_target("Raffle_comp", Raffle(admin.address))\n')),(0,r.kt)("h4",{id:"storage-definition"},"Storage definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(self, address):\n    self.init(admin=address,\n              close_date=sp.timestamp(0),\n              jackpot=sp.tez(0),\n              raffle_is_open=False,\n              hash_winning_ticket=sp.bytes('0x')\n              )\n")),(0,r.kt)("p",null,"The definition of the storage is done in the constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"__init__")," and the different fields of the storage are stated as follows:",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"self.init( field1=value1, field2=value2, field3=value3)")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"field1"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"field2"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"field3")," are the names of the variables and are accessible via ",(0,r.kt)("inlineCode",{parentName:"li"},"self.data")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"self.data.field1"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value1"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"value2"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"value3")," are initial values or variables passed as constructors like ",(0,r.kt)("inlineCode",{parentName:"li"},"__init__(self, value1)")," as we did above for the ",(0,r.kt)("inlineCode",{parentName:"li"},"admin=address")," field. (This can be useful if you want to initialize the storage with some specific values)")),(0,r.kt)(i.Z,{mdxType:"NotificationBar"},(0,r.kt)("p",null,(0,r.kt)("p",null,"SmartPy types are all of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.T<TypeName>"),". Check out ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html#_primitive_data_types_overview"},"Typing"),".\nFor examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sp.TUnit\nsp.TBool\nsp.TInt\nsp.TNat\nsp.TString\n...\n")),(0,r.kt)("p",null,"Types are usually automatically inferred and not explicitly needed. However, it is still possible to add constraints on types, e.g. check out ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html#_setting_a_type_constraint_in_smartpy"},"Setting a type of constraint in SmartPy"),"."))),(0,r.kt)("p",null,"For the storage of the raffle contract, we have defined five fields for the moment:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"admin")," is the only authorized ",(0,r.kt)("inlineCode",{parentName:"li"},"address")," to call the two entrypoints ",(0,r.kt)("em",{parentName:"li"},"open_raffle")," and ",(0,r.kt)("em",{parentName:"li"},"close_raffle"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"close_date")," is a ",(0,r.kt)("inlineCode",{parentName:"li"},"timestamp")," to indicate the closing date of the raffle. The raffle must remain open for at least seven days."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"jackpot")," is the amount in ",(0,r.kt)("inlineCode",{parentName:"li"},"tez")," that will be distributed to the winner."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"raffle_is_open")," is a ",(0,r.kt)("inlineCode",{parentName:"li"},"boolean")," to indicate if the raffle is open or not."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"hash_winning_ticket")," is the hash of the winning ticket indicated by the admin.")),(0,r.kt)(i.Z,{mdxType:"NotificationBar"},(0,r.kt)("p",null,"It's not possible to generate a truly random number from a smart contract, so an easy alternative is to use a hash. This example is for educational purposes and is not intended to be deployed on the real Tezos network.")),(0,r.kt)("h4",{id:"entrypoint-implementation"},"Entrypoint implementation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@sp.entry_point\ndef open_raffle(self, jackpot_amount, close_date, hash_winning_ticket):\n    sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n    sp.verify(~ self.data.raffle_is_open, message="A raffle is already open.")\n    sp.verify(sp.amount >= jackpot_amount, message="The administrator does not own enough tz.")\n    today = sp.now\n    in_7_day = today.add_days(7)\n    sp.verify(close_date > in_7_day, message="The raffle must remain open for at least 7 days.")\n    self.data.close_date = close_date\n    self.data.jackpot = jackpot_amount\n    self.data.hash_winning_ticket = hash_winning_ticket\n    self.data.raffle_is_open = True\n')),(0,r.kt)("p",null,"An entrypoint is a method of the contract class and is always preceded by the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"@sp.entry_point"),". It can take on several parameters. In our case, the first entrypoint we use, is called ",(0,r.kt)("inlineCode",{parentName:"p"},"open_raffle")," and does the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"With ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.verify()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.verify_equal()")," we check that a statement is true or if it return an error message (more info at ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html#_checking_a_condition"},"Checking a Condition"),"). Here we check four statements :"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The address that calls the entrypoint must be the administrator one indicated in the storage. We compare here ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.source")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"self.data.admin"),"."),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"sp.sender")," is the address that calls the current entrypoint.",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"sp.source")," is the address that initiates the current transaction. It may or may not be equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.sender"),", but in our case, it is."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"No raffle must be open. For this, we use the boolean ",(0,r.kt)("inlineCode",{parentName:"p"},"raffle_is_open")," defined in the storage."),(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"~")," is the symbol used for logical negation."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The amount ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.amount")," sent to the contract by the administrator during the transaction must be at least greater than the value specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"jackpot_amount")," argument.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The closing date ",(0,r.kt)("inlineCode",{parentName:"p"},"close_date")," passed as a parameter must be at least seven days in the future (more info on ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html#_timestamps"},"Timestamps"),").")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Once all the conditions are passed we update the storage as follows:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"self.data.close_date = close_date\nself.data.jackpot = jackpot_amount\nself.data.hash_winning_ticket = hash_winning_ticket\nself.data.raffle_is_open = True\n")),(0,r.kt)("h4",{id:"test-scenario"},"Test Scenario"),(0,r.kt)("p",null,"The purpose of the test scenario is to ensure that the smart contract functions properly by triggering the conditions and checking the changes made to the storage."),(0,r.kt)("p",null,"On ",(0,r.kt)("em",{parentName:"p"},"SmartPy"),", a test is a method of the contract class, preceded by ",(0,r.kt)("inlineCode",{parentName:"p"},"@sp.add_test"),"."),(0,r.kt)("p",null,"Inside this method, you need to instantiate your contract class and your scenarios, to which you will add the contract instance and all the calls related that you want to test. For instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@sp.add_test(name="Raffle")\ndef test():\n    r = Raffle(admin.address)\n    scenario = sp.test_scenario()\n    scenario.h1("Raffle")\n    scenario += r\n')),(0,r.kt)("p",null,"Note that you can also organize your scenarios by adding titles with ",(0,r.kt)("inlineCode",{parentName:"p"},'scenario.h1("My title")'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'scenario.h2("My subtitle")'),", etc."),(0,r.kt)("p",null,"An interesting capacity is to define test accounts for our scenarios:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'alice = sp.test_account("Alice")\nadmin = sp.test_account("Administrator")\n')),(0,r.kt)("p",null,"Test accounts can be defined through calling ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.test_account(seed)"),", where ",(0,r.kt)("em",{parentName:"p"},"seed")," is a string.\nA test account contains a few fields: ",(0,r.kt)("inlineCode",{parentName:"p"},"account.address"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"account.public_key_hash"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"account.public_key"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"account.secret_key"),"."),(0,r.kt)("p",null,"You can then simulate the calls to the entrypoints by specifying the different arguments as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'scenario.h3("The unauthorized user Alice unsuccessfully call open_raffle")\nscenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                          hash_winning_ticket=hash_winning_ticket) \\\n    .run(source=alice.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n         valid=False)\n')),(0,r.kt)("p",null,"The run method accepts optional parameters that can help to setup a relevant context for the entrypoint call. You can specify the ",(0,r.kt)("inlineCode",{parentName:"p"},"source")," of the transaction, the ",(0,r.kt)("inlineCode",{parentName:"p"},"amount")," of tez sent, the transaction date using ",(0,r.kt)("inlineCode",{parentName:"p"},"now")," etc."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that the option ",(0,r.kt)("inlineCode",{parentName:"p"},"valid=False")," allows you to indicate that the transaction is expected to fail here because Alice is not the administrator.")),(0,r.kt)("p",null,"The result is displayed in an HTML document in the output panel of the online editor."),(0,r.kt)("h4",{id:"run-and-watch-the-output"},"Run and watch the output"),(0,r.kt)("p",null,"Let's run our code:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(4230).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 4: Online Editor Contract Summary"),(0,r.kt)("p",null,"You can see a summary of our smart contract with the following information:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Address of the contract"),(0,r.kt)("li",{parentName:"ul"},"Balance in tez"),(0,r.kt)("li",{parentName:"ul"},"Storage"),(0,r.kt)("li",{parentName:"ul"},"Entry points")),(0,r.kt)("p",null,"By clicking on the ",(0,r.kt)("em",{parentName:"p"},"Types")," tab, we have access to the types of the storage elements and the parameters of the entrypoints."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(9547).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 5: Online Editor Types"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"As with Python, most of the time, it is not necessary to specify the type of an object in ",(0,r.kt)("em",{parentName:"p"},"SmartPy"),".",(0,r.kt)("br",{parentName:"p"}),"\n","But because the target language of SmartPy, Michelson, requires types.",(0,r.kt)("br",{parentName:"p"}),"\n","Each ",(0,r.kt)("em",{parentName:"p"},"SmartPy")," expression, however, needs a type. This is why ",(0,r.kt)("em",{parentName:"p"},"SmartPy")," uses type inference to determine the type of each expression.",(0,r.kt)("br",{parentName:"p"}),"\n","See doc ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html#_typing"},"Typing"),".")),(0,r.kt)("p",null,"By clicking on the ",(0,r.kt)("em",{parentName:"p"},"Deploy Michelson Contract")," tab, we have access to the codes compiled in Michelson for the storage (",(0,r.kt)("em",{parentName:"p"},"Storage")," tab) and the smart contract (",(0,r.kt)("em",{parentName:"p"},"Code")," tab)."),(0,r.kt)("p",null,"The michelson code of our smart contract is for now, the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"parameter (pair %open_raffle (timestamp %close_date) (pair (bytes %hash_winning_ticket) (mutez %jackpot_amount)));\nstorage   (pair (pair (address %admin) (timestamp %close_date)) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))));\ncode\n  {\n    UNPAIR;     # @parameter : @storage\n    SWAP;       # @storage : @parameter\n    # == open_raffle ==\n    # sp.verify(sp.pack(sp.set_type_expr(sp.source, sp.TAddress)) == sp.pack(sp.set_type_expr(self.data.admin, sp.TAddress)), message = 'Administrator not recognized.') # @storage : @parameter\n    DUP;        # @storage : @storage : @parameter\n    DUG 2;      # @storage : @parameter : @storage\n    CAR;        # pair (address %admin) (timestamp %close_date) : @parameter : @storage\n    CAR;        # address : @parameter : @storage\n    PACK;       # bytes : @parameter : @storage\n    SOURCE;     # @source : bytes : @parameter : @storage\n    PACK;       # bytes : bytes : @parameter : @storage\n    COMPARE;    # int : @parameter : @storage\n    EQ;         # bool : @parameter : @storage\n    IF\n      {}\n      {\n        PUSH string \"Administrator not recognized.\"; # string : @parameter : @storage\n        FAILWITH;   # FAILED\n      }; # @parameter : @storage\n    SWAP;       # @storage : @parameter\n    # sp.verify(~ self.data.raffle_is_open, message = 'A raffle is already open.') # @storage : @parameter\n    DUP;        # @storage : @storage : @parameter\n    DUG 2;      # @storage : @parameter : @storage\n    GET 6;      # bool : @parameter : @storage\n    IF\n      {\n        PUSH string \"A raffle is already open.\"; # string : @parameter : @storage\n        FAILWITH;   # FAILED\n      }\n      {}; # @parameter : @storage\n    # sp.verify(sp.amount >= params.jackpot_amount, message = 'The administrator does not own enough tz.') # @parameter : @storage\n    DUP;        # @parameter : @parameter : @storage\n    GET 4;      # mutez : @parameter : @storage\n    AMOUNT;     # @amount : mutez : @parameter : @storage\n    COMPARE;    # int : @parameter : @storage\n    GE;         # bool : @parameter : @storage\n    IF\n      {}\n      {\n        PUSH string \"The administrator does not own enough tz.\"; # string : @parameter : @storage\n        FAILWITH;   # FAILED\n      }; # @parameter : @storage\n    # sp.verify(params.close_date > sp.add_seconds(sp.now, 604800), message = 'The raffle must remain open for at least 7 days.') # @parameter : @storage\n    NOW;        # @now : @parameter : @storage\n    PUSH int 604800; # int : @now : @parameter : @storage\n    ADD;        # timestamp : @parameter : @storage\n    SWAP;       # @parameter : timestamp : @storage\n    DUP;        # @parameter : @parameter : timestamp : @storage\n    DUG 2;      # @parameter : timestamp : @parameter : @storage\n    CAR;        # timestamp : timestamp : @parameter : @storage\n    COMPARE;    # int : @parameter : @storage\n    GT;         # bool : @parameter : @storage\n    IF\n      {}\n      {\n        PUSH string \"The raffle must remain open for at least 7 days.\"; # string : @parameter : @storage\n        FAILWITH;   # FAILED\n      }; # @parameter : @storage\n    SWAP;       # @storage : @parameter\n    # self.data.close_date = params.close_date # @storage : @parameter\n    UNPAIR;     # pair (address %admin) (timestamp %close_date) : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    CAR;        # address : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    DUP 3;      # @parameter : address : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    CAR;        # timestamp : address : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    SWAP;       # address : timestamp : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    PAIR;       # pair address timestamp : pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)) : @parameter\n    PAIR;       # pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))) : @parameter\n    SWAP;       # @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    # self.data.jackpot = params.jackpot_amount # @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    DUP;        # @parameter : @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    DUG 2;      # @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))) : @parameter\n    GET 4;      # mutez : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))) : @parameter\n    UPDATE 5;   # pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))) : @parameter\n    SWAP;       # @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    # self.data.hash_winning_ticket = params.hash_winning_ticket # @parameter : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    GET 3;      # bytes : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    UPDATE 3;   # pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    # self.data.raffle_is_open = True # pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    PUSH bool True; # bool : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    UPDATE 6;   # pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    NIL operation; # list operation : pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open)))\n    PAIR;       # pair (list operation) (pair (pair address timestamp) (pair (bytes %hash_winning_ticket) (pair (mutez %jackpot) (bool %raffle_is_open))))\n  };\n")),(0,r.kt)("p",null,"By scrolling down a little, we have access to the results of the test scenario, with within each step a summary of the contract."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(7863).Z})),(0,r.kt)("small",{className:"figure"},"FIGURE 4: Online Editor Scenario Output"),(0,r.kt)("h3",{id:"buy_ticket-entrypoint"},"buy_ticket entrypoint"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"buy_ticket")," is an entrypoint that can be called on by everyone who wants to participate in the raffle.\nIf the invocation is successful, the address of the sender will be added to the storage, and the player will be eligible to win the jackpot"),(0,r.kt)("h4",{id:"link-to-referential-manual-1"},"Link to referential manual"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_sets"},"Sets")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_maps_and_big_maps"},"Maps"))),(0,r.kt)("h4",{id:"code-1"},"Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Raffle Contract - Example for illustrative purposes only.\n\nimport smartpy as sp\n\n\nclass Raffle(sp.Contract):\n    def __init__(self, address):\n        self.init(admin=address,\n                  close_date=sp.timestamp(0),\n                  jackpot=sp.tez(0),\n                  raffle_is_open=False,\n                  players=sp.set(),\n                  sold_tickets=sp.map(),\n                  hash_winning_ticket=sp.bytes(\'0x\')\n                  )\n\n    @sp.entry_point\n    def open_raffle(self, jackpot_amount, close_date, hash_winning_ticket):\n        sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n        sp.verify(~ self.data.raffle_is_open, message="A raffle is already open.")\n        sp.verify(sp.amount >= jackpot_amount, message="The administrator does not own enough tz.")\n        today = sp.now\n        in_7_day = today.add_days(7)\n        sp.verify(close_date > in_7_day, message="The raffle must remain open for at least 7 days.")\n        self.data.close_date = close_date\n        self.data.jackpot = jackpot_amount\n        self.data.hash_winning_ticket = hash_winning_ticket\n        self.data.raffle_is_open = True\n\n    @sp.entry_point\n    def buy_ticket(self):\n        ticket_price = sp.tez(1)\n        current_player = sp.sender\n        sp.verify(self.data.raffle_is_open, message="The raffle is closed.")\n        sp.verify(sp.amount == ticket_price,\n                  message="The sender did not send the right tez amount (Ticket price = 1tz).")\n        sp.verify(~ self.data.players.contains(current_player), message="Each player can participate only once.")\n        self.data.players.add(current_player)\n        ticket_id = abs(sp.len(self.data.players) - 1)\n        self.data.sold_tickets[ticket_id] = current_player\n\n\nif "templates" not in __name__:\n    alice = sp.test_account("Alice")\n    jack = sp.test_account("Jack")\n    admin = sp.test_account("Administrator")\n\n\n    @sp.add_test(name="Raffle")\n    def test():\n        r = Raffle(admin.address)\n        scenario = sp.test_scenario()\n        scenario.h1("Raffle")\n        scenario += r\n\n        scenario.h2("Test open_raffle entrypoint")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        jackpot_amount = sp.tez(10)\n        number_winning_ticket = sp.nat(345)\n        bytes_winning_ticket = sp.pack(number_winning_ticket)\n        hash_winning_ticket = sp.sha256(bytes_winning_ticket)\n\n        scenario.h3("The unauthorized user Alice unsuccessfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=alice.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle with wrong close_date")\n        close_date = sp.timestamp_from_utc_now().add_days(4)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle by sending not enough tez to the contract")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(5), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin successfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now())\n        scenario.verify(r.data.close_date == close_date)\n        scenario.verify(r.data.jackpot == jackpot_amount)\n        scenario.verify(r.data.raffle_is_open)\n\n        scenario.h3("Admin unsuccessfully call open_raffle because a raffle is already open")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h2("Test buy_ticket entrypoint (at this point a raffle is open)")\n\n        scenario.h3("Alice unsuccessfully call buy_ticket by sending a wrong amount of tez")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(3), valid=False)\n\n        scenario.h3("Alice successfully call buy_ticket")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(1))\n        alice_ticket_id = sp.nat(0)\n        scenario.verify(r.data.players.contains(alice.address))\n        scenario.verify_equal(r.data.sold_tickets[alice_ticket_id], alice.address)\n\n        scenario.h3("Alice unsuccessfully call buy_ticket because she has already buy one")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(1), valid=False)\n\n        scenario.h3("Jack successfully call buy_ticket")\n        scenario += r.buy_ticket().run(sender=jack.address, amount=sp.tez(1))\n        jack_ticket_id = sp.nat(1)\n        scenario.verify(r.data.players.contains(jack.address))\n        scenario.verify(r.data.players.contains(alice.address))\n        scenario.verify_equal(r.data.sold_tickets[alice_ticket_id], alice.address)\n        scenario.verify_equal(r.data.sold_tickets[jack_ticket_id], jack.address)\n\n\n    sp.add_compilation_target("Raffle_comp", Raffle(admin.address))\n')),(0,r.kt)("h4",{id:"storage-definition-1"},"Storage definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(self, address):\n    self.init(admin=address,\n              close_date=sp.timestamp(0),\n              jackpot=sp.tez(0),\n              raffle_is_open=False,\n              players=sp.set(),\n              sold_tickets=sp.map(),\n              hash_winning_ticket=sp.bytes('0x')\n              )\n")),(0,r.kt)("p",null,"With the addition of this entrypoint we have defined two new fields in the storage:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"players"),", is a ",(0,r.kt)("inlineCode",{parentName:"li"},"set")," that receives the addresses of each new player who bought a raffle ticket."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"sold_tickets"),", is a ",(0,r.kt)("inlineCode",{parentName:"li"},"map")," that associates each player's address with a ticket number.")),(0,r.kt)("h4",{id:"entrypoint-implementation-1"},"Entrypoint implementation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@sp.entry_point\ndef buy_ticket(self):\n    ticket_price = sp.tez(1)\n    current_player = sp.sender\n    sp.verify(self.data.raffle_is_open, message="The raffle is closed.")\n    sp.verify(sp.amount == ticket_price,\n              message="The sender did not send the right tez amount (Ticket price = 1tz).")\n    sp.verify(~ self.data.players.contains(current_player), message="Each player can participate only once.")\n    self.data.players.add(current_player)\n    ticket_id = abs(sp.len(self.data.players) - 1)\n    self.data.sold_tickets[ticket_id] = current_player\n')),(0,r.kt)("p",null,"Three assertions are tested for this entrypoint to work:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The raffle must be open."),(0,r.kt)("li",{parentName:"ol"},"The amount of tez sent to the contract during the transaction must be equal to the ticket price (",(0,r.kt)("inlineCode",{parentName:"li"},"1tez"),")."),(0,r.kt)("li",{parentName:"ol"},"Each player is allowed to buy only one ticket.")),(0,r.kt)("p",null,"If the conditions are met, then the storage is updated:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The address of the player is added to the set ",(0,r.kt)("inlineCode",{parentName:"li"},"self.data.players"),"."),(0,r.kt)("li",{parentName:"ul"},"The ticket identification (id) is associated with the player's address in the map ",(0,r.kt)("inlineCode",{parentName:"li"},"self.data.sold_tickets"),".",(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"In ",(0,r.kt)("inlineCode",{parentName:"p"},"ticket_id = abs(sp.len(self.data.players) - 1)"),", the ticket id is incremented for each new participant. The ",(0,r.kt)("inlineCode",{parentName:"p"},"abs()")," function, which designates the absolute value, is used to ensure that the ",(0,r.kt)("inlineCode",{parentName:"p"},"ticket_id")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.TNat"),".")))),(0,r.kt)("h3",{id:"close_raffle-entrypoint"},(0,r.kt)("em",{parentName:"h3"},"close_raffle")," entrypoint"),(0,r.kt)("p",null,"Only the administrator can call on the entrypoint ",(0,r.kt)("inlineCode",{parentName:"p"},"close_raffle"),". If the invocation is successful, the raffle is closed, the jackpot amount is sent to the winner, and the storage is reset to a default value."),(0,r.kt)("h4",{id:"link-to-referential-manual-2"},"Link to referential manual"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://smartpy.io/reference.html#_bytes"},"Bytes"))),(0,r.kt)("h3",{id:"full-code"},"Full code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Raffle Contract - Example for illustrative purposes only.\n\nimport smartpy as sp\n\n\nclass Raffle(sp.Contract):\n    def __init__(self, address):\n        self.init(admin=address,\n                  close_date=sp.timestamp(0),\n                  jackpot=sp.tez(0),\n                  raffle_is_open=False,\n                  players=sp.set(),\n                  sold_tickets=sp.map(),\n                  hash_winning_ticket=sp.bytes(\'0x\')\n                  )\n\n    @sp.entry_point\n    def open_raffle(self, jackpot_amount, close_date, hash_winning_ticket):\n        sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n        sp.verify(~ self.data.raffle_is_open, message="A raffle is already open.")\n        sp.verify(sp.amount >= jackpot_amount, message="The administrator does not own enough tz.")\n        today = sp.now\n        in_7_day = today.add_days(7)\n        sp.verify(close_date > in_7_day, message="The raffle must remain open for at least 7 days.")\n        self.data.close_date = close_date\n        self.data.jackpot = jackpot_amount\n        self.data.hash_winning_ticket = hash_winning_ticket\n        self.data.raffle_is_open = True\n\n    @sp.entry_point\n    def buy_ticket(self):\n        ticket_price = sp.tez(1)\n        current_player = sp.sender\n        sp.verify(self.data.raffle_is_open, message="The raffle is closed.")\n        sp.verify(sp.amount == ticket_price,\n                  message="The sender did not send the right tez amount (Ticket price = 1tz).")\n        sp.verify(~ self.data.players.contains(current_player), message="Each player can participate only once.")\n        self.data.players.add(current_player)\n        ticket_id = abs(sp.len(self.data.players) - 1)\n        self.data.sold_tickets[ticket_id] = current_player\n\n    @sp.entry_point\n    def close_raffle(self, selected_ticket):\n        sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n        sp.verify(self.data.raffle_is_open, message="The raffle is closed.")\n        sp.verify(sp.now >= self.data.close_date,\n                  message="The raffle must remain open for at least 7 days.")\n        bytes_selected_ticket = sp.pack(selected_ticket)\n        hash_selected_ticket = sp.sha256(bytes_selected_ticket)\n        sp.verify_equal(hash_selected_ticket, self.data.hash_winning_ticket,\n                        message="The hash does not match the hash of the winning ticket")\n        number_of_players = sp.len(self.data.players)\n        selected_ticket_id = selected_ticket % number_of_players\n        winner = self.data.sold_tickets[selected_ticket_id]\n        sp.send(winner, self.data.jackpot, message="winner contract not found.")\n        self.data.jackpot = sp.tez(0)\n        self.data.close_date = sp.timestamp(0)\n        self.data.players = sp.set()\n        self.data.sold_tickets = sp.map()\n        self.data.raffle_is_open = False\n\n\nif "templates" not in __name__:\n    alice = sp.test_account("Alice")\n    jack = sp.test_account("Jack")\n    admin = sp.test_account("Administrator")\n\n\n    @sp.add_test(name="Raffle")\n    def test():\n        r = Raffle(admin.address)\n        scenario = sp.test_scenario()\n        scenario.h1("Raffle")\n        scenario += r\n\n        scenario.h2("Test open_raffle entrypoint")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        jackpot_amount = sp.tez(10)\n        number_winning_ticket = sp.nat(345)\n        bytes_winning_ticket = sp.pack(number_winning_ticket)\n        hash_winning_ticket = sp.sha256(bytes_winning_ticket)\n\n        scenario.h3("The unauthorized user Alice unsuccessfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=alice.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle with wrong close_date")\n        close_date = sp.timestamp_from_utc_now().add_days(4)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin unsuccessfully call open_raffle by sending not enough tez to the contract")\n        close_date = sp.timestamp_from_utc_now().add_days(8)\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(5), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h3("Admin successfully call open_raffle")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now())\n        scenario.verify(r.data.close_date == close_date)\n        scenario.verify(r.data.jackpot == jackpot_amount)\n        scenario.verify(r.data.raffle_is_open)\n\n        scenario.h3("Admin unsuccessfully call open_raffle because a raffle is already open")\n        scenario += r.open_raffle(close_date=close_date, jackpot_amount=jackpot_amount,\n                                  hash_winning_ticket=hash_winning_ticket) \\\n            .run(source=admin.address, amount=sp.tez(10), now=sp.timestamp_from_utc_now(),\n                 valid=False)\n\n        scenario.h2("Test buy_ticket entrypoint (at this point a raffle is open)")\n\n        scenario.h3("Alice unsuccessfully call buy_ticket by sending a wrong amount of tez")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(3), valid=False)\n\n        scenario.h3("Alice successfully call buy_ticket")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(1))\n        alice_ticket_id = sp.nat(0)\n        scenario.verify(r.data.players.contains(alice.address))\n        scenario.verify_equal(r.data.sold_tickets[alice_ticket_id], alice.address)\n\n        scenario.h3("Alice unsuccessfully call buy_ticket because she has already buy one")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(1), valid=False)\n\n        scenario.h3("Jack successfully call buy_ticket")\n        scenario += r.buy_ticket().run(sender=jack.address, amount=sp.tez(1))\n        jack_ticket_id = sp.nat(1)\n        scenario.verify(r.data.players.contains(jack.address))\n        scenario.verify(r.data.players.contains(alice.address))\n        scenario.verify_equal(r.data.sold_tickets[alice_ticket_id], alice.address)\n        scenario.verify_equal(r.data.sold_tickets[jack_ticket_id], jack.address)\n\n        scenario.h2("Test close_raffle entrypoint (at this point a raffle is open and two players participated)")\n        selected_ticket = sp.nat(345)\n\n        scenario.h3("The unauthorized user Alice unsuccessfully call close_raffle")\n        scenario += r.close_raffle(selected_ticket).run(sender=alice.address, valid=False)\n\n        scenario.h3("Admin unsuccessfully call close_raffle because it was before the close_date")\n        scenario += r.close_raffle(selected_ticket)\\\n            .run(sender=admin.address, now=sp.timestamp_from_utc_now(), valid=False)\n\n        scenario.h3("Admin unsuccessfully call close_raffle because the hash of the selected ticket does not match with the winning one")\n        selected_ticket = sp.nat(1234)\n        scenario += r.close_raffle(selected_ticket)\\\n            .run(sender=admin.address, now=r.data.close_date, valid=False)\n\n        scenario.h3("Admin successfully call close_raffle")\n        selected_ticket = sp.nat(345)\n        scenario += r.close_raffle(selected_ticket).run(sender=admin.address, now=r.data.close_date)\n        scenario.verify_equal(r.data.jackpot, sp.tez(0))\n        scenario.verify_equal(r.data.close_date, sp.timestamp(0))\n        scenario.verify_equal(r.data.players, sp.set())\n        scenario.verify_equal(r.data.sold_tickets, sp.map())\n        scenario.verify(~ r.data.raffle_is_open)\n\n        scenario.h3("Alice unsuccessfully call buy_ticket because the raffle is closed")\n        scenario += r.buy_ticket().run(sender=alice.address, amount=sp.tez(1), valid=False)\n\n\n    sp.add_compilation_target("Raffle_comp", Raffle(admin.address))\n')),(0,r.kt)("h3",{id:"entrypoint-implementation-2"},"Entrypoint implementation"),(0,r.kt)("p",null,"The storage definition has not been modified by the addition of this entrypoint, so we can directly explain its implementation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'@sp.entry_point\ndef close_raffle(self, selected_ticket):\n    sp.verify_equal(sp.source, self.data.admin, message="Administrator not recognized.")\n    sp.verify(self.data.raffle_is_open, message="The raffle is closed.")\n    sp.verify(sp.now >= self.data.close_date,\n              message="The raffle must remain open for at least 7 days.")\n    bytes_selected_ticket = sp.pack(selected_ticket)\n    hash_selected_ticket = sp.sha256(bytes_selected_ticket)\n    sp.verify_equal(hash_selected_ticket, self.data.hash_winning_ticket,\n                    message="The hash does not match the hash of the winning ticket")\n    number_of_players = sp.len(self.data.players)\n    selected_ticket_id = selected_ticket % number_of_players\n    winner = self.data.sold_tickets[selected_ticket_id]\n    sp.send(winner, self.data.jackpot, message="winner contract not found.")\n    self.data.jackpot = sp.tez(0)\n    self.data.close_date = sp.timestamp(0)\n    self.data.players = sp.set()\n    self.data.sold_tickets = sp.map()\n    self.data.raffle_is_open = False\n')),(0,r.kt)("p",null,"Four assertions are checked in this entrypoint:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The caller must be the admin of the contract."),(0,r.kt)("li",{parentName:"ol"},"The raffle must be open."),(0,r.kt)("li",{parentName:"ol"},"The closing date must be greater than or equal to the closing date indicated in the storage."),(0,r.kt)("li",{parentName:"ol"},"The hash of the ticket used as a parameter, must be equal to the hash of the ticket indicated in the storage.",(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"The administrator provides as parameter a ",(0,r.kt)("inlineCode",{parentName:"p"},"sp.nat()")," which must correspond to the number of the winning ticket, afterwards this natural integer is converted into ",(0,r.kt)("inlineCode",{parentName:"p"},"byte")," and hashed using the ",(0,r.kt)("inlineCode",{parentName:"p"},"sha256")," algorithm.")))),(0,r.kt)("p",null,"If the conditions are met, then:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The jackpot is sent to the winner's address."),(0,r.kt)("li",{parentName:"ul"},"The storage is reset to the default values.")),(0,r.kt)("h3",{id:"run-and-watch-the-output-1"},"Run and watch the output"),(0,r.kt)("p",null,"We are getting to the end of our smart contract. Run it one last time and explore the result. Don't hesitate to read the test scenario, to make sure your smart contract is working correctly. You can, of course, modify the scenarios or create new ones."),(0,r.kt)("p",null,"Check out the final Michelson code generated by SmartPy for this smart contract. Note that you can use this ",(0,r.kt)("em",{parentName:"p"},"Michelson")," code to create additional tests with ",(0,r.kt)("em",{parentName:"p"},"PyTezos")," as described in the ",(0,r.kt)("a",{parentName:"p",href:"/ligo/unit-testing"},"LIGO Module"),"."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"SmartPy is meant for smart contract development and it always yields Michelson code.\nThe method for developing such smart contracts is pretty much always the same."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"the ",(0,r.kt)("strong",{parentName:"li"},"smart contract")," is a class definition that inherits from ",(0,r.kt)("inlineCode",{parentName:"li"},"sp.Contract"),"."),(0,r.kt)("li",{parentName:"ol"},"the ",(0,r.kt)("strong",{parentName:"li"},"storage")," is defined in the constructor of this class."),(0,r.kt)("li",{parentName:"ol"},"the ",(0,r.kt)("strong",{parentName:"li"},"entrypoints")," are defined as a method of the contract class and are marked with the ",(0,r.kt)("inlineCode",{parentName:"li"},"@sp.entry_point")," decorator.")),(0,r.kt)("p",null,"There is no need for a ",(0,r.kt)("strong",{parentName:"p"},"main")," function like ",(0,r.kt)("a",{parentName:"p",href:"/ligo"},"LIGO")," which dispatches the actions of the smart contract. The code can be compiled directly."),(0,r.kt)("p",null,"SmartPy was designed to help developers build smart contracts by providing them with a syntax familiar to them and a powerful analysis tool."),(0,r.kt)("h2",{id:"to-go-further"},"To go further"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can explore contract examples and train yourself on ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/ide"},"the online editor"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can go to ",(0,r.kt)("a",{parentName:"p",href:"https://cryptocodeschool.in/tezos"},"Cryptocodeschool.in"),"\nwhich is a fun platform that teaches how to code decentralized apps on the Tezos blockchain using SmartPy, and more."))),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,"[1]"," ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/reference.html"},"https://smartpy.io/reference.html")),(0,r.kt)("p",null,"[2]"," ",(0,r.kt)("a",{parentName:"p",href:"https://smartpy.io/ide"},"https://smartpy.io/ide")))}d.isMDXComponent=!0},9547:function(e,t,a){"use strict";t.Z=a.p+"assets/images/online_editor_Types-d267721a3a512b12841cfea25d9f5070.png"},5861:function(e,t,a){"use strict";t.Z=a.p+"assets/images/online_editor_create_contract-93430991cb12bdaf51a7fe53344edc1c.png"},7863:function(e,t,a){"use strict";t.Z=a.p+"assets/images/online_editor_scenario_output-e7762a6bedb7728791e324fa3ffb0021.png"},4230:function(e,t,a){"use strict";t.Z=a.p+"assets/images/online_editor_summary_contract-a314f7400b3a35a2c0046d2854a792a6.png"},8913:function(e,t,a){"use strict";t.Z=a.p+"assets/images/raffle_schema-3366ccd4b3a5b3414069eccdebb0a6fc.svg"}}]);