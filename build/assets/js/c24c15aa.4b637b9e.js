(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[599],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=p(n),h=i,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||s;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9635:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return r},toc:function(){return l},default:function(){return c}});var a=n(2122),i=n(9756),s=(n(7294),n(3905)),o={id:"instructions-reference",title:"Instructions Reference",authors:"Frank Hillard"},r={unversionedId:"michelson/instructions-reference",id:"michelson/instructions-reference",isDocsHomePage:!1,title:"Instructions Reference",description:"This chapter provides an explicit list of all the most commonly used instructions in Michelson. It intends to describe common Michelson instructions with a graphical illustration.",source:"@site/docs/michelson/instructions-reference.md",sourceDirName:"michelson",slug:"/michelson/instructions-reference",permalink:"/michelson/instructions-reference",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/michelson/instructions-reference.md",version:"current",lastUpdatedBy:"AymericBethencourt",lastUpdatedAt:1622492036,formattedLastUpdatedAt:"5/31/2021",frontMatter:{id:"instructions-reference",title:"Instructions Reference",authors:"Frank Hillard"},sidebar:"docs",previous:{title:"Examples",permalink:"/michelson/examples"},next:{title:"Exam",permalink:"/michelson/exam"}},l=[{value:"Instructions",id:"instructions",children:[{value:"Stack operations",id:"stack-operations",children:[]},{value:"Generic comparison",id:"generic-comparison",children:[]},{value:"Operations on bool",id:"operations-on-bool",children:[]},{value:"Operations on numbers",id:"operations-on-numbers",children:[]},{value:"Operations on strings",id:"operations-on-strings",children:[]},{value:"Control structures",id:"control-structures",children:[]},{value:"Operations on pairs",id:"operations-on-pairs",children:[]},{value:"Operations on sets",id:"operations-on-sets",children:[]},{value:"Operations on optional values",id:"operations-on-optional-values",children:[]},{value:"Operations on maps/big_maps",id:"operations-on-mapsbig_maps",children:[]},{value:"Operations on unions",id:"operations-on-unions",children:[]},{value:"Operations on lists",id:"operations-on-lists",children:[]},{value:"Operations on timestamps",id:"operations-on-timestamps",children:[]},{value:"Operations on mutez",id:"operations-on-mutez",children:[]},{value:"Operations on contracts",id:"operations-on-contracts",children:[]},{value:"Built-ins",id:"built-ins",children:[]},{value:"Operations on bytes",id:"operations-on-bytes",children:[]},{value:"Crypto primitives",id:"crypto-primitives",children:[]},{value:"Macros and syntactic sugar",id:"macros-and-syntactic-sugar",children:[]},{value:"Annotations",id:"annotations",children:[]}]}],p={toc:l};function c(e){var t=e.components,o=(0,i.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This chapter provides an explicit list of all the most commonly used instructions in Michelson. It intends to describe common Michelson instructions with a graphical illustration."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"It is not intended for you to be read as is but to be used as a reference during your developments.")),(0,s.kt)("p",null,"An exhaustive list of Michelson instructions, with a full detailed description, is available on the official reference website (",(0,s.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/"},"https://tezos.gitlab.io/michelson-reference/"),")."),(0,s.kt)("h2",{id:"instructions"},"Instructions"),(0,s.kt)("h3",{id:"stack-operations"},"Stack operations"),(0,s.kt)("p",null,"Some generic operators allow elements in a stack to be manipulated, such as moving an element into the stack or moving, copying, and removing elements from the stack. "),(0,s.kt)("h4",{id:"push-instruction"},"PUSH instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"PUSH")," instruction allows an element to be placed on top of the stack."),(0,s.kt)("p",null,"It requires the type of pushed element be specified."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(7977).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 2: Illustration of the `PUSH` instruction"),(0,s.kt)("h4",{id:"unit-instruction"},"UNIT instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"UNIT")," instruction pushes a ",(0,s.kt)("inlineCode",{parentName:"p"},"Unit")," value on top of the stack."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Unit")," value represents no value."),(0,s.kt)("h4",{id:"drop-instruction"},"DROP instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DROP")," instruction removes the top element of the stack"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(4946).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 3: Illustration of the `DROP` instruction"),(0,s.kt)("h4",{id:"swap-instruction"},"SWAP instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SWAP")," instruction inverts the position of the top two elements of the stack."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6319).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 4: Illustration of the `SWAP` instruction"),(0,s.kt)("h4",{id:"dup-instruction"},"DUP instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DUP")," instruction duplicates the top element of the stack"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5470).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 5: Illustration of the `DUP` instruction"),(0,s.kt)("h4",{id:"dig-instruction"},"DIG instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DIG n")," instruction moves the n-th element of the stack to the top of the stack."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(7325).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 6: Illustration of the `DIG` instruction"),(0,s.kt)("h4",{id:"dug-instruction"},"DUG instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DUG n")," instruction moves the top element of the stack to the n-th element of the stack."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1331).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 7: Illustration of the `DUG` instruction"),(0,s.kt)("h4",{id:"dip-instruction"},"DIP instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DIP")," instruction takes two arguments:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"n"),": a number of elements to protect (by default 1)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"code"),": a sequence of instructions to execute")),(0,s.kt)("p",null,"It runs the provided sequence of instructions while protecting the ",(0,s.kt)("em",{parentName:"p"},"n")," top elements of the stack."),(0,s.kt)("p",null,"There is a special case when n = 1. An alias (shortcut) is available for this case, the ",(0,s.kt)("inlineCode",{parentName:"p"},"DIP code")," instruction is equivalent to ",(0,s.kt)("inlineCode",{parentName:"p"},"DIP 1 code"),"."),(0,s.kt)("p",null,"Also notice that ",(0,s.kt)("inlineCode",{parentName:"p"},"DIP 0 code")," is equivalent to ",(0,s.kt)("inlineCode",{parentName:"p"},"code")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9667).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 8: Illustration of the `DIP` instruction"),(0,s.kt)("h4",{id:"lambda"},"LAMBDA"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction pushes a function on top of the stack."),(0,s.kt)("p",null,"It requires three arguments:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the type of the function argument"),(0,s.kt)("li",{parentName:"ul"},"the type returned by the function"),(0,s.kt)("li",{parentName:"ul"},"the sequence of instructions associated with the function (code of the function)")),(0,s.kt)("p",null,"Here is an example of a smart contract that defines a function with the ",(0,s.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction and executes the function with the ",(0,s.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage int ;\ncode { CAR ;\n       LAMBDA int int { PUSH int 1 ; ADD } ;\n       SWAP ;\n       EXEC ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"lambda")," function is just incrementing a given int."),(0,s.kt)("p",null,"The execution of this smart contract is described in the example section."),(0,s.kt)("h3",{id:"generic-comparison"},"Generic comparison"),(0,s.kt)("h4",{id:"compare"},"COMPARE"),(0,s.kt)("p",null,"This instruction compares the top two elements of the stack."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction returns -1 if the first element is smaller than the second one. It returns 0 if the two first elements are equal. Otherwise it returns 1."),(0,s.kt)("p",null,"Here is an example of a comparison between two natural integers:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2990).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 9: Illustration of the `COMPARE` instruction"),(0,s.kt)("h4",{id:"eq"},"EQ"),(0,s.kt)("p",null,"The top element is replaced by ",(0,s.kt)("em",{parentName:"p"},"True")," if this element is zero, otherwise by ",(0,s.kt)("em",{parentName:"p"},"False"),". "),(0,s.kt)("p",null,"Here is an example:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9465).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 10: Illustration of the `EQ` instruction"),(0,s.kt)("h4",{id:"lt"},"LT"),(0,s.kt)("p",null,"The top element is replaced by ",(0,s.kt)("em",{parentName:"p"},"True")," if this element is lower than zero, otherwise by ",(0,s.kt)("em",{parentName:"p"},"False"),". "),(0,s.kt)("p",null,"Here is an example:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1618).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 11: Illustration of the `LT` instruction"),(0,s.kt)("h4",{id:"ge"},"GE"),(0,s.kt)("p",null,"The top element is replaced by ",(0,s.kt)("em",{parentName:"p"},"True")," if this element is greater or equal to zero, otherwise by ",(0,s.kt)("em",{parentName:"p"},"False"),". "),(0,s.kt)("p",null,"Here is an example:"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(8280).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 12: Illustration of the `GE` instruction"),(0,s.kt)("h3",{id:"operations-on-bool"},"Operations on bool"),(0,s.kt)("h4",{id:"or"},"OR"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"OR")," instruction consumes the top two elements of the stack and computes a logical ",(0,s.kt)("em",{parentName:"p"},"OR")," of both elements."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9328).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 13: Illustration of the `OR` instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"OR")," instruction requires boolean elements."),(0,s.kt)("h4",{id:"and"},"AND"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"AND")," instruction consumes the top two elements of the stack and computes a logical ",(0,s.kt)("em",{parentName:"p"},"AND")," of the two elements."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(3026).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 14: Illustration of the `AND` instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"AND")," instruction requires boolean elements."),(0,s.kt)("h4",{id:"xor"},"XOR"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"XOR")," instruction consumes the top two elements of the stack and computes an exclusive logical ",(0,s.kt)("em",{parentName:"p"},"OR")," of the two elements."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(926).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 15: Illustration of the `XOR` instruction"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"XOR")," instruction requires boolean elements."),(0,s.kt)("h4",{id:"not"},"NOT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"NOT")," instruction consumes a boolean top element of the stack and pushes the logical inverse of the given boolean.  "),(0,s.kt)("h3",{id:"operations-on-numbers"},"Operations on numbers"),(0,s.kt)("h4",{id:"add"},"ADD"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ADD")," instruction computes addition on ",(0,s.kt)("em",{parentName:"p"},"nat")," and ",(0,s.kt)("em",{parentName:"p"},"int"),". It consumes the top two elements of the stack and pushes back the addition of the two elements on top of the stack."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(3541).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 16: Illustration of the `ADD` instruction"),(0,s.kt)("h4",{id:"sub"},"SUB"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SUB")," instruction computes subtractions on ",(0,s.kt)("em",{parentName:"p"},"nat")," and ",(0,s.kt)("em",{parentName:"p"},"int"),". It consumes the top two elements of the stack and pushes back the difference of the two elements on top of the stack."),(0,s.kt)("p",null,"Notice that the subtraction of two natural integers produces an integer  (since the expression ",(0,s.kt)("inlineCode",{parentName:"p"},"2 - 4")," produces an number smaller than 0)."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1254).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 17: Illustration of the `SUB` instruction"),(0,s.kt)("h4",{id:"mul"},"MUL"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MUL")," instruction computes multiplications on ",(0,s.kt)("em",{parentName:"p"},"nat")," and ",(0,s.kt)("em",{parentName:"p"},"int"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(803).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 18: Illustration of the `MUL` instruction"),(0,s.kt)("p",null,"Notice that the multiplication of two natural integers produces a natural integer."),(0,s.kt)("h4",{id:"ediv"},"EDIV"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction computes divisions on ",(0,s.kt)("em",{parentName:"p"},"nat")," and ",(0,s.kt)("em",{parentName:"p"},"mutez"),"."),(0,s.kt)("p",null,"The euclidean division computes the quotient and the remainder between two numbers."),(0,s.kt)("p",null,"If the divisor is equal to zero, it returns an optional type with the assigned value ",(0,s.kt)("em",{parentName:"p"},"None"),". Otherwise, it applies the Euclidean division and returns an optional type containing the result (quotient and remainder). "),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9640).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 19: Illustration of the `EDIV` instruction"),(0,s.kt)("h3",{id:"operations-on-strings"},"Operations on strings"),(0,s.kt)("p",null,"Strings are mostly used for naming things without having to rely on external ID databases. They are restricted to the printable subset of 7-bit ASCII, plus some escaped characters (see the section on constants). We can use string constants as is, concatenate or splice them, and also use them as keys."),(0,s.kt)("h4",{id:"concat"},"CONCAT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction concatenates strings. It consumes the two top elements and produces a string (concatenation of the two top element) that is placed on top of the stack. The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction also works with a list of strings. "),(0,s.kt)("h4",{id:"size"},"SIZE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction consumes a string of the top of the stack and pushes the number of characters contained in the string element."),(0,s.kt)("h4",{id:"slice"},"SLICE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SLICE")," instruction provides a way to retrieve a part of a string.\nIt expects on top of the stack three elements:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"an ",(0,s.kt)("inlineCode",{parentName:"li"},"offset")," argument indicating the beginning of the substring "),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("inlineCode",{parentName:"li"},"length")," argument indicating the size of the substring"),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("inlineCode",{parentName:"li"},"string")," to slice")),(0,s.kt)("p",null,"It returns an optional string because the given offset may be out of bound."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2365).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 20: Illustration of the `SLICE` instruction"),(0,s.kt)("h4",{id:"compare-with-strings"},"COMPARE with strings"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction allows two strings to be compared. It consumes the top two elements of the stack and pushes an integer to the top. If the first element is lexically greater than the second, then it returns 1. If the first element is lexically equal to the second element, then it returns 0. If the first element is lexically smaller than the second element, then it returns -1."),(0,s.kt)("h3",{id:"control-structures"},"Control structures"),(0,s.kt)("p",null,"Michelson is a turing-complete language and thus provides basic control flow instructions."),(0,s.kt)("h4",{id:"sequence-"},"Sequence {}"),(0,s.kt)("p",null,"The Sequence structure is defined by ",(0,s.kt)("inlineCode",{parentName:"p"},"{")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"}")," and contains instructions separated by ",(0,s.kt)("inlineCode",{parentName:"p"},";")," (semi-colon)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"{ instruction1 ; instruction2 ; ... ; instruction n}\n")),(0,s.kt)("p",null,"When executing a sequence the interpreter executes each instruction sequentially, one after the other, in the specified order."),(0,s.kt)("p",null,"However, this sequence may stop by throwing an exception."),(0,s.kt)("h4",{id:"failwith"},"FAILWITH"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction aborts the execution of the Michelson script by throwing an exception."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction consumes the top element of the stack as argument (usually a string message). The consumed element must be of a pushable type. It is allowed to throw an exception without message by pushing a ",(0,s.kt)("inlineCode",{parentName:"p"},"UNIT")," value on top of the stack."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"FAIL")," keyword has been provided as replacement for ",(0,s.kt)("inlineCode",{parentName:"p"},"UNIT; FAILWITH"),"."),(0,s.kt)("p",null,"Actually, the ",(0,s.kt)("inlineCode",{parentName:"p"},"FAIL"),' keyword is not an instruction but a syntactic sugar (i.e. a "shortcut" instruction that combines many of language\'s basic instructions).'),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction provides a way to reject a transaction by stopping the execution of related instructions."),(0,s.kt)("h4",{id:"if--"},"IF {} {}"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction allows branches of execution to be created (also called conditional branching)."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction takes two sequences as arguments. It expects a boolean at the top element of the stack. It consumes the top element and executes the first given sequence if this boolean-top element is ",(0,s.kt)("em",{parentName:"p"},"True"),". Otherwise it executes the second sequence."),(0,s.kt)("p",null,"Here is an example of an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction that inverts the position of two elements of the stack if the condition is ",(0,s.kt)("em",{parentName:"p"},"False"),", otherwise it throws an exception. Inverting the positions of two elements is done using the ",(0,s.kt)("inlineCode",{parentName:"p"},"SWAP")," instruction."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(5552).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 1: Execution of `IF`"),(0,s.kt)("h4",{id:"loop-"},"LOOP {}"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction is a generic loop, meaning it is a repeatable pattern. It applies a sequence of instructions many times until a condition is reached. "),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction makes it possible to iterate on a composite structure (list, set, map, big_map) and apply a process to all elements sequentially."),(0,s.kt)("h4",{id:"loop_left-loop-with-accumulator"},"LOOP_LEFT (loop with accumulator)"),(0,s.kt)("p",null,"Like the ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP")," instruction, ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT {}")," is a generic loop that handles an accumulator generally used for aggregating data during a repetitive process. "),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT {}")," takes a sequence of instructions as argument and requires a ",(0,s.kt)("inlineCode",{parentName:"p"},"union")," (composed of a given data structure and an accumulator) on top of the stack. If the left part of the ",(0,s.kt)("inlineCode",{parentName:"p"},"union")," is initialized the process is repeated. If the right part is initialized then the process is stopped and the accumulator is returned."),(0,s.kt)("p",null,"Two examples (",(0,s.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-4--computing-a-sum-with-loop_left"},"#4")," and ",(0,s.kt)("a",{parentName:"p",href:"https://opentezos.com/michelson/examples#example-5--computing-a-factorial-with-loop_left"},"#5"),") in the ",(0,s.kt)("em",{parentName:"p"},"Examples")," section describe in detail the ",(0,s.kt)("inlineCode",{parentName:"p"},"LOOP_LEFT")," instruction usage."),(0,s.kt)("h4",{id:"exec"},"EXEC"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction executes a function from the stack."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction consumes a function and its related input arguments on top of the stack. The ",(0,s.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction produces the expected function output on the top of the stack."),(0,s.kt)("p",null,"Here is an example of a smart contract that defines a function with the ",(0,s.kt)("inlineCode",{parentName:"p"},"LAMBDA")," instruction and executes the function with the ",(0,s.kt)("inlineCode",{parentName:"p"},"EXEC")," instruction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage int ;\ncode { CAR ;\n       LAMBDA int int { PUSH int 1 ; ADD } ;\n       SWAP ;\n       EXEC ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"Notice that the code of the ",(0,s.kt)("inlineCode",{parentName:"p"},"LAMBDA")," function just increments a given integer by 1."),(0,s.kt)("p",null,'The execution of this smart contract is described in the "example" section.'),(0,s.kt)("h4",{id:"apply"},"APPLY"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"APPLY 'a")," instruction partially applies a ",(0,s.kt)("em",{parentName:"p"},"tuplified")," function from the stack (i.e. arguments are grouped in pairs or nested pairs). It is parameterized by a type ",(0,s.kt)("inlineCode",{parentName:"p"},"'a"),". Values that are not both push-able and storable (i.e. values of type ",(0,s.kt)("em",{parentName:"p"},"operation"),", ",(0,s.kt)("em",{parentName:"p"},"contract"),", and ",(0,s.kt)("em",{parentName:"p"},"big map"),") cannot be captured by ",(0,s.kt)("em",{parentName:"p"},"APPLY")," (and so cannot appear in argument ",(0,s.kt)("inlineCode",{parentName:"p"},"'a"),")."),(0,s.kt)("p",null,"The instruction produces a new function that is only partially resolved. For example, if a function takes 2 arguments, it is possible to provide one argument and to use the ",(0,s.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction to produce an equivalent partially-resolved function which takes one argument."),(0,s.kt)("p",null,"For example, let's consider a ",(0,s.kt)("inlineCode",{parentName:"p"},"lambda")," function (called ",(0,s.kt)("em",{parentName:"p"},"additionAB"),") that takes a pair of ",(0,s.kt)("em",{parentName:"p"},"nat")," and returns a ",(0,s.kt)("em",{parentName:"p"},"nat"),". It computes the addition of two numbers."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"LAMBDA (pair nat nat) nat { ADD }\n")),(0,s.kt)("p",null,"Notice that the function is tuplified."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"APPLY")," instruction allows a new ",(0,s.kt)("inlineCode",{parentName:"p"},"lambda")," function to be formed (called ",(0,s.kt)("em",{parentName:"p"},"addition2B"),") which takes a single ",(0,s.kt)("em",{parentName:"p"},"nat")," as argument and returns a ",(0,s.kt)("em",{parentName:"p"},"nat"),". This function would increment a given ",(0,s.kt)("em",{parentName:"p"},"nat")," by two. "),(0,s.kt)("p",null,"The resulting function ",(0,s.kt)("em",{parentName:"p"},"addition2B")," is equivalent to:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"LAMBDA nat nat { PUSH nat 2 ; ADD }\n")),(0,s.kt)("h3",{id:"operations-on-pairs"},"Operations on pairs"),(0,s.kt)("h4",{id:"pair"},"PAIR"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"PAIR")," instruction consumes the top two elements of the stack and creates a pair with these two elements."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2749).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 21: Illustration of the `PAIR` instruction"),(0,s.kt)("h4",{id:"car"},"CAR"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CAR")," instruction consumes the top element of the stack (which must be a ",(0,s.kt)("inlineCode",{parentName:"p"},"PAIR"),") and pushes back on top of the stack the left part of the pair."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(8771).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 22: Illustration of the `CAR` instruction"),(0,s.kt)("h4",{id:"cdr"},"CDR"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CDR")," instruction consumes the top element of the stack (which must be a ",(0,s.kt)("inlineCode",{parentName:"p"},"PAIR"),") and pushes back on top of the stack the right part of the pair."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1675).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 23: Illustration of the `CDR` instruction"),(0,s.kt)("h4",{id:"compare-on-pairs"},"COMPARE on pairs"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction computes a lexicographic comparison. Like the generic comparison it consumes the top two elements of the stack and returns an integer (-1, 0 ,1). "),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction executes the comparison on both (left and right) part of a ",(0,s.kt)("em",{parentName:"p"},"pair"),". It starts with comparing left parts and if the result is 0 (i.e. left parts are equal) then the comparison is done on the right part of the pair."),(0,s.kt)("h3",{id:"operations-on-sets"},"Operations on sets"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SET")," data structure is an ordered list of elements. Therefore a value in a set can appear only once."),(0,s.kt)("h4",{id:"empty_set-elt"},"EMPTY_SET 'elt"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EMPTY_SET")," instruction builds a new, empty set for elements of a given type."),(0,s.kt)("p",null,"The 'elt type must be comparable (the COMPARE primitive must be defined over it)."),(0,s.kt)("h4",{id:"mem"},"MEM"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MEM")," instruction checks for the presence of an element in a set."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MEM")," instruction returns a boolean on top of the stack."),(0,s.kt)("h4",{id:"update"},"UPDATE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction inserts or removes an element in a set, replacing a previous value."),(0,s.kt)("p",null,"It takes the top two elements of the stack:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"an element whose type corresponds to the ",(0,s.kt)("em",{parentName:"li"},"set")," type"),(0,s.kt)("li",{parentName:"ul"},"a boolean representing the existence of this element in the ",(0,s.kt)("em",{parentName:"li"},"set"))),(0,s.kt)("p",null,"If the boolean argument is ",(0,s.kt)("em",{parentName:"p"},"False")," then the element will be removed."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2716).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 24: Illustration of the `UPDATE` instruction"),(0,s.kt)("p",null,"If the boolean argument is ",(0,s.kt)("em",{parentName:"p"},"True")," then the element will be inserted."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(8665).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 25: Illustration of the `UPDATE` instruction"),(0,s.kt)("p",null,"The following smart contract illustrates the ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction usage. This smart contract stores a set of integers and can be invoked by specifying an integer that will be inserted in the set."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter int ;\nstorage (set int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       PUSH bool True ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"You can test the smart contract with the following command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script set_example.tz on storage '{1;2;3; 9}' and input '7'\n")),(0,s.kt)("h4",{id:"iter-body"},"ITER body"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction takes a sequence of instructions (called "body") as argument.'),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction applies a given sequence of instructions to each element of a set. The "body" sequence has access to the stack.'),(0,s.kt)("h4",{id:"size-1"},"SIZE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction consumes a set from the top of the stack and pushes to the top the number of elements contained in the set."),(0,s.kt)("h3",{id:"operations-on-optional-values"},"Operations on optional values"),(0,s.kt)("p",null,"An optional value is a data structure that can hold a value (of a given type). The optional value has two states: it is defined as ",(0,s.kt)("inlineCode",{parentName:"p"},"NONE")," if no value is assigned and can be defined as ",(0,s.kt)("inlineCode",{parentName:"p"},"SOME")," if a value has been assigned."),(0,s.kt)("p",null,"When defining an optional value, the type of value must be specified."),(0,s.kt)("h4",{id:"some"},"SOME"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SOME")," instruction packs a value as an optional value."),(0,s.kt)("h4",{id:"none"},"NONE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"NONE")," instruction specifies the absence of value. It requires that the type of value that can be held be specified."),(0,s.kt)("h4",{id:"if_none"},"IF_NONE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE bt bf")," instruction inspects an optional value.\nIt requires two sequences of instructions, as with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction.\nIt executes the first sequence if the optional value has no value assigned, otherwise it executes the second sequence of instructions (where a value has been assigned with a ",(0,s.kt)("inlineCode",{parentName:"p"},"SOME")," instruction)."),(0,s.kt)("p",null,"If the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction encounters a NONE value it consumes it and then start executing the first sequence.",(0,s.kt)("br",{parentName:"p"}),"\n","If the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction encounters a SOME value it does not consumes it and then start executing the second sequence."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6702).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 25: Illustration of the `IF_NONE` instruction"),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(4668).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 26: Illustration of the `IF_NONE` instruction"),(0,s.kt)("h3",{id:"operations-on-mapsbig_maps"},"Operations on maps/big_maps"),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"map")," is an associative array. It stores many pairs of key-value elements, i.e. it binds a key and a value. Key and value type must be defined when instantiating a new ",(0,s.kt)("inlineCode",{parentName:"p"},"map"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"map")," data structure can only contain a limited amount of data. When using big and complex types as values, it is recommended to use the ",(0,s.kt)("inlineCode",{parentName:"p"},"big_map")," data structure."),(0,s.kt)("h4",{id:"empty_map-key-val-and-empty_big_map-key-val"},"EMPTY_MAP 'key 'val and EMPTY_BIG_MAP 'key 'val"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EMPTY_MAP")," instruction builds a new empty map. It requires the type definition of the key (",(0,s.kt)("em",{parentName:"p"},"'key"),") and type definition of the value (",(0,s.kt)("em",{parentName:"p"},"'val"),")."),(0,s.kt)("p",null,"The ",(0,s.kt)("em",{parentName:"p"},"'key")," type must be comparable (the COMPARE primitive must be defined over it)."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EMPTY_BIG_MAP")," instruction builds a new empty ",(0,s.kt)("inlineCode",{parentName:"p"},"big_map")," data structure."),(0,s.kt)("h4",{id:"mem-1"},"MEM"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MEM")," instruction checks for the presence of a binding for a key in a map."),(0,s.kt)("p",null,"It takes a key as argument and returns a boolean on top of the stack."),(0,s.kt)("h4",{id:"update-1"},"UPDATE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction adds or removes an element in a map."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," instruction expects a key, an optional value and a map on top of the stack. It consumes the key and the optional value and modifies the map accordingly."),(0,s.kt)("p",null,"If the optional value is defined as ",(0,s.kt)("inlineCode",{parentName:"p"},"None"),", then the element is removed from the map. The following smart contract (map_remove_example.tz) illustrates the ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," usage while removing an element from the map."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       NONE int ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"This smart contract can be tested with the following command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_remove_example.tz on storage '{ Elt \"toto\" 1 }' and input '\"toto\"'\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6016).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 27: Illustration of the `UPDATE` instruction"),(0,s.kt)("p",null,"If the optional value is defined as ",(0,s.kt)("inlineCode",{parentName:"p"},"Some")," then the element is insert into the map. The following smart contract (map_insert_example.tz) illustrates the ",(0,s.kt)("inlineCode",{parentName:"p"},"UPDATE")," usage while inserting an element into the map."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       PUSH int 2;\n       SOME ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"This smart contract can be tested with the following command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_insert_example.tz on storage '{ Elt \"toto\" 1 }' and input '\"tutu\"'\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(9765).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 28: Illustration of the `UPDATE` instruction"),(0,s.kt)("h4",{id:"get"},"GET"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"GET")," instruction allows to access to an element inside a map. It returns an optional value to be checked with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_SOME")," instruction."),(0,s.kt)("p",null,"The following smart contract illustrates the usage of ",(0,s.kt)("inlineCode",{parentName:"p"},"GET"),". The storage of this contract defines a map. This smart contract takes a key as the parameter and inserts a new element in the map if the key does not exist. In this case it assigns value 0 to the given key. Otherwise if the map possesses an element for the given key then it increments its associated value."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter string ;\nstorage (map string int) ;\ncode { DUP ;\n       CAR ;\n       DIP { CDR } ;\n       DIP { DUP } ;\n       DUP ;\n       DIP { SWAP } ;\n       GET ;\n       IF_NONE { PUSH int 0 ; SOME } { PUSH int 1 ; ADD ; SOME } ;\n       SWAP ;\n       UPDATE ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"This smart contract can be simulated with the following commands:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_example.tz on storage '{}' and input '\"toto\"'\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script map_example.tz on storage '{ Elt \"toto\" 5 }' and input '\"toto\"'\n")),(0,s.kt)("p",null,"Notice that ",(0,s.kt)("inlineCode",{parentName:"p"},"{}")," represents an empty map and ",(0,s.kt)("inlineCode",{parentName:"p"},'{ Elt "toto" 5 }'),' a map containing one element where "toto" is the key and its associated value is 5.'),(0,s.kt)("h4",{id:"map-body"},"MAP body"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP"),' instruction applies a sequence of instructions to each element of a map. It takes a sequence of instructions as argument (called "body"). This "body" sequence has access to the stack.'),(0,s.kt)("p",null,"The following smart contract (map_map_example.tz) illustrates the ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP")," usage. This smart contract stores a ",(0,s.kt)("inlineCode",{parentName:"p"},"map string nat")," and when invoked it goes through all key-value elements of the map and multiplies by 2 the ",(0,s.kt)("inlineCode",{parentName:"p"},"nat")," value."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter unit ;\nstorage (map string nat) ;\ncode {\n       CDR ;\n       MAP { CDR ; PUSH nat 2 ; MUL }  ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"The smart contract can be simulated with the following command."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'tezos-client run script map_map_example.tz on storage \'{ Elt "toto" 1 ; Elt "tutu" 4 }\' and input Unit\n')),(0,s.kt)("h4",{id:"iter-body-1"},"ITER body"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction applies a sequence of instructions (called "body") to each element of a map. The "body" sequence has access to the stack.'),(0,s.kt)("p",null,'An example ("Max list") illustrating ',(0,s.kt)("inlineCode",{parentName:"p"},"ITER")," instruction usage is described in the ",(0,s.kt)("em",{parentName:"p"},"Examples")," section. Despite being applied to a list of integers, the ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER")," instruction works in the same way with a map (except at each iteration a ",(0,s.kt)("em",{parentName:"p"},"pair"),' key-value is pushed on the stack instead of an integer, as in the example "Max list").'),(0,s.kt)("h4",{id:"size-2"},"SIZE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the number of elements inside a map."),(0,s.kt)("p",null,"It consumes a map on top of the stack and places the number of elements on top of the stack."),(0,s.kt)("p",null,"Notice that the ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction cannot be applied to ",(0,s.kt)("inlineCode",{parentName:"p"},"big_map")," type. "),(0,s.kt)("h3",{id:"operations-on-unions"},"Operations on unions"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"union")," data structure specifies two possible type definitions with logical ",(0,s.kt)("em",{parentName:"p"},"or"),". It can be used to create a new type which can handle two different type definitions."),(0,s.kt)("p",null,'For example, the following Michelson expression defines the type "int_or_nat" as:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"or int nat\n")),(0,s.kt)("h4",{id:"left"},"LEFT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"LEFT p")," instruction takes the top-element of the stack and produces a ",(0,s.kt)("em",{parentName:"p"},"union"),".\nThe top-element is placed in the right branch of the ",(0,s.kt)("inlineCode",{parentName:"p"},"or")," structure and the left branch is typed with the given ",(0,s.kt)("inlineCode",{parentName:"p"},"p")," argument."),(0,s.kt)("p",null,"It consumes a type definition on top of the stack and pushes a union where the left part is defined as the consumed type definition."),(0,s.kt)("p",null,"Usage of the ",(0,s.kt)("inlineCode",{parentName:"p"},"LEFT")," instruction is illustrated in the example section."),(0,s.kt)("h4",{id:"right"},"RIGHT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"RIGHT p")," instruction takes the top-element of the stack and produces a ",(0,s.kt)("em",{parentName:"p"},"union"),".\nThe top-element is placed in the left branch of the ",(0,s.kt)("inlineCode",{parentName:"p"},"or")," structure and the right branch is typed with the given ",(0,s.kt)("inlineCode",{parentName:"p"},"p")," argument."),(0,s.kt)("p",null,"It consumes a type definition on top of the stack and pushes a union where the right part is defined as the consumed type definition."),(0,s.kt)("p",null,"Usage of the ",(0,s.kt)("inlineCode",{parentName:"p"},"RIGHT")," instruction is illustrated in the example section."),(0,s.kt)("h4",{id:"if_left"},"IF_LEFT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction inspects a value of ",(0,s.kt)("em",{parentName:"p"},"union"),". It requires two sequences of instructions (bt bf), like with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction. "),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT bt bf"),' executes the "bt" sequence if the left part of a ',(0,s.kt)("em",{parentName:"p"},"union"),' has been given, otherwise it will execute the "bf" sequence.'),(0,s.kt)("p",null,"The instruction consumes a Michelson expression on top of the stack which specifies which part of the ",(0,s.kt)("em",{parentName:"p"},"union")," has been defined."),(0,s.kt)("p",null,"The following smart contract (union_example.tz) illustrates the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," usage. Notice that the parameter is a ",(0,s.kt)("em",{parentName:"p"},"union")," ",(0,s.kt)("inlineCode",{parentName:"p"},"(or string int)")," and the storage is an integer. This smart contract increments the storage if an integer is passed as parameter (i.e. if the smart contract is invoked with an integer) and does nothing if a string is given."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or string int) ;\nstorage int ;\ncode { DUP ; CAR ; DIP { CDR } ;\n       IF_LEFT { DROP } { ADD } ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,"To illustrate the invocation of the smart contract, we will break down its execution."),(0,s.kt)("p",null,"The following command simulates the execution of the smart contract when called with an integer."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script union_example.tz on storage '5' and input 'Right 1'\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1077).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 30: Illustration of the `IF_LEFT` instruction"),(0,s.kt)("p",null,"The following command simulates the execution of the smart contract when called with a string."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script union_example.tz on storage '5' and input 'Left \"Hello\"'\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2841).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 31: Illustration of the `IF_LEFT` instruction"),(0,s.kt)("h3",{id:"operations-on-lists"},"Operations on lists"),(0,s.kt)("h4",{id:"cons"},"CONS"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONS")," instruction adds an element to a list (at the beginning of the list)."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(2472).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 32: Illustration of the `CONS` instruction"),(0,s.kt)("h4",{id:"nil"},"NIL"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"NIL 'a")," instruction specifies an empty list. The type of list elements must be specified. "),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(1658).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 33: Illustration of the `NIL` instruction"),(0,s.kt)("h4",{id:"if_cons"},"IF_CONS"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_CONS bt bf")," instruction inspects a list. It requires two sequences of instructions (bt anf bf), as with the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction."),(0,s.kt)("p",null,"This instruction removes the first element of the list, pushes it on top of the stack and executes the first sequence of instructions (",(0,s.kt)("inlineCode",{parentName:"p"},"bt"),"). If the list is empty, then the second list of instructions is executed (",(0,s.kt)("inlineCode",{parentName:"p"},"bf"),")."),(0,s.kt)("h4",{id:"map-body-1"},"MAP body"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP")," instruction applies a sequence of instructions to each element of a list. The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP"),' instruction requires a sequence of instructions (i.e. "body") which has access to the stack.'),(0,s.kt)("h4",{id:"size-3"},"SIZE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the number of elements in the list.\nIt consumes a list on top of the stack and pushes the number of elements of the list back on top."),(0,s.kt)("h4",{id:"iter-body-2"},"ITER body"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER")," instruction applies a sequence of instructions to each element of a list. The ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER"),' instruction requires a sequence of instructions (called "body") which has access to the stack.'),(0,s.kt)("p",null,"Notice that the Michelson language defines the ",(0,s.kt)("inlineCode",{parentName:"p"},"ITER")," instruction as a recursive call."),(0,s.kt)("p",null,"An example is described in the ",(0,s.kt)("em",{parentName:"p"},"Examples")," section."),(0,s.kt)("h3",{id:"operations-on-timestamps"},"Operations on timestamps"),(0,s.kt)("p",null,"Timestamps can be obtained by the ",(0,s.kt)("inlineCode",{parentName:"p"},"NOW")," operation, or retrieved from script parameters or globals."),(0,s.kt)("h4",{id:"now"},"NOW"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"NOW")," instruction pushes the timestamp of the block whose validation triggered this execution. This timestamp does not change during the execution of the contract."),(0,s.kt)("h4",{id:"add-1"},"ADD"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ADD")," instruction increments a timestamp of the given number of seconds. The number of seconds must be expressed as an ",(0,s.kt)("inlineCode",{parentName:"p"},"int")," and not as a ",(0,s.kt)("inlineCode",{parentName:"p"},"nat"),"."),(0,s.kt)("h4",{id:"sub-1"},"SUB"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SUB")," instruction subtracts a number of seconds from a timestamp. It can also be used to subtract two timestamps."),(0,s.kt)("h4",{id:"compare-1"},"COMPARE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," computes timestamp comparison. It returns an integer, as with the ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction for an integer."),(0,s.kt)("p",null,"It returns 1 if the first timestamp is bigger than the second timestamp, 0 if both timestamps are equal, and -1 otherwise. "),(0,s.kt)("h3",{id:"operations-on-mutez"},"Operations on mutez"),(0,s.kt)("p",null,"Mutez (micro-Tez) are internally represented by a 64-bit, signed integer. There are restrictions to prevent creating a negative amount of mutez. Operations are limited in order to prevent overflow and to avoid mixing with other numerical types by mistake. They are also mandatorily checked for under/overflows."),(0,s.kt)("h4",{id:"add-2"},"ADD"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ADD")," instruction computes additions on mutez. It consumes two ",(0,s.kt)("em",{parentName:"p"},"mutez")," elements on top of the stack and pushes back the addition of the two quantities on top of the stack."),(0,s.kt)("p",null,"This operation may fail in case of overflow."),(0,s.kt)("h4",{id:"sub-2"},"SUB"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SUB")," instruction computes subtractions on mutez. It consumes two ",(0,s.kt)("em",{parentName:"p"},"mutez")," elements on top of the stack and pushes back the difference of the two quantities on top of the stack."),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"mutez")," value cannot be negative so this substration may fail if the first value is smaller than the second one."),(0,s.kt)("h4",{id:"mul-1"},"MUL"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MUL")," instruction computes multiplications on mutez. It consumes a ",(0,s.kt)("em",{parentName:"p"},"mutez")," and a ",(0,s.kt)("em",{parentName:"p"},"nat")," elements on top of the stack and pushes back the product of the two quantities on top of the stack."),(0,s.kt)("p",null,"The multiplication allows mutez to be multiplied with natural integers."),(0,s.kt)("p",null,"Multiplication of 2 ",(0,s.kt)("inlineCode",{parentName:"p"},"mutez")," operands is not allowed. "),(0,s.kt)("h4",{id:"ediv-1"},"EDIV"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction computes the euclidean division on mutez. It consumes a ",(0,s.kt)("em",{parentName:"p"},"mutez")," and a ",(0,s.kt)("em",{parentName:"p"},"nat")," elements on top of the stack and pushes back a ",(0,s.kt)("inlineCode",{parentName:"p"},"option pair")," with the quotient and the reminder (of the two elements) on top of the stack."),(0,s.kt)("p",null,"The euclidean division allows a mutez to be divided by a natural integer."),(0,s.kt)("p",null,"It is also possible to divide 2 mutez, in this case it returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"nat")," as a quotient and a mutez as the rest of the euclidean division."),(0,s.kt)("p",null,"If the divisor is zero then the division is not allowed. In this case, the ",(0,s.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction produces a ",(0,s.kt)("inlineCode",{parentName:"p"},"NONE")," on top of the stack. This is why the ",(0,s.kt)("inlineCode",{parentName:"p"},"EDIV")," instruction returns an ",(0,s.kt)("inlineCode",{parentName:"p"},"option")," value (i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"option pair")," with the quotient and the reminder)."),(0,s.kt)("h4",{id:"compare-2"},"COMPARE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction compares two mutez and returns an integer on top of the stack. It returns 0 if both elements are equal, 1 if the first element is bigger than the second, and -1 otherwise. "),(0,s.kt)("h3",{id:"operations-on-contracts"},"Operations on contracts"),(0,s.kt)("p",null,"This section describes instructions specific to smart contracts and interactions between contracts. It includes key features such as emitting transactions and invoking a contract, setting delegations, and even creating contracts on the fly.  "),(0,s.kt)("h4",{id:"contract"},"CONTRACT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction casts the address to the given contract type if possible.\nIt consumes an ",(0,s.kt)("inlineCode",{parentName:"p"},"address")," to the top element of the stack and returns a contract option which corresponds to the given parameter type."),(0,s.kt)("p",null,"The parameter is ",(0,s.kt)("inlineCode",{parentName:"p"},"unit")," in case of an implicit account."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction considers the default entrypoint if it exists, otherwise the full parameter is returned. "),(0,s.kt)("h4",{id:"transfer_tokens"},"TRANSFER_TOKENS"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction forges a transaction. In Michelson, the ",(0,s.kt)("inlineCode",{parentName:"p"},"operation")," type represents a transaction.\nForging a transaction requires the following to be specified: "),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the ",(0,s.kt)("em",{parentName:"li"},"parameter")," (i.e. the entrypoint expected by the targeted contract)"),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("em",{parentName:"li"},"quantity of mutez")," transferred by this transaction"),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("em",{parentName:"li"},"recipient contract")," representing the target of the transaction (i.e. to which contract this transaction will be sent)")),(0,s.kt)("p",null,"The parameter must be consistent with the one expected by the contract.\nIf the transaction is sent to an implicit account (i.e. the address of an account) then the parameter must be set to ",(0,s.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction consumes the three top elements of the stack and outputs a transaction on top of the stack."),(0,s.kt)("p",null,"As seen in previous sections, the invocation of a Tezos smart contract produces a list of operations and a new storage state. In a smart contract, when using a ",(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction to forge a transaction the produced transaction must be included in the returned list of operations in order to be taken into account."),(0,s.kt)("p",null,"To illustrate the usage of the ",(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS"),' instruction, we will consider a simple "Counter" smart contract that can increment or decrement a value. We will create a second smart contract, "CounterCaller", which forges a transaction and sends it to the "Counter" smart contract using the ',(0,s.kt)("inlineCode",{parentName:"p"},"TRANSFER_TOKENS")," instruction."),(0,s.kt)("p",null,'The following smart contract demonstrates the implementation of the "Counter" smart contract.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or (int %decrement) (int %increment)) ;\nstorage int ;\ncode { DUP ;\n       CDR ;\n       SWAP ;\n       CAR ;\n       IF_LEFT { SWAP ; SUB } { ADD } ;\n       NIL operation ;\n       PAIR }\n")),(0,s.kt)("p",null,'The following smart contract demonstrates the implementation of the "CounterCaller" smart contract.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"parameter (or int int);\nstorage address;\ncode {\n       DUP;\n       DUP;\n       CDR;\n       CONTRACT (or int int);\n       IF_NONE\n              {DROP; NIL operation }\n              {\n                     SWAP;\n                     CAR;\n                     DIP {PUSH mutez 0};\n                     TRANSFER_TOKENS;\n                     DIP {NIL operation;};\n                     CONS;\n              };\n       DIP { CDR };\n       PAIR }\n")),(0,s.kt)("p",null,'Now, let\'s break down the execution of the "CounterCaller" smart contract:'),(0,s.kt)("p",null,"The following command simulates the invocation of the smart contract."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"tezos-client run script countercaller.tz on storage '\"KT1HUbVyf62ZAp7BRqwQaDueb6kgb7Q86cc3\"' and input 'Left 3'\n")),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(6179).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 34: Illustration of the `TRANSFER_TOKENS` instruction"),(0,s.kt)("h4",{id:"set_delegate"},"SET_DELEGATE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SET_DELEGATE")," sets or withdraws the contract's delegation. It consumes an ",(0,s.kt)("em",{parentName:"p"},"option key_hash")," specifying the delegate and returns a transaction (operation) on top of the stack."),(0,s.kt)("p",null,"Using this instruction is the only way to modify the delegation of a smart contract. If the top element is ",(0,s.kt)("em",{parentName:"p"},"None"),", then the delegation of the current contract is withdrawn. If the top element is ",(0,s.kt)("em",{parentName:"p"},"Some kh"),", where ",(0,s.kt)("em",{parentName:"p"},"kh")," is the key hash of a registered delegate (that is not the current delegate of the contract), then this operation sets the delegate of the contract to this registered delegate. The operation fails if ",(0,s.kt)("em",{parentName:"p"},"kh")," is the current delegate of the contract or if ",(0,s.kt)("em",{parentName:"p"},"kh")," is not a registered delegate."),(0,s.kt)("h4",{id:"balance"},"BALANCE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"BALANCE")," instruction pushes the current amount of mutez held by the executing contract to the stack, including any mutez added by the calling transaction."),(0,s.kt)("h4",{id:"create_contract"},"CREATE_CONTRACT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction forges a new contract. It consumes the top three elements of the stack and pushes back a ",(0,s.kt)("em",{parentName:"p"},"transaction")," (responsible for creating the contract) and the ",(0,s.kt)("em",{parentName:"p"},"address")," of the newly created contract."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction expects as argument the smart contract definition as a literal ",(0,s.kt)("inlineCode",{parentName:"p"},"{ storage 'g ; parameter 'p ; code ... }"),", including the storage definition, parameter definition and the code of the smart contract."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CREATE_CONTRACT")," instruction expects three elements on top of the stack (these elements represent arguments for deploying a contract):"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the initial storage value for the new contract."),(0,s.kt)("li",{parentName:"ul"},"an optional ",(0,s.kt)("inlineCode",{parentName:"li"},"key_hash")," value representing the delegate"),(0,s.kt)("li",{parentName:"ul"},"a quantity of mutez transferred to the new contract")),(0,s.kt)("p",null,"Accessing the newly created contract (via a ",(0,s.kt)("inlineCode",{parentName:"p"},"CONTRACT 'p")," instruction) will fail until it is actually originated."),(0,s.kt)("p",null,'For example, here is an implementation of a "Factory" contract that create and deploys a "Counter" contract (as seen previsouly).'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"parameter unit;\nstorage unit;\ncode { DROP;\n       PUSH int 9;\n       PUSH mutez 0;\n       NONE key_hash;\n       CREATE_CONTRACT { parameter (or (int %decrement) (int %increment)) ; storage int ; code { DUP ; CDR ; SWAP ; CAR ; IF_LEFT { SWAP ; SUB } { ADD } ; NIL operation ; PAIR } };\n       DIP { NIL operation };\n       CONS;\n       DIP { DROP; UNIT };\n       PAIR }\n")),(0,s.kt)("p",null,"This smart contract can be simulated with the CLI command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"tezos-client run script factory.tz on storage 'Unit' and input 'Unit'\n")),(0,s.kt)("h3",{id:"built-ins"},"Built-ins"),(0,s.kt)("h4",{id:"address"},"ADDRESS"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ADDRESS")," instruction casts the contract to its address. It consumes a contract on top of the stack and pushes back the address of the contract."),(0,s.kt)("h4",{id:"source"},"SOURCE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SOURCE")," instruction pushes the address of the contract that initiated the current transaction, i.e. the contract that paid the fees and storage cost, and whose manager signed the operation that was sent on the blockchain. Note that since the TRANSFER_TOKENS instructions can be chained, ",(0,s.kt)("inlineCode",{parentName:"p"},"SOURCE")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"SENDER")," are not necessarily the same."),(0,s.kt)("h4",{id:"sender"},"SENDER"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SENDER")," instruction pushes the address of the contract that initiated the current internal transaction. It may be the ",(0,s.kt)("inlineCode",{parentName:"p"},"SOURCE"),", but may also be different if the source sent an order to an intermediate smart contract, which then called the current contract."),(0,s.kt)("h4",{id:"self"},"SELF"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SELF")," instruction pushes the default entrypoint of a contract on top of the stack. This default entrypoint specifies the expected parameter type. "),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SELF 'p")," instruction allows to take a entrypoint name 'p as argument. In this case, it pushed the specified entrypoint on top of the stack. "),(0,s.kt)("h4",{id:"amount"},"AMOUNT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"AMOUNT")," instruction pushes the amount of mutez of the current transaction on top of the stack."),(0,s.kt)("h4",{id:"implicit_account"},"IMPLICIT_ACCOUNT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IMPLICIT_ACCOUNT")," instruction returns a default contract with the given public/private key pair. Any funds deposited in this contract can immediately be spent by the holder of the private key. This contract cannot execute Michelson code and will always exist on the blockchain."),(0,s.kt)("p",null,"The instruction pops a ",(0,s.kt)("em",{parentName:"p"},"key_hash")," from the top of the stack and pushes a ",(0,s.kt)("inlineCode",{parentName:"p"},"contract unit"),"."),(0,s.kt)("h4",{id:"chain_id"},"CHAIN_ID"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CHAIN_ID")," instruction pushes the chain identifier on top of the stack."),(0,s.kt)("h3",{id:"operations-on-bytes"},"Operations on bytes"),(0,s.kt)("p",null,"Bytes are used for serializing data in order to check signatures and to compute hashes on them. They can also be used to incorporate data from the untyped outside world."),(0,s.kt)("h4",{id:"pack"},"PACK"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"PACK")," instruction serializes a piece of data to its optimized binary representation."),(0,s.kt)("h4",{id:"unpack"},"UNPACK"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"UNPACK")," instruction de-serializes a piece of data, if valid. It returns an ",(0,s.kt)("em",{parentName:"p"},"option")," initialized to ",(0,s.kt)("em",{parentName:"p"},"None")," if the de-serialization is invalid, or an ",(0,s.kt)("em",{parentName:"p"},"option")," initialized to ",(0,s.kt)("em",{parentName:"p"},"Some")," if valid."),(0,s.kt)("h4",{id:"concat-1"},"CONCAT"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CONCAT")," instruction concatenates two byte sequences. It can also be applied to a list of byte sequences. It consumes a list of byte sequences and pushes the concatenation of all sequences (in the respective order). "),(0,s.kt)("h4",{id:"size-4"},"SIZE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SIZE")," instruction computes the size of a sequence of bytes. It consumes a byte sequence and pushes the number of bytes of this sequence."),(0,s.kt)("h4",{id:"slice-1"},"SLICE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SLICE")," instruction provides a way to retrieve a part of a byte sequence.\nIt expects the following elements on top of the stack:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"an ",(0,s.kt)("inlineCode",{parentName:"li"},"offset"),", indicating the beginning of the byte sequence "),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("inlineCode",{parentName:"li"},"length"),", indicating the size of the sub-sequence"),(0,s.kt)("li",{parentName:"ul"},"a ",(0,s.kt)("inlineCode",{parentName:"li"},"byte sequence")," to slice")),(0,s.kt)("p",null,"It returns an optional byte sequence because the given offset and length may be out of bound."),(0,s.kt)("h4",{id:"compare-3"},"COMPARE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction computes a lexicographic comparison. As with other ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instructions, it returns 1 if the first sequence is bigger than the second sequence, 0 if both byte sequences are equal, or -1 otherwise."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction can be used only on comparable types."),(0,s.kt)("h3",{id:"crypto-primitives"},"Crypto primitives"),(0,s.kt)("h4",{id:"hash_key"},"HASH_KEY"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"HASH_KEY")," instruction computes the ",(0,s.kt)("em",{parentName:"p"},"b58check")," of a public key."),(0,s.kt)("p",null,"It consumes a key and pushes back a ",(0,s.kt)("em",{parentName:"p"},"key_hash"),"."),(0,s.kt)("h4",{id:"blake2b"},"BLAKE2B"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"BLAKE2B")," instruction computes a cryptographic hash of the value contents using the ",(0,s.kt)("em",{parentName:"p"},"Blake2b-256")," cryptographic hash function."),(0,s.kt)("p",null,"It consumes a byte sequence and pushes back the computed ",(0,s.kt)("em",{parentName:"p"},"Blake2b-256")," hash of this byte sequence."),(0,s.kt)("h4",{id:"sha256"},"SHA256"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SHA256")," instruction computes a cryptographic hash of the value contents using the ",(0,s.kt)("em",{parentName:"p"},"Sha256")," cryptographic hash function."),(0,s.kt)("p",null,"It consumes a byte sequence and pushes back the computed ",(0,s.kt)("em",{parentName:"p"},"Sha256")," of this byte sequence."),(0,s.kt)("h4",{id:"sha512"},"SHA512"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SHA512")," instruction computes a cryptographic hash of the value contents using the ",(0,s.kt)("em",{parentName:"p"},"Sha512")," cryptographic hash function."),(0,s.kt)("p",null,"It consumes a byte sequence and pushes back the computed ",(0,s.kt)("em",{parentName:"p"},"Sha512")," of this byte sequence."),(0,s.kt)("h4",{id:"check_signature"},"CHECK_SIGNATURE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"CHECK_SIGNATURE")," instruction checks that a sequence of bytes has been signed with a given key."),(0,s.kt)("p",null,"It consumes the top three elements of the stack (a byte sequence, a key and a signature) and pushes a boolean. "),(0,s.kt)("h4",{id:"compare-4"},"COMPARE"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction compares values of type ",(0,s.kt)("inlineCode",{parentName:"p"},"key_hash"),". "),(0,s.kt)("p",null,"As for other ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instructions, it returns 1 if the first ",(0,s.kt)("em",{parentName:"p"},"key_hash")," is bigger than than the second key_hash, 0 if the both ",(0,s.kt)("em",{parentName:"p"},"key_hash")," values are equal, and -1 otherwise."),(0,s.kt)("h3",{id:"macros-and-syntactic-sugar"},"Macros and syntactic sugar"),(0,s.kt)("p",null,"Since Michelson is a low-level language, there are some basic combinations of instructions that are regularly used. In order to ease the implementation and reduce the number of instructions of a smart contract, some macros and syntactic sugars have been introduced."),(0,s.kt)("p",null,"Syntactic sugar exists for merging the ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction with comparison combinators, and also for branching."),(0,s.kt)("p",null,"Syntactic sugar exists for merging the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," instruction with specific data types, and also for branching."),(0,s.kt)("h4",{id:"cmpeqneqltgtlege-macro"},"CMP{EQ|NEQ|LT|GT|LE|GE} macro"),(0,s.kt)("p",null,"This macro combines a ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction with a basic comparison."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"CMP(\\op) / S  =>  COMPARE ; (\\op) / S\n")),(0,s.kt)("h4",{id:"ifeqneqltgtlege-bt-bf-macro"},"IF{EQ|NEQ|LT|GT|LE|GE} bt bf macro"),(0,s.kt)("p",null,"This macro combines a basic comparison with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction. As with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction, it requires two sequences of instructions (",(0,s.kt)("em",{parentName:"p"},"bt")," and ",(0,s.kt)("em",{parentName:"p"},"bf"),")."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"IF(\\op) bt bf / S  =>  (\\op) ; IF bt bf / S\n")),(0,s.kt)("h4",{id:"ifcmpeqneqltgtlege-bt-bf-macro"},"IFCMP{EQ|NEQ|LT|GT|LE|GE} bt bf macro"),(0,s.kt)("p",null,"This macro combines a ",(0,s.kt)("inlineCode",{parentName:"p"},"COMPARE")," instruction with a basic comparison and an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction. As with an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction, it requires two sequences of instructions (",(0,s.kt)("em",{parentName:"p"},"bt")," and ",(0,s.kt)("em",{parentName:"p"},"bf"),")."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"IFCMP(\\op) / S  =>  COMPARE ; (\\op) ; IF bt bf / S\n")),(0,s.kt)("h4",{id:"assert-macro"},"ASSERT macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF")," instruction and a ",(0,s.kt)("inlineCode",{parentName:"p"},"FAIL")," instruction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT  =>  IF {} {FAIL}\n")),(0,s.kt)("p",null,"Notice that the first sequence of instructions is empty, meaning that it either fails or does nothing."),(0,s.kt)("h4",{id:"assert_eqneqltlegtge-macro"},"ASSERT_{EQ|NEQ|LT|LE|GT|GE} macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro with a basic comparison."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_(\\op)  =>  IF(\\op) {} {FAIL}\n")),(0,s.kt)("h4",{id:"assert_cmpeqneqltlegtge-macro"},"ASSERT_CMP{EQ|NEQ|LT|LE|GT|GE} macro"),(0,s.kt)("p",null,"This macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IFCMP")," macro with the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_CMP(\\op)  =>  IFCMP(\\op) {} {FAIL}\n")),(0,s.kt)("h4",{id:"assert_none-macro"},"ASSERT_NONE macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT_NONE")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," macro with the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_NONE  =>  IF_NONE {} {FAIL}\n")),(0,s.kt)("h4",{id:"assert_some-macro"},"ASSERT_SOME macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT_SOME")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," macro with the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_SOME @x =>  IF_NONE {FAIL} {RENAME @x}\n")),(0,s.kt)("p",null,"Notice that this macro uses the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction and not the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_SOME")," instruction."),(0,s.kt)("h4",{id:"assert_left-macro"},"ASSERT_LEFT macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT_LEFT")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction with the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_LEFT @x =>  IF_LEFT {RENAME @x} {FAIL}\n")),(0,s.kt)("h4",{id:"assert_right-macro"},"ASSERT_RIGHT macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT_RIGHT")," macro combines an ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," instruction with the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT")," macro. Notice that instruction sequences are inverted compared to the ",(0,s.kt)("inlineCode",{parentName:"p"},"ASSERT_LEFT")," macro."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"ASSERT_RIGHT @x =>  IF_LEFT {FAIL} {RENAME @x}\n")),(0,s.kt)("h4",{id:"dup-n-macro"},"DUP n macro"),(0,s.kt)("p",null,"These macros are simply more syntactically convenient for various common operations."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"DUP n")," macro is a syntactic sugar for duplicating the n-th element of the stack."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"DUP 1 / S  =>  DUP / S\nDUP 2 / S  =>  DIP (DUP) ; SWAP / S\nDUP (n+1) / S  =>  DIP n (DUP) ; DIG (n+1) / S\n")),(0,s.kt)("h4",{id:"nested-pair-macro"},"Nested PAIR macro"),(0,s.kt)("p",null,"Data structures may become complex in case of nested pairs. The\n",(0,s.kt)("inlineCode",{parentName:"p"},"P(\\left=A|P(\\left)(\\right))(\\right=I|P(\\left)(\\right))R")," macro is a syntactic sugar for building nested pairs."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"PA(\\right)R / S => DIP ((\\right)R) ; PAIR / S\nP(\\left)IR / S => (\\left)R ; PAIR / S\nP(\\left)(\\right)R =>  (\\left)R ; DIP ((\\right)R) ; PAIR / S\n")),(0,s.kt)("p",null,"A good way to quickly figure out which macro to use is to mentally parse the macro as ",(0,s.kt)("em",{parentName:"p"},"P")," for the pair constructor, ",(0,s.kt)("em",{parentName:"p"},"A")," for the left leaf and ",(0,s.kt)("em",{parentName:"p"},"I")," for the right leaf. The macro takes as many elements from the stack as there are leaves and constructs a nested pair with the shape given by its name."),(0,s.kt)("p",null,"Take the macro ",(0,s.kt)("em",{parentName:"p"},"PAPPAIIR")," for instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"P A  P P A  I    I R\n( l, ( ( l, r ), r ))\n")),(0,s.kt)("p",null,"A typing rule can be inferred:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"PAPPAIIR\n:: 'a : 'b : 'c : 'd : 'S  ->  (pair 'a (pair (pair 'b 'c) 'd))\n")),(0,s.kt)("h4",{id:"nested-unpair-macro"},"Nested UNPAIR macro"),(0,s.kt)("p",null,"Data structures may become complex in case of nested pairs. The ",(0,s.kt)("inlineCode",{parentName:"p"},"UNP(\\left=A|P(\\left)(\\right))(\\right=I|P(\\left)(\\right))R")," is a syntactic sugar for destructing nested pairs. These macros follow the same convention as the previous one."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"UNPAIR / S => DUP ; CAR ; DIP { CDR } / S\nUNPA(\\right)R / S => UNPAIR ; DIP (UN(\\right)R) / S\nUNP(\\left)IR / S => UNPAIR ; UN(\\left)R / S\nUNP(\\left)(\\right)R => UNPAIR ; DIP (UN(\\right)R) ; UN(\\left)R / S\n")),(0,s.kt)("h4",{id:"cadr-macro"},"C","[AD]","+R macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"C[AD]+R")," macro is a syntactic sugar for accessing fields in nested pairs."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"CA(\\rest=[AD]+)R / S  =>  CAR ; C(\\rest)R / S\nCD(\\rest=[AD]+)R / S  =>  CDR ; C(\\rest)R / S\n")),(0,s.kt)("p",null,'For example, in order to access the "sub" part of the above nested pair, the macro ',(0,s.kt)("inlineCode",{parentName:"p"},"CADR")," can be used, which is equivalent to ",(0,s.kt)("inlineCode",{parentName:"p"},"{ CAR; CDR }"),"."),(0,s.kt)("p",null,(0,s.kt)("img",{src:n(4200).Z})),(0,s.kt)("small",{className:"figure"},"FIGURE 35: Illustration of the C[AD]+R macro"),(0,s.kt)("h4",{id:"if_some-macro"},"IF_SOME macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_SOME bt bf")," macro inspects an ",(0,s.kt)("em",{parentName:"p"},"option")," value, like the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_NONE")," instruction with inverted sequences of instruction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"IF_SOME bt bf / S  =>  IF_NONE bf bt / S\n")),(0,s.kt)("h4",{id:"if_right-macro"},"IF_RIGHT macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_RIGHT bt bf")," macro inspects an ",(0,s.kt)("em",{parentName:"p"},"option")," value, like the ",(0,s.kt)("inlineCode",{parentName:"p"},"IF_LEFT")," with inverted sequences of instruction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"IF_RIGHT bt bf / S  =>  IF_LEFT bf bt / S\n")),(0,s.kt)("h4",{id:"set_cadr-macro"},"SET_C{A|D}R macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SET_CAR")," sets the left field of a pair. It combines the ",(0,s.kt)("inlineCode",{parentName:"p"},"CDR"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"SWAP")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"PAIR")," instructions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"SET_CAR  =>  CDR ; SWAP ; PAIR\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SET_CDR")," sets the right field of a pair. It combines the ",(0,s.kt)("inlineCode",{parentName:"p"},"CAR")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"PAIR")," instructions."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"SET_CDR  =>  CAR ; PAIR\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"SET_C[AD]+R")," macro is a syntactic sugar for setting fields in nested pairs."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"SET_CA(\\rest=[AD]+)R / S   =>\n    { DUP ; DIP { CAR ; SET_C(\\rest)R } ; CDR ; SWAP ; PAIR } / S\nSET_CD(\\rest=[AD]+)R / S   =>\n    { DUP ; DIP { CDR ; SET_C(\\rest)R } ; CAR ; PAIR } / S\n")),(0,s.kt)("h4",{id:"map_cadr-macro"},"MAP_C{A|D}R macro"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP_CAR code"),' macro transforms the left field of a pair. It applies the "code" sequence on the left field of a pair.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"MAP_CAR code  =>  DUP ; CDR ; DIP { CAR ; code } ; SWAP ; PAIR\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP_CDR code"),' macro transforms the right field of a pair. It applies the "code" sequence on the right field of a pair.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"MAP_CDR code  =>  DUP ; CDR ; code ; SWAP ; CAR ; PAIR\n")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"MAP_C[AD]+R code")," is a syntactic sugar for transforming fields in nested pairs."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"MAP_CA(\\rest=[AD]+)R code / S   =>\n    { DUP ; DIP { CAR ; MAP_C(\\rest)R code } ; CDR ; SWAP ; PAIR } / S\nMAP_CD(\\rest=[AD]+)R code / S   =>\n    { DUP ; DIP { CDR ; MAP_C(\\rest)R code } ; CAR ; PAIR } / S\n")),(0,s.kt)("h3",{id:"annotations"},"Annotations"),(0,s.kt)("p",null,"Michelson's annotation mechanism provides ways to better track data on the stack and give additional type constraints. Annotations are only here to add constraints, i.e. they cannot turn an otherwise rejected program into an accepted one. The notable exception to this rule is for entrypoints: the semantics of the ",(0,s.kt)("inlineCode",{parentName:"p"},"CONTRACT")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"SELF")," instructions vary depending on their constructor annotations, and some contract origination may fail due to invalid entrypoint constructor annotations."),(0,s.kt)("p",null,"Stack visualization tools, like the Michelson Emacs mode, print annotations associated with each type in the program, as propagated by the type checker as well as variable annotations on the types of elements in the stack. This is especially useful for debugging."),(0,s.kt)("p",null,"We distinguish three kinds of annotations:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"type annotations"),", written ",(0,s.kt)("inlineCode",{parentName:"li"},":type_annot")," ")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"(pair :point (int :x_pos) (int :y_pos))\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"variable annotations"),", written ",(0,s.kt)("inlineCode",{parentName:"li"},"@var_annot"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"(prim @v :t %x arg1 arg2 ...)\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"field annotations")," or constructors annotations, written ",(0,s.kt)("inlineCode",{parentName:"li"},"%field_annot"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"(or :t\n    (int %A)\n    (or\n       (bool %B)\n       (pair %C\n             (nat %n1)\n             (nat %n2))))\n")),(0,s.kt)("p",null,"Please visit the ",(0,s.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/007/michelson.html"},"reference pages")," for more detail about annotations in the Michelson language."))}c.isMDXComponent=!0},6179:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_example_transfertoken_execution-1e728baa011cb9db29a3da35c5063b08.svg"},3541:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_add_example-938944ba9bd680b6fc511043a9f61fdd.svg"},3026:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_and_example-2fd12cc90ac9f9e196e32ebbde1b449f.svg"},8771:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_car_example-5aab635921f5fc0da71b5dd5ad5b72b9.svg"},1675:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_cdr_example-b3a0b33e8bb879111b621a676e0c1bca.svg"},2990:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_compare_example-e697aa4e8764e371664efa7ac5b87350.svg"},2472:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_cons_example-72004d345be8eef54baf5d4a6ee62904.svg"},7325:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dig_example-0c1f6744d93fa7c896ec6bfc70181417.svg"},9667:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dip_example-1b840feb7826991e288d1019d0dfc10e.svg"},4946:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_drop_example-504b5a7eadac4a84353f9d079dc0e137.svg"},1331:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dug_example-a4bcecd1511e67965798974cb42ddf03.svg"},5470:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_dup_example-f2a97d8c62fc429aff0dca5370d989aa.svg"},9640:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ediv_example-affff443b53a6bd499435337c1ed0b6a.svg"},9465:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_eq_example-ebb295907a9f28c40cbf50c232e0ed70.svg"},8280:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ge_example-a14f4b60a347c7e727dd004afbaefe39.svg"},5552:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_if_example-e6a11542d1bec6f3086bc2b89fcb25d0.svg"},2841:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifleft_left_example-4be764b370901ac4c41804b7c62bee2f.svg"},1077:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifleft_right_example-24b5d95ac17997958bdf0411855b54c0.svg"},6702:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifnone_none_example-f162286deb209c962f0b4220843d3f51.svg"},4668:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_ifnone_some_example-1583eb394f815c74940d8c5a832517d3.svg"},1618:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_lt_example-58fd600baee81824b269075e056106ea.svg"},9765:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mapinsert_example-bf78e54704a2a5bf367f5cbba30d23bf.svg"},6016:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mapremove_example-c398367edc01b4738fcfe4898af9fb64.svg"},803:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_mul_example-427e0664e857a85a48e31282eb8daefa.svg"},1658:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_nillist_example-e14ad579e2909d07424acb3297cef796.svg"},9328:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_or_example-8c499ecad23c5af1da00b089eead699f.svg"},2749:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_pair_example-01992fc3a497d3da819622acf23421b1.svg"},7977:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_push_example-212622adb38ae9bcbe26ab899c65d5d7.svg"},2365:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_slice_example-e6cd513819ba4cc66ee7f3f0687ae904.svg"},1254:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_sub_example-4a0e1da09f0dd54089302c43f8dc4f13.svg"},6319:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_swap_example-f8ab1903def5f30ecaa8a953a0790027.svg"},8665:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_updatesetinsert_example-fb43a4f5d1e08e0d3c9bee5d40e1e89e.svg"},2716:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_updatesetremove_example-4c3a938c8048ccc2eb3839835a6a770d.svg"},926:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_instruction_xor_example-1462803c39d1fea62b796fa579ca0587.svg"},4200:function(e,t,n){"use strict";t.Z=n.p+"assets/images/michelson_macro_C[AD]+R_example-406d9ded47e46d42e62de8fc60e22d18.svg"}}]);