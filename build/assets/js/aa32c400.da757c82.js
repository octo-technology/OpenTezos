(self.webpackChunkopentezos=self.webpackChunkopentezos||[]).push([[2952],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6330:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},metadata:function(){return r},toc:function(){return l},default:function(){return p}});var a=n(2122),i=n(9756),o=(n(7294),n(3905)),s={id:"language-basics",title:"Language basics",authors:"Maxime Sallerin and Benjamin Pilia"},r={unversionedId:"ligo/language-basics",id:"ligo/language-basics",isDocsHomePage:!1,title:"Language basics",description:"In this chapter, all the following examples will use the PascaLigo syntax.",source:"@site/docs/ligo/language-basics.md",sourceDirName:"ligo",slug:"/ligo/language-basics",permalink:"/ligo/language-basics",editUrl:"https://github.com/octo-technology/OpenTezos/tree/main/docs/ligo/language-basics.md",version:"current",lastUpdatedBy:"frankhillard",lastUpdatedAt:1623846789,formattedLastUpdatedAt:"6/16/2021",frontMatter:{id:"language-basics",title:"Language basics",authors:"Maxime Sallerin and Benjamin Pilia"},sidebar:"docs",previous:{title:"Smart contract development in PascaLIGO",permalink:"/ligo/write-contracts-ligo"},next:{title:"Smart Contract",permalink:"/ligo/deploy-a-contract"}},l=[{value:"Built-in types",id:"built-in-types",children:[]},{value:"Type aliases",id:"type-aliases",children:[]},{value:"Structured types (Record example)",id:"structured-types-record-example",children:[]},{value:"Constants",id:"constants",children:[]},{value:"Variables",id:"variables",children:[]},{value:"Addition",id:"addition",children:[]},{value:"Subtraction",id:"subtraction",children:[]},{value:"Multiplication",id:"multiplication",children:[]},{value:"Division",id:"division",children:[]},{value:"Modulo",id:"modulo",children:[]},{value:"Casting",id:"casting",children:[]},{value:"Checking a nat",id:"checking-a-nat",children:[]},{value:"Concatenating strings",id:"concatenating-strings",children:[]},{value:"Slicing strings",id:"slicing-strings",children:[]},{value:"Length of strings",id:"length-of-strings",children:[]},{value:"Blockless functions",id:"blockless-functions",children:[]},{value:"Anonymous functions (a.k.a. lambdas)",id:"anonymous-functions-aka-lambdas",children:[]},{value:"Recursive function",id:"recursive-function",children:[]},{value:"Booleans",id:"booleans",children:[]},{value:"Comparing values",id:"comparing-values",children:[{value:"Comparing strings",id:"comparing-strings",children:[]},{value:"Comparing numbers",id:"comparing-numbers",children:[]},{value:"Comparing tez",id:"comparing-tez",children:[]}]},{value:"Conditionals",id:"conditionals",children:[]},{value:"Tuples",id:"tuples",children:[{value:"Defining tuples",id:"defining-tuples",children:[]},{value:"Accessing components",id:"accessing-components",children:[]},{value:"Update components",id:"update-components",children:[]}]},{value:"Lists",id:"lists",children:[{value:"Defining lists",id:"defining-lists",children:[]},{value:"Adding to lists",id:"adding-to-lists",children:[]},{value:"Accessing list element",id:"accessing-list-element",children:[]}]},{value:"Sets",id:"sets",children:[{value:"Defining sets",id:"defining-sets",children:[]},{value:"Sets tools",id:"sets-tools",children:[]}]},{value:"Records",id:"records",children:[{value:"Defining records",id:"defining-records",children:[]},{value:"Accessing record fields",id:"accessing-record-fields",children:[]},{value:"Updating a record",id:"updating-a-record",children:[]}]},{value:"Maps",id:"maps",children:[{value:"Defining a map",id:"defining-a-map",children:[]},{value:"Accessing map bindings",id:"accessing-map-bindings",children:[]},{value:"Updating a Map",id:"updating-a-map",children:[]}]},{value:"While loops",id:"while-loops",children:[]},{value:"For loops",id:"for-loops",children:[]},{value:"Iterations",id:"iterations",children:[]},{value:"Unit type",id:"unit-type",children:[]},{value:"Variant type",id:"variant-type",children:[]},{value:"Pattern Matching",id:"pattern-matching",children:[]},{value:"Option type",id:"option-type",children:[]},{value:"Timestamps",id:"timestamps",children:[]},{value:"Addresses",id:"addresses",children:[]},{value:"Main function",id:"main-function",children:[]},{value:"Entrypoints",id:"entrypoints",children:[]},{value:"A few Built-ins",id:"a-few-built-ins",children:[]},{value:"Failwith",id:"failwith",children:[]},{value:"Access Control",id:"access-control",children:[]},{value:"Transactions",id:"transactions",children:[]},{value:"Interactions",id:"interactions",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],c={toc:l};function p(e){var t=e.components,s=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this chapter, all the following examples will use the PascaLigo syntax."),(0,o.kt)("h1",{id:"types"},"Types"),(0,o.kt)("p",null,"LIGO is a strongly and statically typed language. This means that the compiler can checks how your contract processes data,\nto ensure that each function's expectations are met.\nIf it passes the test, your contract will not fail during run-time due to some inconsistent assumptions in your data.\nThis is called type checking."),(0,o.kt)("p",null,"LIGO types are built on top of Michelson's type system."),(0,o.kt)("h2",{id:"built-in-types"},"Built-in types"),(0,o.kt)("p",null,"LIGO comes with some basic built-in types like ",(0,o.kt)("em",{parentName:"p"},"string"),", ",(0,o.kt)("em",{parentName:"p"},"int")," or ",(0,o.kt)("em",{parentName:"p"},"tez")," (for account balance or monetary transactions).\nYou can find all of the built-in types on the ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/-/tree/dev#L35"},"LIGO gitlab"),"."),(0,o.kt)("h2",{id:"type-aliases"},"Type aliases"),(0,o.kt)("p",null,"Type aliasing consists of renaming a given type when the context calls for a more precise name.\nThis increases the readability and maintainability of your smart contracts.\nFor example, we can choose to alias a ",(0,o.kt)("em",{parentName:"p"},"string")," type as an animal breed; this will allow us to communicate our intent with added clarity."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type breed is string\nconst dog_breed : breed = "Saluki"\n')),(0,o.kt)("h2",{id:"structured-types-record-example"},"Structured types (Record example)"),(0,o.kt)("p",null,"Often contracts require complex data structures,\nwhich in turn require the use of well-typed storage or functions to work with.\nLIGO offers a simple way to compose simple types into structured types."),(0,o.kt)("p",null,"The first of those structured types is the ",(0,o.kt)("em",{parentName:"p"},"record"),",\nwhich aggregates types as fields and indexes them with a field name.\nIn the example below, you can see the definition of data types\nfor a ledger that keeps the balance and the number of the previous transactions of a given account."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type account is record [\n  balance : tez;\n  transactions : nat\n]\n\nconst my_account : account = record [\n    balance = 10mutez;\n    transactions = 5n\n  ]\n")),(0,o.kt)("p",null,"We will look more deeply into the ",(0,o.kt)("inlineCode",{parentName:"p"},"record")," construct in the following chapters."),(0,o.kt)("h1",{id:"constants--variables"},"Constants & Variables"),(0,o.kt)("h2",{id:"constants"},"Constants"),(0,o.kt)("p",null,"Constants are immutable by design, which means their values cannot be reassigned.\nPut in another way, they can only be assigned once, at their declaration.\nWhen defining a constant you need to provide a name, a type and a value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const age : int = 25\n")),(0,o.kt)("h2",{id:"variables"},"Variables"),(0,o.kt)("p",null,"Variables, unlike constants, are mutable.\nThey cannot be declared in a global scope, but they can be declared and used within functions,\nor as function parameters."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var c: int := 2 + 3\nc := c - 3\n")),(0,o.kt)("p",null,"\u26a0\ufe0f Notice the assignment operator ",(0,o.kt)("strong",{parentName:"p"},":=")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"var"),", instead of ",(0,o.kt)("strong",{parentName:"p"},"=")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"const"),"."),(0,o.kt)("h1",{id:"maths-numbers--tez"},"Maths, Numbers & Tez"),(0,o.kt)("p",null,"LIGO offers four built-in numerical types:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"int")," are integers, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"10"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"-6")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nat")," are natural numbers (integral numbers greater than or equal to zero).\nThey are followed by the suffix ",(0,o.kt)("strong",{parentName:"li"},"n")," such as ",(0,o.kt)("inlineCode",{parentName:"li"},"3n"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"12n")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"0n")," for the natural zero."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tez")," are units of measure of Tezos tokens. They can be decimals and are followed by ",(0,o.kt)("strong",{parentName:"li"},"tez")," or ",(0,o.kt)("strong",{parentName:"li"},"tz")," such as ",(0,o.kt)("inlineCode",{parentName:"li"},"3tz")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"12.4tez"),".\nYou can also type units in millionths of tez, using the suffix ",(0,o.kt)("strong",{parentName:"li"},"mutez")," after a natural literal, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"1000mutez")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"0mutez"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"bytes")," are sequences of bytes, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"0x12e4"),".")),(0,o.kt)("p",null,"\u26a0\ufe0f Note that there are no floating-point types in LIGO because they are not deterministic in hardware modules."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Pro tip: you can use underscores for better readability when defining large\nnumbers:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const sum : tez = 100_000mutez\n"))),(0,o.kt)("h2",{id:"addition"},"Addition"),(0,o.kt)("p",null,"Additions in LIGO are accomplished by means of the ",(0,o.kt)("inlineCode",{parentName:"p"},"+")," infix\noperator. Some type constraints apply, for example, you cannot add a\nvalue of type ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," to a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// int + int yields int\nconst a : int = 5 + 10\n\n// nat + int yields int\nconst b : int = 5n + 10\n\n// tez + tez yields tez\nconst c : tez = 5mutez + 0.000_010tez\n\n//tez + int or tez + nat is invalid\n// const d : tez = 5mutez + 10n\n\n// two nats yield a nat\nconst e : nat = 5n + 10n\n\n// nat + int yields an int: invalid\n// const f : nat = 5n + 10;\n\nconst g : int = 1_000_000\n")),(0,o.kt)("h2",{id:"subtraction"},"Subtraction"),(0,o.kt)("p",null,"Subtractions look as follows."),(0,o.kt)("p",null,"\u26a0\ufe0f Even when subtracting two ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," values, the result is an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int = 5 - 10\n\n// Subtraction of two nats yields an int\nconst b : int = 5n - 2n\n\n// Therefore, the following is invalid\n// const c : nat = 5n - 2n\n\nconst d : tez = 5mutez - 1mutez\n")),(0,o.kt)("h2",{id:"multiplication"},"Multiplication"),(0,o.kt)("p",null,"You can multiply values of the same type, such as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int = 5 * 5\nconst b : nat = 5n * 5n\n\n// You can also multiply `nat` and `tez`\nconst c : tez = 5n * 5mutez\n")),(0,o.kt)("h2",{id:"division"},"Division"),(0,o.kt)("p",null,"In LIGO you can divide ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"tez"),". Here's how:"),(0,o.kt)("p",null,"\u26a0\ufe0f Remember that there are no floating-point numbers in LIGO so the ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," operator stands for integer division."),(0,o.kt)("p",null,"Therefore, the division of two ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," values results in a ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," value."),(0,o.kt)("p",null,"The division of a ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," value by a ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," value results in a ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int = 10 / 3\nconst b : nat = 10n / 3n\nconst c : nat = 10mutez / 3mutez\nconst d : tez = 10mutez / 2n\n")),(0,o.kt)("h2",{id:"modulo"},"Modulo"),(0,o.kt)("p",null,"LIGO also allows you to compute the remainder of a Euclidean division. In LIGO, it is a natural number."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int = 120\nconst b : int = 9\nconst rem1 : nat = a mod b  // 3\n")),(0,o.kt)("h2",{id:"casting"},"Casting"),(0,o.kt)("p",null,"You can ",(0,o.kt)("em",{parentName:"p"},"cast")," an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," to a ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," and vice versa. Here is how:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int = int (1n)\nconst b : nat = abs (1)\n")),(0,o.kt)("h2",{id:"checking-a-nat"},"Checking a nat"),(0,o.kt)("p",null,"You can check if a value is a ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," by using a predefined cast\nfunction ",(0,o.kt)("inlineCode",{parentName:"p"},"is_nat")," which accepts an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," value and returns an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),": if the\nresult is not ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),", then the provided integer was indeed a natural\nnumber."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const is_a_nat : option (nat) = is_nat (1)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type expresses whether there is a value of some type or none. The ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type will be explained later in this chapter ",(0,o.kt)("a",{parentName:"p",href:"#option-type"},"here"),"."),(0,o.kt)("h1",{id:"strings"},"Strings"),(0,o.kt)("p",null,"Strings are defined using the built-in ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," type as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const a : string = "Hello Captain Rogers"\n')),(0,o.kt)("h2",{id:"concatenating-strings"},"Concatenating strings"),(0,o.kt)("p",null,"Strings can be concatenated using the ",(0,o.kt)("inlineCode",{parentName:"p"},"^")," operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const name : string = "Captain Rogers"\nconst greeting : string = "Hello"\nconst full_greeting : string = greeting ^ " " ^ name\n')),(0,o.kt)("h2",{id:"slicing-strings"},"Slicing strings"),(0,o.kt)("p",null,"Strings can be sliced using a built-in function ",(0,o.kt)("inlineCode",{parentName:"p"},"String.sub")," which takes three parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an ",(0,o.kt)("strong",{parentName:"li"},"offset")," describing the index of the first character that will be copied. The index starts at ",(0,o.kt)("inlineCode",{parentName:"li"},"0n")),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("strong",{parentName:"li"},"length")," describing the number of characters that will be copied (starting from the given offset)"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("strong",{parentName:"li"},"string")," being sliced")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const name  : string = "Captain Rogers"\nconst rank : string = String.sub (0n, 7n, name) //Captain\nconst family_name : string = String.sub (8n, 6n, name) //Rogers\n')),(0,o.kt)("p",null,"\u26a0\ufe0f Notice that the offset and length of the slice are natural numbers."),(0,o.kt)("h2",{id:"length-of-strings"},"Length of strings"),(0,o.kt)("p",null,"The length of a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," value can be found using a built-in function ",(0,o.kt)("inlineCode",{parentName:"p"},"String.length")," as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const name : string = "Captain Rogers"\nconst length : nat = String.length (name) // length = 14\n')),(0,o.kt)("h1",{id:"functions"},"Functions"),(0,o.kt)("p",null,"LIGO functions are the basic building block of contracts.\nEach entrypoint of a contract is a function\nand each smart contract must have at least one ",(0,o.kt)("em",{parentName:"p"},"main")," function\nthat dispatches the control flow to other functions."),(0,o.kt)("p",null,"When calling a function,\nLIGO makes a copy of the arguments but also the environment variables.\nTherefore, any modification to these will not be reflected outside the scope of the function\nand will be lost if not explicitly returned by the function."),(0,o.kt)("p",null,"There are 2 types of functions in PascaLIGO, Block Functions and Blockless Functions:"),(0,o.kt)("h1",{id:"block-functions"},"Block functions"),(0,o.kt)("p",null,"In PascaLIGO, blocks allow for the sequential composition of instructions into an isolated scope.\nEach block needs to include at least one instruction."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"block { \n    const b : int = 10\n    a := a + b \n}\n")),(0,o.kt)("p",null,"If we need a placeholder, we use the instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"skip")," which leaves\nthe state unchanged.  The rationale for ",(0,o.kt)("inlineCode",{parentName:"p"},"skip")," instead of a truly\nempty block is that it prevents you from writing an empty block by\nmistake."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"block { skip }\n")),(0,o.kt)("p",null,"Functions using PascaLIGO are defined with the following syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function <name> (<parameters>) : <return_type> is \n  block {\n   <operations and instructions>\n  } with <returned_value>\n")),(0,o.kt)("p",null,"For instance :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function add (const a : int; const b : int) : int is\n  block {\n    const sum : int = a + b\n  } with sum\n")),(0,o.kt)("h2",{id:"blockless-functions"},"Blockless functions"),(0,o.kt)("p",null,"Functions that can contain all of their own logic into a single expression can be defined without the need for a block.\nThe add function above can be re-written as a blockless function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function add (const a: int; const b : int) : int is a + b\n")),(0,o.kt)("h2",{id:"anonymous-functions-aka-lambdas"},"Anonymous functions (a.k.a. lambdas)"),(0,o.kt)("p",null,"It is possible to define functions without assigning them a name.\nThis is useful when you want to pass them as arguments,\nor assign them to a key in a record or a map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function increment (const b : int) : int is\n   (function (const a : int) : int is a + 1) (b)\nconst a : int = increment (1); // a = 2\n")),(0,o.kt)("p",null,"If the example above seems contrived, here is a more common design pattern for lambdas:\nto be used as parameters to functions.\nConsider this use case of having a list of integers and mapping the increment function to all its elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function incr_map (const l : list (int)) : list (int) is\n  List.map (function (const i : int) : int is i + 1, l)\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'For the input "list ',"[1;2;3]",'" the output will be ',"[2;3;4]")),(0,o.kt)("h2",{id:"recursive-function"},"Recursive function"),(0,o.kt)("p",null,"LIGO functions are not recursive by default,\nthe user needs to, indicate that the function is recursive."),(0,o.kt)("p",null,"At the moment,\nrecursive functions are limited to one (possibly tupled) parameter\nand recursion is limited to tail recursion (i.e the recursive call should be the last expression of the function)"),(0,o.kt)("p",null,"In PascaLigo recursive functions are defined by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"recursive")," keyword."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"recursive function sum (const n : int; const acc: int) : int is\n  if n<1 then acc else sum(n-1,acc+n)\n")),(0,o.kt)("h1",{id:"booleans--conditionals"},"Booleans & Conditionals"),(0,o.kt)("h2",{id:"booleans"},"Booleans"),(0,o.kt)("p",null,"The type of a boolean value is ",(0,o.kt)("inlineCode",{parentName:"p"},"bool"),". Here is how to define a boolean\nvalue:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : bool = True   // Also: true\nconst b : bool = False  // Also: false\n")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"Operator"),(0,o.kt)("th",{parentName:"tr",align:null},"Example"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"and")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const logical_and: bool = True and True;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"or")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const logical_or: bool = False or True;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"not")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const logical_not: bool = not False;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"=")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const eq: bool = 2 = 3;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"=/=")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const not_eq: bool = 2 =/= 3;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},">")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const gt: bool = 4 > 3;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"<")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const lt: bool = 4 < 3;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},">=")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const gte: bool = 4 >= 3;"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("strong",{parentName:"td"},"<=")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"const lte: bool = 4 <= 3;"))))),(0,o.kt)("h2",{id:"comparing-values"},"Comparing values"),(0,o.kt)("p",null,"Only values of the same type can be natively compared,\ni.e. int, nat, string, tez, timestamp, address, etc. "),(0,o.kt)("p",null,"However some values of the same type are not natively comparable,\ni.e. maps, sets or lists.\nYou will have to write your own comparison functions for those values."),(0,o.kt)("h3",{id:"comparing-strings"},"Comparing strings"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const a : string = "Captain Rogers"\nconst b : string = "Captain Rogers"\nconst c : bool = (a = b) // True\n')),(0,o.kt)("h3",{id:"comparing-numbers"},"Comparing numbers"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : int  = 5\nconst b : int  = 4\nconst c : bool = (a = b)\nconst d : bool = (a > b)\nconst e : bool = (a < b)\nconst f : bool = (a <= b)\nconst g : bool = (a >= b)\nconst h : bool = (a =/= b)\n")),(0,o.kt)("h3",{id:"comparing-tez"},"Comparing tez"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const a : tez  = 5mutez\nconst b : tez  = 10mutez\nconst c : bool = (a = b) // False\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 Comparing the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," is especially useful when dealing with an amount sent, in a transaction.")),(0,o.kt)("h2",{id:"conditionals"},"Conditionals"),(0,o.kt)("p",null,"Conditional logic enables you to fork the control of the flow depending on the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function isSmall (const n : nat) : bool is\nif n < 10n then true else false\n")),(0,o.kt)("p",null,"\u26a0\ufe0f When the branches of the conditional are not a single expression, as above, we need a ",(0,o.kt)("inlineCode",{parentName:"p"},"block"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"if x < y then\nblock {\nx := x + 1;\ny := y - 1\n}\nelse skip;\n")),(0,o.kt)("h1",{id:"tuples-lists-sets"},"Tuples, lists, sets"),(0,o.kt)("h2",{id:"tuples"},"Tuples"),(0,o.kt)("p",null,"Tuples gather a given number of values in a specific order. Then, those values,\ncalled components,\ncan be retrieved by their index (position).\nProbably the most common tuple is the pair ",(0,o.kt)("inlineCode",{parentName:"p"},"(x,y)"),"."),(0,o.kt)("h3",{id:"defining-tuples"},"Defining tuples"),(0,o.kt)("p",null,"To define a tuple type, use the * operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type full_name is (string * string)\nconst captain_full_name : full_name = ("Roger", "Johnson")\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that you are not forced to give them names by type aliasing,\nand can do this instead:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const captain_full_name : (string * string) = ("Roger", "Johnson")\n'))),(0,o.kt)("h3",{id:"accessing-components"},"Accessing components"),(0,o.kt)("p",null,"You can access each component of a tuple by their position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const captain_first_name : string = captain_full_name.0\nconst captain_last_name : string = captain_full_name.1\n")),(0,o.kt)("p",null,"\u26a0\ufe0f Tuple components are zero-indexed, that is, the first component has the index ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("h3",{id:"update-components"},"Update components"),(0,o.kt)("p",null,"You can modify a component of a tuple by assigning values as if they were a variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'captain_full_name.1 := "Carter"\n')),(0,o.kt)("h2",{id:"lists"},"Lists"),(0,o.kt)("p",null,"Lists are ",(0,o.kt)("strong",{parentName:"p"},"linear collections of elements of the same type"),".\nLinear means that to reach an element in a list,\nwe must visit all the elements before (sequential access).\nElements can be repeated, as only their order in the collection matters.\nThe first element is called the head,\nand the sub-list after the head is called the tail."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 Lists are needed when returning operations from a smart contract's main function.")),(0,o.kt)("h3",{id:"defining-lists"},"Defining lists"),(0,o.kt)("p",null,"To define an empty list and a list with values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const empty_list : list (int) = list [] // Or nil\nconst my_list : list (int) = list [1; 2; 2]\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"nil")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"list []"))),(0,o.kt)("h3",{id:"adding-to-lists"},"Adding to lists"),(0,o.kt)("p",null,"You can add elements to an existing list using the cons operator ",(0,o.kt)("inlineCode",{parentName:"p"},"#")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"cons(<value>, <list>)"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const larger_list : list (int) = 5 # my_list // [5; 1; 2; 2]\nconst larger_list_bis : list (int) = cons(5, my_list) // [5; 1; 2; 2]\n")),(0,o.kt)("h3",{id:"accessing-list-element"},"Accessing list element"),(0,o.kt)("p",null,"You cannot access an element directly in a list,\nbut you can access the first element,\nthe head or the rest of the list, the tail.\nThe two functions to access those are ",(0,o.kt)("inlineCode",{parentName:"p"},"List.head_opt")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"List.tail_opt"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const head : option (int) = List.head_opt (my_list) // 1\nconst tail : option (list(int)) = List.tail_opt (my_list) // [2;2]\n")),(0,o.kt)("h2",{id:"sets"},"Sets"),(0,o.kt)("p",null,"Sets are ",(0,o.kt)("strong",{parentName:"p"},"unordered collections of values of the same type"),",\nunlike lists, which are ordered collections.\nLike the mathematical sets and lists,\nsets can be empty and, if not,\nthen the elements of the sets in LIGO are unique,\nbut they can be repeated in a list."),(0,o.kt)("h3",{id:"defining-sets"},"Defining sets"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const empty_set : set (int) = set []\nconst my_set : set (int) = set [3; 2; 2; 1]   // resulting set is [3; 2; 1] \n")),(0,o.kt)("h3",{id:"sets-tools"},"Sets tools"),(0,o.kt)("p",null,"You can test membership with the ",(0,o.kt)("inlineCode",{parentName:"p"},"contains")," operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const contains_3 : bool = my_set contains 3\n")),(0,o.kt)("p",null,"You can get the size of a set by using the Set.size operator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const cardinal : nat = Set.size (my_set)\n")),(0,o.kt)("p",null,"To update a set:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const larger_set  : set (int) = Set.add (4, my_set)\nconst smaller_set : set (int) = Set.remove (3, my_set)\n")),(0,o.kt)("h1",{id:"records--maps"},"Records & Maps"),(0,o.kt)("h2",{id:"records"},"Records"),(0,o.kt)("p",null,"Records are one-way data of different types that can be packed into a single type.\nA record is made of a set of fields, which are, in turn, made of a field name and a field type."),(0,o.kt)("h3",{id:"defining-records"},"Defining records"),(0,o.kt)("p",null,"To instantiate a record, you must first declare its type as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type user is\n  record [\n    id : nat;\n    is_admin : bool;\n    name : string\n  ]\n")),(0,o.kt)("p",null,"And here is how to define an associated record value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const rogers : user =\n  record [\n    id = 1n;\n    is_admin = true;\n    name = "Rogers"\n  ]\n')),(0,o.kt)("h3",{id:"accessing-record-fields"},"Accessing record fields"),(0,o.kt)("p",null,"You can access the contents of a given field with the ",(0,o.kt)("inlineCode",{parentName:"p"},".")," infix operator."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const rogers_admin : bool = roger.is_admin\n")),(0,o.kt)("h3",{id:"updating-a-record"},"Updating a record"),(0,o.kt)("p",null,"You can modify values in a record as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function change_name (const u : user) : user is\n  block {\n      const my_user : user = u with record [name = "Mark"]\n  } with my_user\n')),(0,o.kt)("p",null,"\u26a0\ufe0f Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," value ",(0,o.kt)("em",{parentName:"p"},"u")," (given as argument) has not been changed by the function."),(0,o.kt)("p",null,"You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," to modify the record:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function change_name (const u : user) : user is\n  block {\n      patch u with record [name = "Mark"]\n  } with u\n')),(0,o.kt)("h2",{id:"maps"},"Maps"),(0,o.kt)("p",null,"Maps are data structures that associate a value to a key, thus creating a key-value binding. All keys have the same type and all values have the same type.\nAn additional requirement is that the type of the keys must be comparable."),(0,o.kt)("h3",{id:"defining-a-map"},"Defining a map"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type balances is map (string, nat)\n\nconst empty : balances = map []\n\nconst user_balances : balances =\n    map [\n        "tim" -> 5n;\n        "mark" -> 0n\n    ]\n')),(0,o.kt)("h3",{id:"accessing-map-bindings"},"Accessing map bindings"),(0,o.kt)("p",null,"Use the postfix [] operator to read a value of the map:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const my_balance : option (nat) = user_balances ["tim"]\n')),(0,o.kt)("h3",{id:"updating-a-map"},"Updating a Map"),(0,o.kt)("p",null,"You can add or modify a value using the usual assignment syntax ",(0,o.kt)("inlineCode",{parentName:"p"},":=")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'user_balances ["tim"] := 2n\nuser_balances ["New User"] := 24n\n')),(0,o.kt)("p",null,"A key value can be removed from the mapping as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'remove "tim" from map user_balances\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Maps load their entries into the environment,\nwhich is fine for small maps,\nbut for larger maps holding millions of entries,\nthe cost would be too expensive.\nFor such cases we use ",(0,o.kt)("inlineCode",{parentName:"p"},"big_maps"),". Their syntax is the same as those of regular maps.")),(0,o.kt)("h1",{id:"loops"},"Loops"),(0,o.kt)("p",null,"LIGO integrates 2 kinds of loops. General ",(0,o.kt)("inlineCode",{parentName:"p"},"while")," iterations and bounded for ",(0,o.kt)("inlineCode",{parentName:"p"},"loops"),"."),(0,o.kt)("h2",{id:"while-loops"},"While loops"),(0,o.kt)("p",null,"While loops are defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"while <condition> block {\n    <operations>\n}\n")),(0,o.kt)("p",null,"For instance, here is how to compute the greatest common divisors of two natural numbers by means of Euclid's algorithm:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function gcd (var x : nat; var y : nat) : nat is\n  block {\n    if x < y then {\n      const z : nat = x;\n      x := y; y := z\n    }\n    else skip;\n    var r : nat := 0n;\n    while y =/= 0n block {\n      r := x mod y;\n      x := y;\n      y := r\n    }\n  } with x\n")),(0,o.kt)("p",null,"\u26a0\ufe0f If the 'while' condition is never met, the block will repeatedly be evaluated until the contract runs out of gas or fails."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u2139\ufe0f About gas: The smart contracts interpreter uses the concept of gas.\nEach evaluation of low-level instruction burns an amount of gas\nwhich is crafted to be proportional to the actual execution time\nand if an execution exceeds its allowed gas consumption,\nit is stopped immediately and the effects of the execution are rolled back.\nThe transaction is still included in the block and the fees are taken,\nto prevent the nodes from being spammed with failing transactions.\nIn Tezos, the economic protocol sets the gas limit per block and for each transaction,\nand the emitter of the transaction also set an upper limit to the gas consumption for its transaction.\nThe economic protocol does not require the transaction fee to be proportional to the gas upper bound,\nhowever the default strategy of the baking software (that forges blocks)\nde facto does require it.")),(0,o.kt)("h2",{id:"for-loops"},"For loops"),(0,o.kt)("p",null,"For-loops iterates, over bounded intervals and are defined as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"for <variable assignment> to <upper bound> block {\n    <operations>\n}\n")),(0,o.kt)("p",null,"For instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var acc : int := 0;\nfor i := 1 to 10 block {\n    acc := acc + i\n}\n")),(0,o.kt)("h2",{id:"iterations"},"Iterations"),(0,o.kt)("p",null,"For-loops can also iterate through the contents of a collection, that is, it can iterate with a list, a set or a map.\nThis is done with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"for <element var> in <collection type> <collection var> block {\n    <operations>\n}\n")),(0,o.kt)("p",null,"Here is an example where the integers are summed up in a list."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function sum_list (var l : list (int)) : int is block {\n  var total : int := 0;\n  for i in list l block {\n    total := total + i\n  }\n} with total\n")),(0,o.kt)("p",null,"Sets and maps follow the same logic:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"maps with ",(0,o.kt)("inlineCode",{parentName:"li"},"for key -> value in map m")),(0,o.kt)("li",{parentName:"ul"},"sets with ",(0,o.kt)("inlineCode",{parentName:"li"},"for i in set s"))),(0,o.kt)("h1",{id:"unit-variant--option"},"Unit, Variant & Option"),(0,o.kt)("h2",{id:"unit-type"},"Unit type"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," type in Michelson or LIGO is a predefined type\nthat contains only one value that carries no information.\nIt is used when no relevant information is required or produced.\nHere is how it used."),(0,o.kt)("p",null,"In PascaLIGO, the unique value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," type is ",(0,o.kt)("inlineCode",{parentName:"p"},"Unit"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const n : unit = Unit\n")),(0,o.kt)("h2",{id:"variant-type"},"Variant type"),(0,o.kt)("p",null,"A variant type is a user-defined or a built-in type (in case of options) that defines a type by cases,\nso the value of a variant type is either this, or that, or...\nThe simplest variant type is equivalent to the enumerated types, found in Java, C++, JavaScript etc."),(0,o.kt)("p",null,"Here is how we define a bit as being either 1 or 0 (and nothing else):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\nconst closed_switch : bit = One\nconst open_switch : bit = Zero\n")),(0,o.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,o.kt)("p",null,"Pattern matching is similar to the switch construct in Javascript,\nand can be used to route the program's controlled flow based on the value of a variant.\nConsider for example the definition of a power switch that turns a light on/off."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type bit is One | Zero\n\nfunction power_switch (const b : bit) : bit is\n  case b of\n    One -> Zero\n  | Zero -> One\n  end\n")),(0,o.kt)("h2",{id:"option-type"},"Option type"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type is a predefined variant type that is used to express whether\nthere is a value of some type or none.\nThis is especially useful when calling a partial function,\nthat is, a function that is not defined for some (specific) inputs.\nIn that case, the value of the option type would be ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),",\notherwise ",(0,o.kt)("inlineCode",{parentName:"p"},"Some (v)"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"v")," is some meaningful value of any type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function div (const a : nat; const b : nat) : option (nat) is\n  if b = 0n then (None: option (nat)) else Some (a/b)\n")),(0,o.kt)("p",null,"The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," can be used in pattern matching to retrieve the value behind the option variable.",(0,o.kt)("br",{parentName:"p"}),"\n","The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," can be used in pattern matching to verify that the option variable has no value."),(0,o.kt)("p",null,"Here is an example of a pattern matching resolving an option type directly\n(useful when we just want to retrieve the value behind the optional) :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const my_balance : expected_type = case user_balances[1n] of\n  Some (val) -> val\n| None -> (failwith ("Unknown user") : expected_type)\nend\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Notice the cast of the ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith")," instruction into an expected_type.",(0,o.kt)("br",{parentName:"p"}),"\n","The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith")," will be explained later in this chapter ",(0,o.kt)("a",{parentName:"p",href:"#failwith"},"here"),".")),(0,o.kt)("h1",{id:"timestamps-addresses"},"Timestamps, Addresses"),(0,o.kt)("h2",{id:"timestamps"},"Timestamps"),(0,o.kt)("p",null,"Timestamps are responsible for providing the current, given, timestamp for a contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const today : timestamp = Tezos.now\nconst one_day : int = 86_400\nconst in_24_hrs : timestamp = today + one_day\nconst some_date : timestamp = ("2000-01-01T10:10:10Z" : timestamp)\nconst one_day_later : timestamp = some_date + one_day\n')),(0,o.kt)("h2",{id:"addresses"},"Addresses"),(0,o.kt)("p",null,"You can define Tezos addresses by casting a string to an address type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const my_account : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address)\n')),(0,o.kt)("p",null,"\u26a0\ufe0f You will not see a compilation error if the address you enter is wrong, but the execution will fail."),(0,o.kt)("h1",{id:"main-function-and-entrypoints"},"Main function and Entrypoints"),(0,o.kt)("h2",{id:"main-function"},"Main function"),(0,o.kt)("p",null,"Smart contracts are small programs that are stored and executed on the blockchain.\nThey allow people to cooperate and exchange tokens without requiring them to trust one another."),(0,o.kt)("p",null,"A LIGO contract is made of a series of constant and function, declarations.\nOnly functions with a special type can be called when the contract is activated:\nwe call them ",(0,o.kt)("strong",{parentName:"p"},"main functions"),". A main function takes two parameters,\nthe ",(0,o.kt)("strong",{parentName:"p"},"contract parameter")," and the ",(0,o.kt)("strong",{parentName:"p"},"on-chain storage"),",\nand returns a pair made of a ",(0,o.kt)("strong",{parentName:"p"},"list of operations")," and a ",(0,o.kt)("strong",{parentName:"p"},"(new) storage"),"."),(0,o.kt)("br",null),(0,o.kt)("p",null,(0,o.kt)("img",{src:n(9784).Z})),(0,o.kt)("small",{className:"figure"},"FIGURE 1: Main function"),(0,o.kt)("br",null),(0,o.kt)("p",null,"The type of the contract parameter and the storage is up to the contract designer,\nbut the type for list operations is not."),(0,o.kt)("p",null,"The return type of a main function is as follows,\nassuming that the type ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," has been defined elsewhere."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type storage is ...  // Any name, any type\ntype return is list (operation) * storage\n")),(0,o.kt)("p",null,"The contract storage can only be modified by activating the main function:\nif given the state of the storage on-chain,\na main function specifies how to create another state for it,\ndepending on the contract's parameter."),(0,o.kt)("p",null,"Here is an example where the storage is a single natural number, updated by the parameter."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type parameter is nat\ntype storage is nat\ntype return is list (operation) * storage\n\nfunction save (const action : parameter; const store : storage) : return is\n  ((nil : list (operation)), store)\n")),(0,o.kt)("h2",{id:"entrypoints"},"Entrypoints"),(0,o.kt)("p",null,"In LIGO, the design pattern has one main function called ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),",\nthat dispatches the control flow according to its parameter.\nThe functions used for those actions are called entrypoints."),(0,o.kt)("p",null,"As an analogy, in the C programming language,\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function is the unique main function and any of the functions called from it would be an entrypoint."),(0,o.kt)("p",null,"The parameter of the contract is then a variant type,\nand, depending on the constructors of that type,\ndifferent functions in the contract are called.\nIn other terms, the unique main function dispatches the control flow\naccording to the pattern matching on the contract parameter."),(0,o.kt)("p",null,"In the following example,\nthe storage contains a counter of type ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," and a name of type ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),".\nDepending on the parameter of the contract, either the counter or the name is updated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type parameter is\n  Action_A of nat\n| Action_B of string\n\ntype storage is record [\n  counter : nat;\n  name    : string\n]\n\ntype return is list (operation) * storage\n\nfunction entry_A (const n : nat; const store : storage) : return is\n  ((nil : list (operation)), store with record [counter = n])\n\nfunction entry_B (const s : string; const store : storage) : return is\n  ((nil : list (operation)), store with record [name = s])\n\nfunction main (const action : parameter; const store : storage): return is\n  case action of\n    Action_A (n) -> entry_A (n, store)\n  | Action_B (s) -> entry_B (s, store)\n  end\n")),(0,o.kt)("h1",{id:"built-in"},"Built-in"),(0,o.kt)("h2",{id:"a-few-built-ins"},"A few Built-ins"),(0,o.kt)("p",null,"A LIGO smart contract can query parts of the state of the Tezos blockchain through the built-in values."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.balance"),": Gets the balance for the contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.amount"),": Gets the amount of tez provided by the sender to complete this transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.sender"),": Gets the address that initiated the current transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.self_address"),": Gets the address of the currently running contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.source"),": Gets the originator (address) of the current transaction.\nThat is, if a chain of transactions led to the current execution, it gets the address that began the chain.\nNot to be confused with Tezos.sender,\nwhich gives the address of the contract or user which directly caused the current transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.chain_id"),": Gets the identifier of the chain, to be able to distinguish between main and test chains.")),(0,o.kt)("h2",{id:"failwith"},"Failwith"),(0,o.kt)("p",null,"The keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith")," throws an exception and stop the execution of the smart contract."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"failwith(<string_message>)\n")),(0,o.kt)("h2",{id:"access-control"},"Access Control"),(0,o.kt)("p",null,"This example shows how Tezos.source can be used to deny access to an entrypoint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const owner : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx": address);\n\nfunction main (const action : parameter; const store : storage) : return is\n    if Tezos.source =/= owner then (failwith ("Access denied.") : return)\nelse ((nil : list (operation)), store)\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"<string_message>")," must be a ",(0,o.kt)("inlineCode",{parentName:"p"},"string value"))),(0,o.kt)("h1",{id:"transactions-and-interactions"},"Transactions and Interactions"),(0,o.kt)("h2",{id:"transactions"},"Transactions"),(0,o.kt)("p",null,"You can transfer an amount of ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," to an account, or to the function of another smart contract.\nFor this, use :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Tezos.transaction (<parameter>, <mutez>, <contract>);\n")),(0,o.kt)("p",null,"where :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"parameter")," is the entrypoint of another contract,\nor use ",(0,o.kt)("inlineCode",{parentName:"li"},"unit")," if you are transferring to a wallet address,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"mutez")," is the amount to transfer,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"contract")," is the contract interface of the targeted contract.\nIt can be retrieved from the address of the other contract or the wallet.")),(0,o.kt)("p",null,"Here is an example of how to send money to a wallet address."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function purchase (const purchase_price : tez) : bool is\nblock {\n    const ship_address : address = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" : address);\n    const vendor_address : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address);\n\n    if Tezos.source =/= ship_address then failwith ("Access denied");\n    if Tezos.amount =/= purchase_price then failwith ("Incorrect amount");\n\n    const vendor_contract : contract (unit) =\n      case (Tezos.get_contract_opt (vendor_address) : option (contract (unit))) of\n        Some (c) -> c\n      | None -> (failwith ("Contract not found.") : contract (unit))\n      end;\n    Tezos.transaction (unit, purchase_price, vendor_contract)\n} with True\n')),(0,o.kt)("h2",{id:"interactions"},"Interactions"),(0,o.kt)("p",null,"It is also possible to use ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.transaction")," to call an entrypoint from another contract.\nIn that case, we store the transaction in a type ",(0,o.kt)("inlineCode",{parentName:"p"},"operation"),"\nwhich is a predefined type representing a contract invocation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const <operation_name> : operation = Tezos.transaction (<parameter>, <mutez>, <contract>);\n")),(0,o.kt)("p",null,"To get the contract we want to call and its entry points, we can use:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Tezos.get_contract_opt(<address>)\n")),(0,o.kt)("p",null,"The function takes an address and returns an ",(0,o.kt)("strong",{parentName:"p"},"optional contract")," (remember to use ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),").\nWhen no contract is found, or if the contract doesn't match the type, ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," is returned."),(0,o.kt)("p",null,"Here is an example of how to use it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'type storage is unit\n\ntype parameter is\n  Fire of int\n| Stop\n\ntype return is list (operation) * storage\n\nconst right_laser_address : address = ("tz1fND4ejogxWN7HB5JKdz119A48Cp2eYKj9" : address)\nconst left_laser_address : address = ("tz1PVWEWDcuow9R6y5EFwcHbFNoZBZ9RjxaB" : address)\n\nfunction orders (const param : unit; const store : storage): return is\n  block {\n    const right_laser : contract (parameter) =\n      case (Tezos.get_contract_opt(right_laser_address) : option (contract (parameter))) of\n        Some (contract) -> contract\n      | None -> (failwith ("Contract not found.") : contract (parameter))\n      end;\n    const left_laser : contract (parameter) =\n      case (Tezos.get_contract_opt(left_laser_address) : option (contract (parameter))) of\n        Some (contract) -> contract\n      | None -> (failwith ("Contract not found.") : contract (parameter))\n      end;\n\n    const operations : list (operation) = list [\n        Tezos.transaction (Fire(5), 0tez, right_laser);\n        Tezos.transaction (Stop, 0tez, right_laser);\n        Tezos.transaction (Fire(5), 0tez, left_laser);\n        Tezos.transaction (Stop, 0tez, left_laser);\n    ]\n  } with (operations, store)\n\ntype action is Order | Nothing\n\nfunction main (const a : action; const s : storage) : return is\nblock { skip } with case a of\n      Order  -> orders(unit, s)\n    | Nothing -> ((nil: list(operation)), s)\nend\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"PascaLigo provides developers with all the necessary commands to write smart contracts. Thanks to a syntax close to other languages, it is possible for anyone to develop complex smart contracts without using the stack-based language Michelson. All the Michelson instructions have an equivalent in Ligo: comparisons, sending transactions, checking a sender address, handling amounts, calling other entrypoints..."),(0,o.kt)("p",null,"However, Michelson remains the Tezos smart contract language: Ligo compiles to Michelson code, that will be deployed onto the Blockchain."),(0,o.kt)("p",null,"Ligo is always improving: the Ligo team releases a new version every other week. It fixes bugs and adds functionalities, but it also may induce breaking changes. You can refer to the release notes ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/next/intro/changelog/"},"here"),"."))}p.isMDXComponent=!0},9784:function(e,t,n){"use strict";t.Z=n.p+"assets/images/main_function-def6ca332b38507cc42b237cc24c24fc.svg"}}]);