<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="OpenTezos Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="OpenTezos Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">Formal verification on smart contracts | OpenTezos</title><meta data-react-helmet="true" property="og:url" content="https://opentezos.com/formal-verification/modeling-theorem"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Formal verification on smart contracts | OpenTezos"><meta data-react-helmet="true" name="description" content="This section describes how to bridge the Tezos world (and the Michelson language) with the formal world of Coq. For this, we are going to model a theorem representing a smart contract and its intentions."><meta data-react-helmet="true" property="og:description" content="This section describes how to bridge the Tezos world (and the Michelson language) with the formal world of Coq. For this, we are going to model a theorem representing a smart contract and its intentions."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://opentezos.com/formal-verification/modeling-theorem"><link data-react-helmet="true" rel="alternate" href="https://opentezos.com/formal-verification/modeling-theorem" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://opentezos.com/formal-verification/modeling-theorem" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5941add9.css">
<link rel="preload" href="/assets/js/runtime~main.ce0c191f.js" as="script">
<link rel="preload" href="/assets/js/main.10173fb8.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo-dark.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/octo-technology/OpenTezos/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">üåô</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">‚òÄÔ∏è</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo-dark.svg" alt="OpenTezos" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a href="https://github.com/octo-technology/OpenTezos/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Welcome</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/">Modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/paths">Paths</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Blockchain Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/main-properties">Main properties of the first &quot;blockchain&quot;</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/proof-of-work">Proof-of-work</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/other-consensuses">Introduction to other consensus algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/smart-contracts">Smart Contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/blockchain-basics/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tezos Basics</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/smart-contracts">Smart contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/liquid-proof-of-stake">Liquid Proof-of-Stake</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/operations">Operations</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/cli-and-rpc">CLI and RPC</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/governance-on-chain">Governance on-chain</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/history-of-amendments">History of amendments</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/economics-and-rewards">Economics and rewards</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/tezos-basics/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Deploy a node</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/deploy-a-node">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/deploy-a-node/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">How to use an Explorer</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/indexer-explained">How Indexers Work?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/available-tezos-indexers">Available Tezos Explorers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/tzstats-main-features">How to use the tzStats blockchain explorer?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/tzstats-smart-contract">Checkout your smart contract on TzStats</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/private-indexer">Private indexer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/explorer/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">SmartPy</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/write-contract-smartpy">Smart contract development with SmartPy</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/smartpy/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">LIGO</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/write-contracts-ligo">Smart contract development in Pascaligo</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/language-basics">Language basics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/deploy-a-contract">Smart Contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/unit-testing">Unit Testing with PyTezos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/examples">Examples</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/exam">Exam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/ligo/take-away">Take Away</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Michelson</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/smart-contracts">Smart Contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/tutorial">Tutorial</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/examples">Examples</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/instructions-reference">Instructions Reference</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/exam">Exam</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/michelson/take-away">Take away</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Build a Dapp</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/truffle_compilation_migration">Smart contract deployment with Truffle</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/taquito">Taquito</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/temple">Temple Wallet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/basics">Build a dapp - basics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/front_user_experience">Build a dapp - User Experience</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/dapp/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Baking</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking/baking_explained">How baking works?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking/reward">Rewards</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking/bakers_list">List of bakers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baking/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Deploy Bakers</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baker">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/baker/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">DeFi</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/token-standards">Token Standards</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/dexs">Decentralized Exchanges</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/wrapped-assets">Wrapped Assets</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/cross-chain-swaps">Cross-chain Swaps</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/oracles">On-chain Oracles</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/stablecoins">Stablecoins</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/synthetics">Synthetics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/lending">Lending and Flash Loans</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/defi/exam">Exam</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Formal Verification</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification/gadt-coq">Coq, GADT and Mi-Cho-Coq</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/formal-verification/modeling-theorem">Formal verification on smart contracts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/formal-verification/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Private Blockchain</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/private">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/private/exam">Exam</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">How to contribute</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute">Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/report-issue">Report an issue</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/opentezos">Contribute to OpenTezos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/tezos-core">Contribute to the Tezos Core Protocol</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/grant">Receive a grant</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/baker">Become a baker or a delegator</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/contribute/exam">Exam</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Formal verification on smart contracts</h1></header><div class="markdown"><p>This section describes how to bridge the Tezos world (and the Michelson language) with the formal world of <em>Coq</em>. For this, we are going to model a theorem representing a smart contract and its intentions.
// TODO: Is intention the right word there? Seems weird. &quot;Interactions&quot; maybe?</p><p>This chapter is based on the <em>Vote</em> smart contract seen in <a href="/ligo">previous modules</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="overview"></a>Overview<a class="hash-link" href="#overview" title="Direct link to heading">#</a></h2><p>The Tezos blockchain can run smart contracts using the Michelson language. Michelson is a low-level stack-based Turing-complete language that is formally proven. The proof of Michelson language is compiled in a library called <strong>Mi-Cho-Coq</strong> (check the official documentation <a href="/formal-verification/modeling-theorem#references">[2]</a>). </p><p><em>Mi-Cho-Coq</em> is based on the <em>Curry-Howard isomorphism</em> (<a href="/formal-verification/modeling-theorem#references">[5] [6] [7]</a>), which ensures the correspondence between a program and a theorem. <em>Mi-Cho-Coq</em> is used in the <em>coq</em> proof assistant to translate a Michelson script into a theorem (i.e., into its logical equivalent form). The official documentation of <em>Coq</em> can be found here <a href="/formal-verification/modeling-theorem#references">[1]</a>, but we recommend easier-to-read documentation such as this introduction to <em>Coq</em> <a href="/formal-verification/modeling-theorem#references">[3]</a>.</p><blockquote><p>The Coq proof assistant is built upon the paradigm of <strong>calculus of constructions</strong> (as described by Thierry Coquand <a href="/formal-verification/modeling-theorem#references">[16]</a>). The <em>Gallina</em> language <a href="/formal-verification/modeling-theorem#references">[4]</a> (the language allowing to interact with the Coq engine) provides a syntax (Terms) for describing formal objects (like a theorem) and also provides a set of instructions (Vernacular syntax) called <em>tactics</em> for writing the proof of the theorem.</p></blockquote><p>The formal verification of a Michelson smart contract is done by providing the proof for this theorem. <em>Coq</em> will perform the verification of a given proof (and its related theorem) based on the <em>Mi-Cho-Coq</em> proof.</p><p>The proof consists of a sequence of <em>tactics</em> which the Coq engine will interpret. These instructions manipulate formal expressions (following logical laws (<em>Coq</em> universe) and <em>Mi-Cho-Coq</em> definitions) to formally assert the truth of a given theorem (based on given assumptions).</p><p>Before going deeper, let&#x27;s illustrate the workflow of formal verification of Tezos smart contracts in Fig. 1 below.</p><p><img src="/assets/images/overview_process-52c2f563b6e0308a203a07088e7719bb.svg"></p><small class="figure">FIGURE 1: Proof process</small><p>//TODO: Add more explanations about this schema. Why is proof in Vernacular and Theorem in Terms as they are both in Gallinea?</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="modeling-a-smart-contract-as-a-theorem"></a>Modeling a smart contract as a theorem<a class="hash-link" href="#modeling-a-smart-contract-as-a-theorem" title="Direct link to heading">#</a></h2><p>This ecosystem combines an assistant of proof (<em>Coq</em>) and the proof of the Michelson language (<em>Mi-Cho-Coq</em>) to formally verify the correctness of a theorem and its proof.</p><p>The theorem is based on </p><ul><li>a Michelson script representing what the smart contract does.</li><li>post-conditions representing the rules of the smart contract in a formal form.</li></ul><p>Formal verification of a Tezos smart contract consists of verifying formally that <strong>the execution of the Michelson script satisfies specific post-conditions</strong>.</p><p><img src="/assets/images/overview_theorem-50dae61bbd0263d8c84f665bb635e3f7.svg"></p><small class="figure">FIGURE 2: Naive description of the theorem</small><p>//TODO: Add more explanations about this schema. What are A, B, C, D ???</p><p>In the following sections, we will detail how the execution of a Michelson script can be formally written and how to define post-conditions. We will then study the formal proof as a sequence of <em>Coq</em> tactics (cf. the <em>Vernacular</em> part of the Gallina language).</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="smart-contract-invocation"></a>Smart contract invocation<a class="hash-link" href="#smart-contract-invocation" title="Direct link to heading">#</a></h3><p>Tezos smart contract can be written LIGO or SmartPy but are utimatly compiled in Michelson.</p><p>A smart contract invocation requires the smart contract itself, the entrypoint that is being called (and its related arguments) and the storage state.</p><p>If all these elements are provided, the execution of the smart contract code is triggered, which will result in side-effects on the storage and optionally on the Tezos network.</p><p><img src="/assets/images/smartcontract_invocation-2a3848180be26f7c3bafb797140f72ad.svg"></p><small class="figure">FIGURE 3: Execution of an entrypoint of a smart contract triggering its code and thus side-effect on storage and Tezos network.</small><p>The entrypoint information is used to identify which portion of the code will be executed.
The entrypoint arguments and the storage are used as the context of execution (i.e, the execution stack is initialized with arguments and a storage).
The execution of the code produces a new storage state and operations.
The operations produced by this invocation are some new invocations of other smart contracts.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="formally-modeling-the-execution-of-a-tezos-smart-contract"></a>Formally modeling the execution of a Tezos smart contract<a class="hash-link" href="#formally-modeling-the-execution-of-a-tezos-smart-contract" title="Direct link to heading">#</a></h3><p>Now let&#x27;s see how to formulate formally <strong>the execution of the Michelson script</strong>. </p><p>As we have seen, the <strong>the execution of the Michelson script</strong> produces a new storage state (we consider there are no operations produced). </p><p>So, formally speaking:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">EXECUTION(CODE,arguments,storage) produces a new storage </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>The execution of code is done by evaluating a sequence of Michelson instruction for a given initial stack (an <code>eval</code> function is provided by <em>Coq</em>). The execution of code also requires a context and a quantity of gas to be able to execute each instruction (requirement defined by <em>Mi-Cho-Coq</em>). So the execution of code can be formalized as:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">eval env CODE fuel (arguments,storage) = return (newstorage)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>where:</p><ul><li><code>fuel</code> represents the quantity of gas.</li><li><code>env</code> represents a context of evaluation for the Coq engine.</li><li><code>eval</code> represents an evaluator which effectively executes each instruction sequentially on the provided initial stack.</li><li><code>arguments</code> represents the parameter (entrypoint) and its related arguments.</li><li><code>storage</code> represents the storage state before the execution.</li><li><code>newstorage</code> represents the resulting storage after the execution.</li></ul><p>The theorem can be formalized as:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">eval env CODE fuel (arguments, storage) = return (newstorage) &lt;=&gt; post-conditions</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>where <code>&lt;=&gt;</code> represents an equivalence</p><p>Now let&#x27;s see how to define post-conditions.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="post-conditions"></a>Post-conditions<a class="hash-link" href="#post-conditions" title="Direct link to heading">#</a></h3><p>Post-conditions are logical assertions that model the intention of the smart contract. In other words, post-conditions are logical expressions defining constraints to verify on storage data.</p><p>The work is to identify rules (or constraints) that ensure the correctness of the execution (i.e., ensure that the storage cannot end up in an invalid state).</p><p>In fact, post-conditions are usually multiple assertions combined with a logical <em>AND</em> operator ( <code>^</code> in <em>Coq</em>).</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">post-conditions &lt;=&gt; A ^ B ^ C ^ D</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Since post-conditions are a generic concept formalizing the smart contract intention as logical assertions, we will use an example in order to illustrate the modeling ofpost-conditions.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="example-vote"></a>Example Vote<a class="hash-link" href="#example-vote" title="Direct link to heading">#</a></h3><p>Let&#x27;s consider a very simple <em>Vote</em> smart contract that handles a voting process. The complete implementation of the theorem and its proof are available at <a href="/formal-verification/modeling-theorem#references">[20]</a>. In this section, we explain the &quot;Vote&quot; reference example. The <em>Vote</em> smart contract allows anyone to vote for a candidate (we consider that candidates are registered and their number of votes is initialized to zero).</p><p>When someone invokes the smart contract, one must indicate the candidate. If the candidate is registered then its corresponding number of votes is incremented.</p><blockquote><p>The <em>Vote</em> smart contract will only modify its storage and thus will have no impact on the rest of the network (i.e. the execution of the smart contract will not produce operations).
//TODO: Voting itself isn&#x27;t an operation?</p></blockquote><p>Here is the code of the smart contract:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">{</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    parameter (string %vote);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    storage (map string int);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    code {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        AMOUNT;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        PUSH mutez 5000000;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        COMPARE; GT;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        IF { FAIL } { NOOP };</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        DUP; DIP { CDR; DUP }; CAR; DUP;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        DIP {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            GET; ASSERT_SOME;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">            PUSH int 1; ADD; SOME</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        };</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        UPDATE;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        NIL operation; PAIR</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Notice that candidates are identified by a <code>string</code> value (entrypoint argument) and the storage is a <code>map string int</code>.</p><p>Notice that amount of XTZ transferred must be lower than five million; otherwise the execution fails.</p><p>Notice also that the candidate must be registered; otherwise the execution fails.</p><p>This very simple script is equivalent to this pseudo-code:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">candidate is string</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">storageMap is map(key=string, value=int)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">....</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">function code(amount, candidate, storageMap) : storageMap {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    if (amount &gt; 5000000)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        fail()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    else if (candidate not in storageMap)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        fail()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    else </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        storageMap[candidate] += 1;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    return storageMap;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><code>amount</code> and <code>candidate</code> are given as arguments.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="parameter-definition"></a>Parameter definition<a class="hash-link" href="#parameter-definition" title="Direct link to heading">#</a></h4><p>The parameter type and storage type can be defined in <em>Coq</em> as two distinct definitions:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Definition parameter_ty : type := string.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Definition storage_ty := map string int.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>The parameter type (<code>parameter_ty</code>) can be wrap into a <code>SelfType</code> definition as follow:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Module ST : (SelfType with Definition self_type := parameter_ty).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  Definition self_type := parameter_ty.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">End ST.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>It will be used when defining the smart contract.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="annotated-script"></a>Annotated script<a class="hash-link" href="#annotated-script" title="Direct link to heading">#</a></h4><p>The Tezos smart contract is a Michelson script but it cannot be taken as input by the Coq engine as it is.</p><p>Mi-Cho-Coq (which is the Coq specification of the Michelson language) provides the correspondence between a Michelson instruction and an equivalent logical proposition.</p><p>//TODO: So is this automated? You give the Michelson code to mi-cho-coq and it automatically transpiles it into a coq code?</p><p>The <em>Vote</em> smart contract can be formalized in a formal definition in Coq (Terms).
//TODO: I thought coq languge was galina?</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Definition vote : full_contract _ ST.self_type storage_ty :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">(</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    AMOUNT ;;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    PUSH mutez (5000000 ~mutez);;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    COMPARE;; GT;;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    IF ( FAIL ) ( NOOP );;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    DUP;; DIP1 ( CDR;; DUP );; CAR;; DUP;;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    DIP1 (</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      GET (i := get_map string int);; ASSERT_SOME;;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      PUSH int (Int_constant 1%Z);; ADD (s := add_int_int);; SOME</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    );;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    UPDATE (i := Mk_update string (option int) (map string int) (Update_variant_map string int));;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    NIL operation;; PAIR </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">).</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This <code>vote</code> definition will be used to formalize the theorem. Notice that it takes the parameter and storage types (<code>parameter_ty</code>, <code>storage_ty</code>) as arguments.</p><p>Notice that <code>GET</code>, <code>UPDATE</code>, <code>ADD</code> and <code>PUSH</code> instructions are annotated:</p><ul><li><code>ADD (s := add_int_int)</code> indicates it is an addition between two integers.</li><li><code>GET (i := get_map string int)</code> indicates it accesses elements into a <code>map string int</code>. </li><li><code>UPDATE (i := Mk_update string (option int) (map string int) (Update_variant_map string int))</code> indicates it updates (<code>Mk_update</code>) a <code>map</code> with a <code>string</code> as key and an <code>option int</code> as value.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="post-conditions-1"></a>Post-conditions<a class="hash-link" href="#post-conditions-1" title="Direct link to heading">#</a></h4><p>As said previously, post-conditions are logical expressions defining constraints to verify on the storage data.</p><p>In our example <em>Vote</em> smart contract, the storage is a map containing the number of votes per candidate.</p><p>Let&#x27;s see how we can define logical assertions on the storage data.</p><p>First, let&#x27;s define some rules governing the voting process:</p><ul><li>&quot;When someone votes for a candidate, its number of votes increments by 1&quot;.</li><li>&quot;When someone votes for a candidate, the number of votes of other candidates does not change&quot;.</li><li>&quot;When someone votes for a candidate, it does not change the list of candidates&quot;.</li><li>&quot;If the voting process is successful, then it means that the candidate is registered&quot;.</li><li>&quot;Invoking this smart contract does not impact the rest of the Tezos network, only the related storage&quot;.</li></ul><p>Now, these rules can be translated into formal propositions. These propositions depend on the given parameter, the current storage state and the new storage state (and the produced operations).</p><p><img src="/assets/images/postconditions_rules-2f0d3d2b3522dfda9dd03db41f2ad3d8.svg"></p><small class="figure">FIGURE 4: Post conditions of _Vote_ smart contract.</small><p>The rule &quot;Keys of the old storage exists in the new storage&quot; can be written in Coq (Gallina - Terms) with the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">(forall s, (mem _ _ (Mem_variant_map _ int) s storage) &lt;-&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        (mem _ _ (Mem_variant_map _ int) s new_storage))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This expression verifies that all keys of the old storage are defined in the new storage.</p><p>The rule &quot;For Bob, number of votes is incremented&quot; can be formulated as: &quot;For each element of the mapping whose key is equal to the given parameter, the new value must be equal to the old value plus one&quot;. It can be written in Coq (Gallina - Terms) with the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">match (get _ _ _ (Get_variant_map _ int) param storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | Some n1 =&gt; match (get _ _ _ (Get_variant_map _ int) param new_storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | Some n2 =&gt; n2 = (BinInt.Z.add n1 1)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | None =&gt; False</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              end</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | None =&gt; False end</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>The rule &quot;For others, number of votes do not change&quot; can be formulated as: &quot;For each element of the mapping different from the given parameter, ensure that the old value is equal to the new value&quot;. It can be written in Coq (Gallina - Terms) with the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">(forall s, s &lt;&gt; param -&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">   match (get _ _ _ (Get_variant_map _ int) s storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | Some n1 =&gt; match (get _ _ _ (Get_variant_map _ int) s new_storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | Some n2 =&gt; n2 = n1</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | None =&gt; False</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              end</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | None =&gt; True end)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>The rule &quot;Only the storage is modified&quot; can be expressed by verifying that no operations have been produced. It can be written in Coq (Gallina - Terms) with the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">returned_operations = nil</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>As seen previously, the smart contract can be executed only if the amount of XTZ transferred is lower than 5000000; otherwise the execution fails. This constraint can be written in Coq (Gallina - Terms) with the following:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">(Z.ge (tez.to_Z (amount env)) 5000000)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>To sum up, our post-conditions are a combination of all these logical rules merged into a single object which depends on the given old storage state and parameter, and the resulting new storage state (and the returned operations).</p><p>This object <code>vote_spec</code> represents the post-conditions of the voting process: </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Definition vote_spec</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           (storage: data storage_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           (param : data parameter_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           (new_storage : data storage_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           (returned_operations : data (list operation)) :=</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  (* Preconditions *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  (Z.ge (tez.to_Z (amount env)) 5000000) /\</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  mem _ _ (Mem_variant_map _ int) param storage /\</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  (* Postconditions *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  (forall s, (mem _ _ (Mem_variant_map _ int) s storage) &lt;-&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        (mem _ _ (Mem_variant_map _ int) s new_storage)) /\</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  returned_operations = nil /\</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  match (get _ _ _ (Get_variant_map _ int) param storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | Some n1 =&gt; match (get _ _ _ (Get_variant_map _ int) param new_storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | Some n2 =&gt; n2 = (BinInt.Z.add n1 1)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | None =&gt; False</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              end</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | None =&gt; False end /\</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  (forall s, s &lt;&gt; param -&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">   match (get _ _ _ (Get_variant_map _ int) s storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | Some n1 =&gt; match (get _ _ _ (Get_variant_map _ int) s new_storage) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | Some n2 =&gt; n2 = n1</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              | None =&gt; False</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              end</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  | None =&gt; True end).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  </span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Notice that the <code>vote_spec</code> definition above express logical assertions depending on:</p><ul><li>the initial storage state (<code>storage</code>)</li><li>the returned storage state (<code>new_storage</code>)</li><li>the parameter (<code>param</code>)</li><li>the returned operations (<code>returned_operations</code>)</li></ul><p>To conclude, the <em>Vote</em> smart contract is defined by the <code>vote_spec</code> definition and can be used to formalize the theorem.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="theorem-definition"></a>Theorem definition<a class="hash-link" href="#theorem-definition" title="Direct link to heading">#</a></h4><p>As said previously, the formal verification of a Tezos smart contract consists of verifying formally that <strong>the execution of the Michelson script satisfies specific post-conditions</strong>.</p><p>Also, as said previously, the theorem can be formalized as:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">eval env CODE fuel (arguments, storage) = return (newstorage) &lt;=&gt; post-conditions</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Here is a schema describing graphically the theorem formalization:</p><p><img src="/assets/images/theorem_graphical-0c7e3ac239c21f872507de8b0867b6de.svg"></p><small class="figure">FIGURE 5: Description of the theorem.</small><p>Now that we have defined the post-conditions to verify, we can define the theorem in Gallina (Terms) syntax.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Theorem vote_correct</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      (storage : data storage_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      (param : data parameter_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      (new_storage : data storage_ty)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      (returned_operations : data (list operation))</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      (fuel : Datatypes.nat) :</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  fuel &gt;= 42 -&gt;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  eval env vote fuel ((param, storage), tt) = Return ((returned_operations, new_storage), tt)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  &lt;-&gt; vote_spec storage param new_storage returned_operations.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Notice that the <code>vote</code> object represents our smart contract (in a formal representation).</p><p>Notice also that the <code>vote_spec</code> object represents the post-conditions to verify (in a formal representation).</p><p>We can represent this equivalence between the execution of the code and the verification of post-conditions by the following diagram.</p><p><img src="/assets/images/theorem_graphical_detail-50483736505c58b9269b735adc7ab62c.svg"></p><small class="figure">FIGURE 6: Detailed description of the theorem.</small><p>Notice that the <code>vote_spec</code> definition is used as post condition and requires 4 arguments (<code>storage</code>, <code>param</code>, <code>new_storage</code>, <code>returned_operations</code>). </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="proof"></a>Proof<a class="hash-link" href="#proof" title="Direct link to heading">#</a></h2><p>Now that the intention of our smart contract has been modeled into post-conditions and that our smart contract has been translated into a theorem (which combines evaluation of a sequence of Michelson instruction and those logical post-conditions), we need to prove that this theorem is true.</p><p>The demonstration or proof of the theorem can be expressed with a sequence of <em>Coq</em> tactics.</p><p>Since the theorem is a complex logical proposition, it is suggested to decompose it into simpler propositions easily provable. This decomposition is done by separating into smaller independent propositions or applying reductions (see reductions in Gallina <a href="/formal-verification/modeling-theorem#references">[4]</a>).</p><p>The following proof script relies on:</p><ul><li>tactics (commands of the Vernacular of Gallina) </li><li>induced types (Mi-Cho-Coq)</li><li>proven theorem of Mi-Cho-Coq dealing with Tezos smart contract properties (e.g. gas)</li><li>the <em>Coq</em> universe, which defines sets of numbers and related theorem. For example, natural integers are defined upon the <em>Peano</em> arithmetic.</li></ul><p>Here is the proof of the Vote smart contract.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Proof.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  intro Hfuel. unfold &quot;&gt;=&quot; in Hfuel.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  unfold eval.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  rewrite return_precond.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  rewrite eval_precond_correct.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  do 15 (more_fuel; simpl).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  rewrite if_false_not.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  apply and_both_0.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  - change (tez.compare (5000000 ~Mutez) (amount env)) with</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        (5000000 ?= (tez.to_Z (amount env)))%Z.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    rewrite Z.compare_antisym.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    unfold &quot;&gt;=&quot;%Z.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    destruct (tez.to_Z (amount env) ?= 5000000)%Z; simpl; intuition discriminate.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  - (* Enough tez sent to contract *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    destruct (map.get str Z string_compare param storage) eqn:mapget.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    + (* Key is in the map *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      more_fuel; simpl.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      split; intros.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      * (* -&gt;  *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        simpl in *.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        repeat split; inversion H.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- apply map.map_getmem with z; assumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- intro Hstor.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           apply map.map_updatemem.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           assumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- intro Hnstor.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           destruct (string_compare s param) eqn:strcomp.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite string_compare_Eq_correct in strcomp; subst.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           apply map.map_getmem with z. assumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           eapply map.map_updatemem_rev with (k&#x27;:= param).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite &lt;- (compare_diff string). left. eassumption. eassumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           eapply map.map_updatemem_rev with (k&#x27;:= param).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite &lt;- (compare_diff string). right. eassumption. eassumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- reflexivity.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- rewrite mapget.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite map.map_updateeq.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           destruct z; try destruct p; reflexivity.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- intros s Hneq.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           destruct (map.get str Z string_compare s storage) eqn:mapget2.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite map.map_updateneq.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite mapget2. reflexivity. intro contra. subst; contradiction.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           constructor.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      * (* &lt;- *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        repeat simpl.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        destruct H as [H1 [H2 [H3 [H4 H5]]]].</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        repeat f_equal.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- symmetry. assumption.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        -- symmetry.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           rewrite map.map_updateSome_spec.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           split.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           ++ unfold get, semantics.get in H5; simpl in H5.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              simpl in *.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              destruct (map.get str Z string_compare param storage); destruct (map.get str Z string_compare param new_storage); subst;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                try inversion H4.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              inversion mapget; subst. rewrite BinInt.Z.add_comm. reflexivity.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">           ++ simpl in *.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              clear H4.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              intros s Hdiff. specialize (H5 s).</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              assert (s &lt;&gt; param) as Hdiff2 by (intro contra; rewrite contra in Hdiff; contradiction);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                apply H5 in Hdiff2.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              unfold get, semantics.get in Hdiff2. simpl in Hdiff2.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              destruct (map.get str Z string_compare s storage) eqn:get1;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                destruct (map.get str Z string_compare s new_storage) eqn:get2; subst;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">                  try reflexivity.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              inversion Hdiff2.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              exfalso. clear H5.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              apply map.map_getmem in get2.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              rewrite &lt;- H2 in get2. apply map.map_memget in get2. destruct get2 as [v get2].</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">              rewrite get2 in get1. discriminate get1.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  + (* Key is not in the map *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    more_fuel; simpl.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">               split; intros.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      * (* -&gt; *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        inversion H.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      * (* &lt;- *)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        destruct H as [H1 [H2 [H3 [H4 H5]]]].</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        apply map.map_memget in H1. destruct H1 as [v H1].</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">        simpl in H1. rewrite H1 in mapget. discriminate mapget.</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Qed.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>This chapter is not intended to be a <em>Coq</em> tutorial, we will not deep further into this script. If you want to look into proof implementation in <em>Coq</em>, we recommend these simple tutorials <a href="/formal-verification/modeling-theorem#references">[3]</a>, <a href="/formal-verification/modeling-theorem#references">[14]</a> as a start and the Coq&#x27;Art book <a href="/formal-verification/modeling-theorem#references">[15]</a> for a more complete overview. </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="conclusion"></a>Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">#</a></h2><p>//TODO: Conclusion, small summary of this chapter and how to learn more</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="references"></a>References<a class="hash-link" href="#references" title="Direct link to heading">#</a></h2><p>[1] Coq - <a href="https://coq.inria.fr/distrib/current/refman/index.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/index.html</a></p><p>[2] Mi-cho-coq repository - <a href="https://gitlab.com/nomadic-labs/mi-cho-coq" target="_blank" rel="noopener noreferrer">https://gitlab.com/nomadic-labs/mi-cho-coq</a></p><p>[3] Introduction to Coq - <a href="http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf" target="_blank" rel="noopener noreferrer">http://www-sop.inria.fr/members/Yves.Bertot/courses/introcoq.pdf</a></p><p>[4] Gallina - <a href="https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/language/gallina-specification-language.html</a></p><p>[5] Lambda-Calculus and Isomorphism Curry-Howard - <a href="http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf" target="_blank" rel="noopener noreferrer">http://disi.unitn.it/~bernardi/RSISE11/Papers/curry-howard.pdf</a></p><p>[6] Isomorphism Curry-Howard for Dummies - <a href="https://www.p%C3%A9drot.fr/slides/inria-junior-02-15.pdf" target="_blank" rel="noopener noreferrer">https://www.p√©drot.fr/slides/inria-junior-02-15.pdf</a></p><p>[7] Isomorphism Curry-Howard (small) - <a href="https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf" target="_blank" rel="noopener noreferrer">https://www.seas.harvard.edu/courses/cs152/2015sp/lectures/lec15-curryhoward.pdf</a></p><p>[8] Higher-order abstract syntax in Coq - <a href="https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps" target="_blank" rel="noopener noreferrer">https://web.archive.org/web/20060830033826/http://www.site.uottawa.ca/~afelty/dist/tlca95.ps</a></p><p>[9] Michelson - <a href="https://tezos.gitlab.io/michelson-reference/" target="_blank" rel="noopener noreferrer">https://tezos.gitlab.io/michelson-reference/</a></p><p>[10] Logique formelle - <a href="https://www.irif.fr/~roziere/2ord/2ndordre.pdf" target="_blank" rel="noopener noreferrer">https://www.irif.fr/~roziere/2ord/2ndordre.pdf</a></p><p>[12] Axioms de Peano - <a href="https://fr.wikipedia.org/wiki/Axiomes_de_Peano" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Axiomes_de_Peano</a></p><p>[13] Calculus of constructions - <a href="https://fr.wikipedia.org/wiki/Calcul_des_constructions" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Calcul_des_constructions</a></p><p>[14] Mini-guide Coq - <a href="https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf" target="_blank" rel="noopener noreferrer">https://www.lri.fr/~paulin/MathInfo/coq-survey.pdf</a></p><p>[15] Coq‚ÄôArt - <a href="https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf" target="_blank" rel="noopener noreferrer">https://www.labri.fr/perso/casteran/CoqArt/coqartF.pdf</a></p><p>[16] The calculus of constructions (1988) by Thierry Coquand - <a href="https://www.sciencedirect.com/science/article/pii/0890540188900053" target="_blank" rel="noopener noreferrer">https://www.sciencedirect.com/science/article/pii/0890540188900053</a></p><p>[17] Lambda-calcul - <a href="https://fr.wikipedia.org/wiki/Lambda-calcul" target="_blank" rel="noopener noreferrer">https://fr.wikipedia.org/wiki/Lambda-calcul</a></p><p>[18] Calculus of Inductive Constructions - <a href="https://coq.inria.fr/distrib/current/refman/language/cic.html" target="_blank" rel="noopener noreferrer">https://coq.inria.fr/distrib/current/refman/language/cic.html</a></p><p>[19] Michelson - <a href="https://www.michelson-lang.com/why-michelson.html" target="_blank" rel="noopener noreferrer">https://www.michelson-lang.com/why-michelson.html</a></p><p>[20] Vote example - <a href="https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v" target="_blank" rel="noopener noreferrer">https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/master/src/contracts_coq/vote.v</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/octo-technology/OpenTezos/tree/main/docs/formal-verification/modeling-theorem.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-05-19T22:48:57.000Z" class="lastUpdatedDate_1WI_">5/20/2021</time> by <strong>AymericBethencourt</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/formal-verification/gadt-coq"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Coq, GADT and Mi-Cho-Coq</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/formal-verification/exam"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Exam ¬ª</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#overview" class="table-of-contents__link">Overview</a></li><li><a href="#modeling-a-smart-contract-as-a-theorem" class="table-of-contents__link">Modeling a smart contract as a theorem</a><ul><li><a href="#smart-contract-invocation" class="table-of-contents__link">Smart contract invocation</a></li><li><a href="#formally-modeling-the-execution-of-a-tezos-smart-contract" class="table-of-contents__link">Formally modeling the execution of a Tezos smart contract</a></li><li><a href="#post-conditions" class="table-of-contents__link">Post-conditions</a></li><li><a href="#example-vote" class="table-of-contents__link">Example Vote</a></li></ul></li><li><a href="#proof" class="table-of-contents__link">Proof</a></li><li><a href="#conclusion" class="table-of-contents__link">Conclusion</a></li><li><a href="#references" class="table-of-contents__link">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2021 OpenTezos.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ce0c191f.js"></script>
<script src="/assets/js/main.10173fb8.js"></script>
</body>
</html>